<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>JavaSE进阶重点提炼 | RichardTech</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://geckoc.github.io//favicon.ico?v=1605086324140">
<link rel="stylesheet" href="https://geckoc.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="About Array


Java语言中的数组Array是一种引用数据类型，数组的父类是Object；


数组实际是一种容器，可以同时容纳多个元素（数组是一个数据集合）字面意思是一组数据；


数组当中可以存储基本数据类型，也可以存储引..." />
    <meta name="keywords" content="Exception,JavaNote" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://geckoc.github.io/">
        <img src="https://geckoc.github.io//images/avatar.png?v=1605086324140" class="site-logo">
        <h1 class="site-title">RichardTech</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com" target="_blank">Github</a> | <a class="rss" href="https://geckoc.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">JavaSE进阶重点提炼</h2>
            <div class="post-date">2020-07-25</div>
            
              <div class="feature-container" style="background-image: url('https://geckoc.github.io//post-images/javase-yu-fa-jin-jie-chong-dian-ti-lian.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <h4 id="about-array"><em>About Array</em></h4>
<ol>
<li>
<p>Java语言中的数组Array是一种引用数据类型，数组的父类是Object；</p>
</li>
<li>
<p>数组实际是一种容器，可以同时容纳多个元素（数组是一个数据集合）字面意思是一组数据；</p>
</li>
<li>
<p>数组当中可以存储基本数据类型，也可以存储引用数据类型；</p>
</li>
<li>
<p>数组是引用数据类型，所以数组对象是堆内存当中的； （存放在堆内存中）</p>
</li>
<li>
<p>数组当中如果存储的是&quot;Java对象&quot;的话，实际上存储的是对象的引用(内存地址)；</p>
</li>
<li>
<p>数组一旦创建，长度不可变；（数组长度不可变）</p>
</li>
<li>
<p>数组的分类：一维数组、二维数组、三维数组....</p>
</li>
<li>
<p>所有数组都有length属性(Java自带的)，用来获取数组中元素的个数；</p>
</li>
<li>
<p>Java中数组中元素要求类型统一</p>
</li>
<li>
<p>数组在内存方面存储的时候，数组中的元素内存地址是连续的（有规律的，排列好的）紧挨着的，数组是一种数据结构</p>
</li>
<li>
<p>数组中首元素的内存地址作为整个数组对象的内存地址</p>
</li>
<li>
<p>数组中每一个元素都是有下标的,下标从0开始，以1递增，最后一个元素的下标是: length-1;</p>
</li>
<li>
<p>数组这种数据结构的优点和缺点？</p>
<ul>
<li>
<p>优点：查询/检索某个下标上的元素时效率极高，可以说是查询效率最高的一个数据结构；</p>
</li>
<li>
<p><strong>为什么查询效率高？</strong><br>
1、每一个元素的内存地址在空间存储上是连续的；<br>
2、每一个元素的类型相同，所以占用空间相同；<br>
3、知道第一个元素内存地址，知道元素占用空间，知道下标，可通过数学表达式快速计算<br>
出某一个下标上元素的内存地址，直接定位所以效率是最高的；</p>
<p>数组中存储100个元素，或者100万个元素，在查询/检索方面，效率是相同的；</p>
</li>
<li>
<p>缺点：由于数组上元素的内存地址是连续的，所以在数组上随机增删元素时，效率较低，因增删元素会涉及到后面元素统一向前或向后位移的操作；</p>
</li>
<li>
<p>数组不能存储大数据类型，为什么？</p>
<ul>
<li>因为很难在内存空间上找到一块特别大的连续的内存空间</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意：对于数组最后一个元素的增删，效率是不会影响的</strong></p>
<hr>
<pre><code>//		静态初始化数组
		int[] i = {12,123,124,325,523};
		for (int j = 0; j &lt; i.length; j++) {
			System.out.println(i[j]);
		}
		System.out.println(i[i.length-1]);
		
//		动态初始化数组
		Object[] obj = new Object[5];
		for (int j = 0; j &lt; obj.length; j++) {
			System.out.println(obj[j]);
		}
</code></pre>
<pre><code>/*
 * 	一维数组深入理解：数组中存储的类型为引用数据类型
 * 	对于数组来说，实际上只能存户java对象的“内存地址”，
 * 	数组中存储的每个元素是“引用”
 */
public class ArrayDeep01 {
	public static void main(String[] args) {
		Animal a1 = new Animal();
		Animal a2 = new Animal();
		Animal[] animals = {a1 , a2};
		for (int i = 0; i &lt; animals.length; i++) {
//			Animal animal = animals[i];
//			animal.move();
			animals[i].move(); // 代码合并
			//animals是一个数组 。
			//animals[0]是数组中的一个元素 所以可以调用move()方法
		}
		
		Animal[] anis = new Animal[3];
		anis[0] = new Animal();
//		anis[1] = new Product();类型不匹配，无法转换 数值中元素要求数据类型统一
		anis[2] = new Cat(); // Animal数组中可以存放Cat，因为Cat是Animal的子类
		anis[1] = new Bird(); //多态父类型引用指向子类型对象
		
		anis[0].move();
		anis[1].move();
		anis[2].move();
		System.out.println(&quot;--------------&quot;);
//		当使用子对象特有方法时，需向下类型转换   
		for (int i = 0; i &lt; anis.length; i++) {
			if (anis[i] instanceof Cat) {
				Cat cat = (Cat)anis[i];
				cat.catchMouse();
			}else if (anis[i] instanceof Bird) {
				Bird bird = (Bird)anis[i];
				bird.fly();
			}
		}
	}

}
class Animal{
	public void move() {
		System.out.println(&quot;Animal move...&quot;);
	}
}
class Product{
	
}

class Cat extends Animal{
	public void move() {
		System.out.println(&quot;Cat move...&quot;);
	}
	public void catchMouse() {
		System.out.println(&quot;猫抓老鼠&quot;);
	}
}

class Bird extends Animal{
	public void move() {
		System.out.println(&quot;Bird fly!!!&quot;);
	}
	public void fly() {
		System.out.println(&quot;鸟儿在翱翔&quot;);
	}
}
</code></pre>
<h6 id="关于java一维数组的扩容">关于Java一维数组的扩容</h6>
<pre><code>public class ArrayDeep02 {
	public static void main(String[] args) {
		//数组是如何进行拷贝的？
//		System.arraycopy(src源, srcPos源的起始位置, dest目标, destPos目标起始位置, length长度); 
		
		int[] src = {1 , 23 , 455 , 21 , 24}; //拷贝源
		int[] dest = new int[20];	//目标		
		
		System.arraycopy(src, 0, dest, 5, src.length);
		
		// 遍历目标数组
		for (int i = 0; i &lt; dest.length; i++) {
			System.out.println(dest[i]);
		}
		
		//数组中存储的元素是引用，也可以拷贝
		String[] str = {&quot;xsax&quot;, &quot;sadasd&quot;, &quot;Hello&quot;, &quot;World&quot;, &quot;Copy&quot;};
		String[] deStrings = new String[10];
		System.arraycopy(str, 0, deStrings, 2, str.length);
		for (int i = 0; i &lt; deStrings.length; i++) {
//			System.out.print(deStrings[i] + &quot;\t&quot;);
		}
		
		Object[] objs = {new Object(), new Object(), new Object()};
		Object[] destObj = new Object[10];
		System.out.println(&quot;============&quot;);
		// 拷贝的是对象的内存地址，不是拷贝对象；
		System.arraycopy(objs, 0, destObj, 2, objs.length);
		for (int i = 0; i &lt; destObj.length; i++) {
			System.out.println(destObj[i]);
		}
	}
}
</code></pre>
<h6 id="关于java中的二维数组">关于Java中的二维数组</h6>
<pre><code>/**
*
* Copyright: Copyright (c) 2020 Richard-Chan
* @Description: 关于Java中的二维数组
* 	1. 二维数组是一个特殊的一维数组，特殊在这个数组中每一个元素都是一个一维数组
* 
* 	2. 三维数组是一个特殊的一维数组，特殊在这个数组中每一个元素都是一个二维数组
* 		实际开发中使用最多的是一维数组，二维数组较少用，三维几乎不用
* 
* 	3. 二维数组静态初始化
*		int[][] y = { {100, 200, 300},{234, 234, 987},{290, 876, 230}, {0 , 1} };
*
*---------------------------------------------------------
 */
public class Array2Dimension01 {
	public static void main(String[] args) {
		// 一维数组
		int[] x = {100, 200, 300};
		System.out.println(x.length); //3
		// 二维数组  ,每一个元素都是一个一维数组
		// 二维数组的length属性
		int[][] y = {
				{100, 200, 300},
				{234, 234, 987},
				{290, 876, 230}, {0 , 1}
			};
		System.out.println(y.length); //4
		System.out.println(y[0].length);//3
	}
}
---------------------------------------------------------------
/*
 *  	关于二维数组的读和改
 *  	a[二维数组中一维数组的下标] [一维数组的下标]
 *  
 *  	a[0][0] 表示二维数组中第一个一维数组中的第一个元素
 *  
 *  	a[3][100] 表示二维数组中第四个一维数组中的第101个元素
 *  
 *  	注意：
 */
public class Array2Dimension02 {
	public static void main(String[] args) {
		int[][] y = {
				{100, 200, 300},
				{234, 234, 987},
				{290, 876, 230}, 
				{0 , 1}
			};
		// 取出二维数组中的元素
		int[] y0 = y[0];
		int x1 = y0[0];
		System.out.println(x1);
		//合并以上代码
		System.out.println(y[0][0]);
		
		//取出第二个一维数组中的第三个元素
		
		//改
		y[0][0] = 999;  //注意下标越界问题
		
	}
}
</code></pre>
<h6 id="二维数组的遍历">二维数组的遍历</h6>
<pre><code>public class Array2Dimension03 {
	public static void main(String[] args) {
		String[][] dimensionArray = {
				{&quot;Java&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;c#&quot;, &quot;PHP&quot;},
				{&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;},
				{&quot;Jack&quot;, &quot;Tom&quot;, &quot;Gilfoyle&quot;, &quot;Denish&quot;, &quot;Richard&quot;}
		};
		
		// 遍历二维数组
		for (int i = 0; i &lt; dimensionArray.length; i++) {  //外层循环 （负责纵向）
//			String[] array = dimensionArray[i]; // 一维数组
			// 遍历一维数组
			for (int j = 0; j &lt; dimensionArray[i].length; j++) {
				System.out.print(dimensionArray[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
}
</code></pre>
<h4 id="about-exception"><em>About Exception</em></h4>
<ul>
<li>什么是异常，异常在Java中的作用
<ol>
<li>程序执行过程中出现的不正常情况，叫做异常</li>
<li>java把异常信息打印输出到控制台，供开发者参考 （信息是JVM打印的）</li>
<li>看到后可以修改，让程序更加完善、健壮</li>
<li>异常在Java中以类的形式存在，只要是类就可以创建对象</li>
</ol>
</li>
</ul>
<p><strong>对于异常的理解</strong></p>
<ul>
<li>
<p>java的异常处理机制</p>
<ol>
<li>
<p>异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？</p>
<ul>
<li>我们可以使用UML图来描述一下继承结构。</li>
<li>画UML图有很多工具，例如：Rational Rose（收费的）、starUML等....</li>
<li>Object</li>
<li>Object下有Throwable（可抛出的）</li>
<li>Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）</li>
<li>Exception下有两个分支：</li>
<li>Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</li>
<li>RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</li>
</ul>
</li>
<li>
<p>编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。</p>
<ul>
<li>编译时异常因为什么而得名？</li>
<li>因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。</li>
<li>所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。</li>
<li>因为异常的发生就是new异常对象。</li>
</ul>
</li>
<li>
<p>编译时异常和运行时异常的区别？</p>
<ul>
<li>
<p>编译时异常一般发生的概率比较高。</p>
<ul>
<li>举个例子：
<ul>
<li>
<p>你看到外面下雨了，倾盆大雨的。</p>
</li>
<li>
<p>你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。</p>
</li>
<li>
<p>而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。</p>
</li>
<li>
<p>“拿一把伞”就是对“生病异常”发生之前的一种处理方式。</p>
</li>
<li>
<p>对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>运行时异常一般发生的概率比较低。</p>
<ul>
<li>举个例子：
<ul>
<li>小明走在大街上，可能会被天上的飞机轮子砸到。</li>
<li>被飞机轮子砸到也算一种异常。</li>
<li>但是这种异常发生概率较低。</li>
<li>在出门之前你没必要提前对这种发生概率较低的异常进行预处理。</li>
<li>如果你预处理这种异常，你将活的很累。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。</p>
</li>
<li>
<p>假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，</p>
</li>
<li>
<p>所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？</p>
<ul>
<li>首先，如果这样的话，程序肯定是绝对的安全的。</li>
<li>但是程序员编写程序太累，代码到处都是处理异常的代码。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编译时异常还有其他名字：</p>
<ul>
<li>受检异常（受控异常）：CheckedException</li>
</ul>
</li>
<li>
<p>运行时异常还有其它名字：</p>
<ul>
<li>未受检异常（非受控异常）：UnCheckedException</li>
</ul>
</li>
<li>
<p>再次强调：所有异常都是发生在运行阶段的。</p>
</li>
<li>
<p>Java语言中对异常的处理包括两种方式：</p>
<ul>
<li>
<p>第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。抛给上一级。</p>
</li>
<li>
<p>第二种方式：使用try..catch语句进行异常的捕捉。这件事发生了，谁也不知道，因为我给抓住了。</p>
</li>
<li>
<p>举个例子：</p>
<ul>
<li>
<p>我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，“损失1000元”这可以看做是一个异常发生了。我有两种处理方式，</p>
</li>
<li>
<p>第一种方式：我把这件事告诉我的领导【异常上抛】</p>
</li>
<li>
<p>第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】</p>
</li>
<li>
<p>张三 --&gt; 李四 ---&gt; 王五 --&gt; CEO</p>
</li>
</ul>
</li>
<li>
<p>思考：</p>
<ul>
<li>异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要</li>
<li>对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</p>
</li>
<li>
<p>不建议在main()方法中调用 throws 上抛异常，因为一旦出现异常</p>
</li>
</ol>
<ul>
<li>main()会直接抛给JVM，终止程序运行</li>
<li>在main方法中一般使用 try...catch 捕捉异常</li>
<li>throws()可以上抛多个异常，以逗号隔开</li>
</ul>
</li>
</ul>
<pre><code>* 异常对象中两个非常重要的方法
* 		1、获取异常的描述信息
* 			String msg = exception.getMessage(); 
* 
*		2、打印异常追踪的堆栈信息
*			e.printStackTrace();
/**
* Copyright: Copyright (c) 2020 Richard-Chan
* 
* @Description: 深入理解 try ... catch..
*		1、catch后面的异常类型可以是具体异常类型也可以是父类
*		2、catch后面可以写多个，建议catch的时候精确的一个个处理，利于调试
*		3、catch写多个的时候，自上而下必须遵守从小到大的原则
*
*---------------------------------------------------------
 */
public class TryCatchDeep {
	public static void main(String[] args) {
		try {
			FileInputStream fis = new FileInputStream(&quot;&quot;);
			fis.read();
			fis.close();
		} catch (FileNotFoundException e) {
			System.out.println(&quot;文件不存在&quot;);
		} catch (IOException e) {
			e.printStackTrace();
		}
		tryCatch();
	}
	
	/*
	 * 	JDK8中的新特性，可以使用 | 或 捕捉多个异常
	 */
	public static void tryCatch() {
		try {
			FileInputStream fis = new FileInputStream(&quot;&quot;);
			System.out.println(fis);
			System.out.println(100 / 0);
		} catch (FileNotFoundException | ArithmeticException | NullPointerException e) {
			System.out.println(&quot;文件不存在？算数异常？空指针异常？都有可能&quot;);
		}
	}
}
</code></pre>
<p><strong><em>Finally</em> 语句</strong></p>
<pre><code>/*      关于try...catch...中的子句Finally
*		1、即使try中出现异常，在finally子句中的代码是最后执行且一定会执行的
*			
*		2、而且必须和try...catch语句一起使用
*
*		3、通常在finally语句中完成资源的释放/关闭,因为finally语句中的代码比较有保障
 * try不可以单独使用
 * finally语句可以和try联合使用
 * finally语句中的代码是一定会执行的
 * exit()可以终止finally
 * 
 */
public class FinallyTry {
	public static void main(String[] args) {
		
		/*
		 * 	以下代码执行顺序：
		 * 	try &gt; finally &gt; return
		 * 	finally语句中即使有return也会执行
		 * 	finally语句
		 */
		try {
			System.out.println(&quot;try....&quot;);
//			System.exit(0); 退出JVM，finally语句不执行
			return;
		} finally {
			System.out.println(&quot;finally...&quot;);
		}
		//以下代码一定不会执行，所以编译错误，上面已经执行return
		//System.out.println(&quot;Hello Gilfoyle&quot;);
	}
}
</code></pre>
<p><strong><em>Finally</em></strong> <strong>面试题</strong></p>
<pre><code>public class FinallyInterview {
	public static void main(String[] args) {
		int result = finallyIV();
		System.out.println(result); // 100
	}
	/*
	 * Java语法规则，必须遵循自上而下的原则
	 * return语句必须保证是最后执行的
	 * return语句一旦执行整个方法必须结束
	 */
	public static int finallyIV() {
		int i = 100;
		try {
			return i;
		} finally {
			i++;
		}
	}
}
</code></pre>
<p><strong><em>final、finally、finalize</em></strong> <strong>的区别</strong></p>
<ul>
<li>final（关键字）</li>
<li>final 修饰的变量无法重新赋值</li>
<li>final 修饰的类无法继承</li>
<li>final 修饰的方法无法覆盖（重写）</li>
<li>finally（关键字）</li>
<li>finally和try一起联用</li>
<li>finally语句块中的代码是必须执行的</li>
<li>finalize （标识符）是一个Object类中的方法名, 这个方法是由垃圾回收器GC调用的</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://geckoc.github.io/tag/4IKWkCHYr/" class="tag">
                    Exception
                  </a>
                
                  <a href="https://geckoc.github.io/tag/m3MrWnh7T/" class="tag">
                    JavaNote
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/">
                  <h3 class="post-title">
                    Java多线程模拟车站售票
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'efb43fc5663c1b20fb9a',
        clientSecret: 'ae39da7462f16dfbada5371e0181900ef4faf543',
        repo: 'blogCommon',
        owner: 'Geckoc',
        admin: ['Geckoc'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
