<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geckoc.github.io/</id>
    <title>RichardTech</title>
    <updated>2021-01-07T01:08:43.386Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geckoc.github.io/"/>
    <link rel="self" href="https://geckoc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://geckoc.github.io/images/avatar.png</logo>
    <icon>https://geckoc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, RichardTech</rights>
    <entry>
        <title type="html"><![CDATA[JQuerySummary]]></title>
        <id>https://geckoc.github.io/post/jquerysummary/</id>
        <link href="https://geckoc.github.io/post/jquerysummary/">
        </link>
        <updated>2021-01-06T13:38:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="文本操作">文本操作</h3>
<pre><code class="language-javascript">html()//取得第一个匹配元素的html内容，包含标签内容
html(val)//设置所有匹配元素的html内容，识别标签，能够表现出标签的效果
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="文本操作">文本操作</h3>
<pre><code class="language-javascript">html()//取得第一个匹配元素的html内容，包含标签内容
html(val)//设置所有匹配元素的html内容，识别标签，能够表现出标签的效果

&lt;!-- more --&gt;

text()// 取得所有匹配元素的内容，只有文本内容，没有标签
text(val)//设置所有匹配元素的内容，不识别标签，将标签作为文本插入进去
示例:
$('.c1').text('&lt;h3&gt;你好,理查德&lt;/h3&gt;');
$('.c1').html('&lt;h3&gt;你好,理查德&lt;/h3&gt;');
</code></pre>
<h3 id="属性操作">属性操作</h3>
<pre><code class="language-javascript">attr(attrName)// 返回第一个匹配元素的属性值
attr(attrName, attrValue)// 为所有匹配元素设置一个属性值
attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值
removeAttr(attrName)// 从每一个匹配的元素中删除一个属性

示例:
	设置单个属性
		$('.c1').attr('xx','oo');
	设置多个属性
		$('.c1').attr({'age':'18','sex':'alex'});
	查看属性
		$('.c1').attr('属性名');
    	$('.c1').attr('xx');
    删除属性
    	$('.c1').removeAttr('xx');

prop -- 针对的是checked\selected\disabled..

查看标签是否有checked属性,也就是是否被选中
	    attr $(':checked').attr('checked'); //checked -- undefined
	    prop $(':checked').prop('checked'); //true  -- false
		
		通过设置属性的方式来设置是否选中:
			$(':radio').eq(2).prop('checked',true);  true和false不能加引号
			$(':radio').eq(2).prop('checked',false);

简单总结:
	1.对于标签上有的能看到的属性和自定义属性都用attr
	2.对于返回布尔值的比如checkbox、radio和option的是否被选中或者设置其被选中与取消选中都用prop。
	具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()
</code></pre>
<h3 id="文档处理">文档处理</h3>
<pre><code class="language-javascript">添加到指定元素内部的后面
	$(A).append(B)// 把B追加到A
	$(A).appendTo(B)// 把A追加到B
	#添加字符串照样能识别标签
	$('#d1').append('&lt;a href=&quot;http://www.jd.com&quot;&gt;京东&lt;/a&gt;');
添加到指定元素内部的前面
	$(A).prepend(B)// 把B前置到A
	$(A).prependTo(B)// 把A前置到B
	示例
		$('a').prependTo($('div'));

添加到指定元素外部的后面
	$(A).after(B)// 把B放到A的后面
	$(A).insertAfter(B)// 把A放到B的后面

添加到指定元素外部的前面
	$(A).before(B)// 把B放到A的前面
	$(A).insertBefore(B)// 把A放到B的前面
	
移除和清空元素
	remove()// 从DOM中删除所有匹配的元素。
	empty()// 删除匹配的元素集合中所有的子节点，包括文本被全部删除，但是匹配的元素还
	$('div').remove();
	$('div').empty();

替换
	replaceWith()
	replaceAll()
	示例:
		var a = document.createElement('a')
		a.href = 'http://www.baidu.com';
		a.innerText = 'xxx';
		
		$('span').replaceWith(a);
		$(a).replaceAll('span');
		
clone()克隆
	&lt;button class=&quot;btn&quot;&gt;屠龙宝刀,点击就送!&lt;/button&gt;	

    $('.btn').click(function () {
        // var a = $(this).clone(); //克隆标签
        var a = $(this).clone(true);  //连带事件一起克隆
        $(this).after(a);

    })
</code></pre>
<h3 id="常用事件">常用事件</h3>
<pre><code class="language-javascript">&lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;

click(function(){...})
	$('#d1').on('click',function () {
        $(this).css({'background-color':'green'})
    })
hover(function(){...})
	//鼠标悬浮 触发事件
    $('.c1').hover(
        //鼠标放上去
        function () {
            $(this).css({'background-color':'blue'});
        },
        function(){
            $(this).css({'background-color':'black'});
        }
    );


blur(function(){...})
	//失去光标(焦点)时触发事件 使div变色
    $('[type=&quot;text&quot;]').blur(function () {
        $('.c1').css({'background-color':'pink'})
    })
focus(function(){...})  //获取光标时触发事件 使div变色
	$('[type=&quot;text&quot;]').focus(function () {
        $('.c1').css({'background-color':'black'})
    })
                 
change(function(){...}) //内容发生变化，input，select等
	//与内容发改变时触发的事件
    $('select').change(function () {
        $('.c1').toggleClass('cc')
    })


keyup(function(){...})	//键盘抬起触发事件
    $(window).keyup(function (e) {
        console.log(e.keyCode);
    })


keydown(function(){...})	//键盘按键按下事件  参数e/event
	$(window).keydown(function (e) {
        console.log(e.keyCode) //每个键都有一个keycode键 ，通过不同的值触发不同的事件
        if(e.keyCode===37){
            $('.c1').css({'background-color':'green'})
        }else if(e.keyCode===39){
            $('.c1').css({'background-color':'balck'})
        }
        else{
            $('.c1').css({'background-color':'yellow'})
        }
    })


mouseenter(function(){...})	// 鼠标悬浮  等同于hover事件
mouseout(function(){...})
	$('.c1').mouseenter(function () {
        $(this).css({'background-color':'blue'});
    });
    $('.c1').mouseout(function () {
        $(this).css({'background-color':'yellow'});
    });


//鼠标悬浮 只触发一次
    $('.c2').mouseenter(function () {
        console.log('你变了');
    });
//鼠标悬浮  连续触发
    $('.c2').mouseover(function () {
        console.log('你变了');
    })
# mouseover 和 mouseenter的区别是：
# mouseover事件是如果该标签有子标签，
# 那么移动到该标签或者移动到子标签时会连续触发，
# mmouseenter事件不管有没有子标签都只触发一次，表示鼠标进入这个对象
</code></pre>
<h3 id="阻止后续冒泡事件发生">阻止后续（冒泡）事件发生</h3>
<pre><code class="language-javascript">//冒泡的意思就是因为html可以嵌套，如果你给儿子标签绑定了点事件或者没有绑定点击事件，
//父级标签绑定了点击事件，那么你一点击子标签，不管子标签有没有绑定事件，
//都会触发父级标签的点击事件，如果有，会先触发子标签的点击事件，
//然后触发父级标签的点击事件，不管子标签有没有点击事件，都会一级一级的还往上找点击事件

$('#d1').click(function () {
        alert('父级标签')
    })
    $('#d2').click(function (e) {	//这个参数e(只是个形参，写evt或者event名字的也很多)表示当前事件本身，这个事件也是一个对象
        alert('子级标签')
        // return false;	//这个也可以阻止
        e.stopPropagation();//用事件对象的这个方法就能阻止冒泡 （Propagation：传递的意思）
    })
</code></pre>
<h3 id="页面载入">页面载入</h3>
<blockquote>
<p>​	  将js代码写到head标签和写道body标签下面的作用是不同的，写在head标签里面的话，</p>
<p>如果你写了操作某个标签的内容的话，那个标签还没加载出来，先加载了你的js代码，就找不到这个标签，所以不会生效，所以写在body标签最下面是一种解决办法。</p>
<p>还有一种办法就是window.onload=function(){js的代码}，等页面上所有的元素都加载完，在执行这里面的js代码，还记得吗？但是这个window.onload有个缺点；</p>
<p>这个缺点就是这个操作时给window.onload赋值，如果你自己写了两个js文件，每个js文件中都有一个window.onload的话，那么后引入的文件会把前面引入的文件的window.onload里面的js代码全部覆盖掉，那么第一个文件的js代码就失去了效果；</p>
<p>还有一个问题就是，window.onload会等到页面上的文档、图片、视频等所有资源都加载完才执行里面的js代码，导致有些效果的加载比较慢；</p>
<p>所以我们使用下面的写法，不存在覆盖问题，而且只要文档加载完就触发，不需要等着一些图片啊视频啊什么的，加载js效果的速度快。</p>
</blockquote>
<pre><code class="language-javascript">1.jQuery文件要在使用jQuery的代码之前引入
2.js代码最好都放在body标签下面或者里面的最下面

3.window.onload:
	window.onload = function () {
            $('.c1').click(function () {
                $(this).css({'background-color': 'green'});
            })
        }

4.页面载入:
$(function () {
            $('.c1').click(function () {
                $(this).css({'background-color': 'green'});
            })
        })
$(document).ready(function{});


与window.onload的区别:
　　　1.window.onload()函数有覆盖现象，必须等待着图片资源加载完成之后才能调用
　　　2.jQuery的这个入口函数没有函数覆盖现象，文档加载完成之后就可以调用（建议使用此函数）
   
        // 等待整个页面中的内容全部加载完成之后,触发window.onload对应的函数里面的内容
        // window.onload 有覆盖现象,会被后面的window.onload给重新赋值
        // window.onload = function () {
        //     $('.c1').click(function () {
        //         $(this).css({'background-color':'green'});
        //     })
        // }

</code></pre>
<h3 id="each循环">each循环</h3>
<pre><code class="language-javascript">循环标签对象数组
$('li').each(function(k,v){
    console.log(k,v);
});

循环普通数组
var d1 = ['aa','bb','cc'];
$.each(d1,function(k,v){
    console.log(k,v);
})

跳出循环  return false; 类似于break
$('li').each(function(k,v){
    console.log(k,v.innerText);
    if (k === 1){
        return false;
    }

});

跳出本次循环  return; 类似于continue
$('li').each(function(k,v){
    
    if (k === 1){
        return;
    }
    console.log(k,v.innerText);
});

</code></pre>
<h3 id="点击事件和滚动事件的示例代码">点击事件和滚动事件的示例代码</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .c1{
            background-color: red;
            height: 100px;
            width: 100px;
        }
        .c2{
            background-color: green;
            height: 1000px;
            width: 100px;
        }
        .c3{
            background-color: blue;
            height: 1000px;
            width: 100px;
        }
        .s1{
            position: fixed;
            left:20px;
            bottom: 20px;
            height: 40px;
            width: 80px;
            background-color: purple;
            line-height: 40px;
            text-align: center;

        }
        .s1 a{
            color: white;
            font-size: 14px;
            text-decoration: none;
        }
        .hide{
            display: none;
        }
&lt;!-- more --&gt;



    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;a name=&quot;top&quot;&gt;这里是顶部&lt;/a&gt;--&gt;
&lt;!--&lt;a&gt;这里是顶部&lt;/a&gt;--&gt;
&lt;span&gt;顶部位置&lt;/span&gt;
&lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;

&lt;button class=&quot;change-postion&quot;&gt;走你&lt;/button&gt;

&lt;div class=&quot;c2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;c3&quot;&gt;&lt;/div&gt;

&lt;span class=&quot;s1 hide&quot;&gt;
    &lt;!--&lt;a href=&quot;#top&quot;&gt;返回顶部&lt;/a&gt;--&gt;
    &lt;span&gt;返回顶部&lt;/span&gt;

&lt;/span&gt;


&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
	//点击事件来改变标签位置
    $('.change-postion').click(function () {
        $('.c1').offset({top:200,left:200});
    });
    
	//滚动事件,监听滚动距离来显示或者隐藏标签
    $(window).scroll(function () {
        console.log($(window).scrollTop());
        if ($(window).scrollTop() &gt;=200){
            $('.s1').removeClass('hide');
        }else {
            $('.s1').addClass('hide');
        }
    });
    
	// 回到顶部,scrollTop设置值
    $('.s1').click(function () {
        $(window).scrollTop(0);
    })

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax&JQuery发送请求]]></title>
        <id>https://geckoc.github.io/post/ajaxandjquery-fa-song-qing-qiu/</id>
        <link href="https://geckoc.github.io/post/ajaxandjquery-fa-song-qing-qiu/">
        </link>
        <updated>2021-01-06T12:52:51.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="ajax原生发送请求">Ajax原生发送请求</h3>
<pre><code class="language-javascript">        window.onload = function () {
          var btn1 = document.getElementById(&quot;btn1&quot;);
          btn1.onclick = function () {
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="ajax原生发送请求">Ajax原生发送请求</h3>
<pre><code class="language-javascript">        window.onload = function () {
          var btn1 = document.getElementById(&quot;btn1&quot;);
          btn1.onclick = function () {
              
&lt;!-- more --&gt;

              // 1.创建用于AJAX方式的一个核心对象
            var xmlHttpRequest = new XMLHttpRequest;
              // alert(xmlHttpRequest);
              // 2.为xmlHttpRequest对象绑定一个固定事件
            /**
             * 事件触发，在一次请求过程中共有5次会被触发
             * 功能是为了接受服务器端传回的数据的。
             */
            xmlHttpRequest.onreadystatechange = function () {
              /**
               * readyState
               *      为0时，表示创建核心对象，初始化之前
               *      为1时，表示创建核心对象后，初始化时
               *      为2时，表示创建核心对象后，发出请求时
               *      为3时，表示服务器端开始响应浏览器
               *      为4时，表示服务器端响应结束
               * @type {number}
               */
              var rState = xmlHttpRequest.readyState;
              if(rState == 4){
                // alert(&quot;事件绑定成功--&gt;&quot;+rState);
                //使用核心对象接受服务器传回的唯一数据
                var responseText = xmlHttpRequest.responseText;
                // alert(responseText);
               document.getElementById(&quot;d1&quot;).innerText = responseText;

              }
            }
              //3.初始化请求  &quot;get&quot;请求方式，&quot;ajaxResponse?name=&quot;+name 请求名称携带参数，默认是异步ajax请求
              var name = document.getElementById(&quot;name&quot;).value;
              xmlHttpRequest.open(&quot;get&quot;,&quot;ajaxResponse?name=&quot;+name);
               //4发出请求
              xmlHttpRequest.send();
          }
        }
</code></pre>
<h3 id="jquery发送ajax请求">jQuery发送Ajax请求</h3>
<pre><code class="language-javascript">$(function () {
    $(&quot;#empno&quot;).blur(function () {
        //获取请求参数
        var empno = $(&quot;#empno&quot;).val();
        var ename = $(&quot;#ename&quot;).val();
        $.ajax({ //在ajax函数中传递一个json数据，json数据中包含所有的参数
            url:&quot;getEmpById&quot;, //请求名称
            data:{&quot;empno&quot;:empno,&quot;ename&quot;:ename},//请求参数
            datatype:&quot;json&quot;,//规定从服务器端传回的数据类型，&quot;json&quot;,&quot;text&quot;
            async:true,//异步请求true,同步请求false,默认异步
            type:&quot;post&quot;,//请求方式，post或get,默认是get
            success:function(data){//函数中需要添加一个参数，这个参数可以自动接收服务器传回的数据
                alert(data);
            }
        });
    })
})
</code></pre>
<h3 id="post-get">$.post()   $.get()</h3>
<h4 id="post-和-get-使用同理">post 和 get 使用同理</h4>
<p>格式：jQuery.post(url, [data], [callback], [type])</p>
<p><strong>url</strong>:发送请求地址。</p>
<p><strong>data</strong>:待发送 Key/value 参数。</p>
<p><strong>callback</strong>:发送成功时回调函数。</p>
<p><strong>type</strong>:返回内容格式，xml, html, script, json, text, _default。</p>
<pre><code class="language-javascript">$.post(&quot;/deleteInfo.do&quot;,{&quot;id&quot;:id}
       function(data){
    		alert(data);
	  },&quot;json&quot;);
</code></pre>
<p>&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。</p>
<p>&quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。</p>
<p>&quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了&quot;cache&quot;参数。'''注意：'''在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)</p>
<p>&quot;json&quot;: 返回 JSON 数据 。</p>
<p>&quot;jsonp&quot;: <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 格式。使用 <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。</p>
<p>&quot;text&quot;: 返回纯文本字符串</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Checkbox批量删除]]></title>
        <id>https://geckoc.github.io/post/checkbox-pi-liang-shan-chu/</id>
        <link href="https://geckoc.github.io/post/checkbox-pi-liang-shan-chu/">
        </link>
        <updated>2021-01-06T09:46:38.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="checkbox批量删除">Checkbox批量删除</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="checkbox批量删除">Checkbox批量删除</h3>
<!-- more -->
<h4 id="页面主要代码">页面主要代码</h4>
<h6 id="根据id从数据库中删除jquery16以上">根据ID从数据库中删除，jQuery1.6以上</h6>
<pre><code class="language-javascript"> &lt;script type=&quot;text/javascript&quot;&gt;
 jQuery(function ($) {
 	// 批量删除
            $(&quot;#delete&quot;).click(function () {
                // 定义一个js数组保存所有用户选择的编号
                var arr = [];
                $(&quot;input[type='checkbox']:checked&quot;).each(function (index, item) {
                    arr.push($(this).val());
                });
                // 为0则没有选中任何checkbox
                if (arr.length == 0){
                    alert(&quot;请先选择要删除的商品...&quot;);
                    return;
                }
                // 将数组转换称字符串
                var result = arr.join(&quot;,&quot;);
                if (!confirm('请问确定删除'+arr.length+'条记录吗?')) return;
                // 当确定删除执行ajax异步请求
                $.get(
                    &quot;/batchDelete.json&quot;,
                     {&quot;id&quot;:result},
                    function (data) {
                        if (data==true){
                            alert(&quot;删除成功&quot;);
                            location.reload(); 
                        }
                    },
                &quot;json&quot;);
            });
 }
 &lt;/script&gt;
&lt;div&gt;
	&lt;input id=&quot;delete&quot; type=&quot;button&quot; value=&quot;批量删除&quot;/&gt;
&lt;/div&gt;
&lt;c:forEach items=&quot;${requestScope.product}&quot; var=&quot;p&quot; varStatus=&quot;step&quot;&gt;
        &lt;tr&gt;
            &lt;td style=&quot;height: 22px&quot; align=&quot;center&quot;&gt;
                &lt;input type=&quot;checkbox&quot; value=&quot;${p.id}&quot; name=&quot;id&quot;&gt;
            &lt;/td&gt;
            &lt;td style=&quot;height: 22px&quot; align=&quot;center&quot;&gt;${step.count}&lt;/td&gt;
            &lt;td style=&quot;height: 22px&quot; align=&quot;left&quot;&gt;${p.name}&lt;/td&gt;
            &lt;td style=&quot;height: 22px&quot; align=&quot;center&quot;&gt;${p.price}&lt;/td&gt;
            &lt;td style=&quot;height: 22px&quot; align=&quot;center&quot;&gt;${p.typename}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/c:forEach&gt;
</code></pre>
<h4 id="servlet主要代码">servlet主要代码</h4>
<p>使用jackson2.11</p>
<pre><code class="language-java">        response.setContentType(&quot;application/json;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();
        String id = request.getParameter(&quot;id&quot;);
        System.out.println(id);
        System.out.println(&quot;---------------&quot;);
       
        ObjectMapper mapper = new ObjectMapper();
        ProductService service = new ProductServiceImpl();
        /* 
        	由于数据库id类型是int 实体类数据类型为Integer
        	将字符串以,分割,循环传参
        	 若id为String类型，则无需分割循环
        */
        String[] split = id.split(&quot;,&quot;);
        boolean success = false;
        for (String s : split) {
            success = service.batchDelete(Integer.valueOf(s));
        }
         // 将响应结果转换为JSON格式字符串返回
        String jsonValue = mapper.writeValueAsString(success);
        System.out.println(&quot;批量删除成功 BatchDelete.....&quot;);
        out.write(jsonValue);
</code></pre>
<h4 id="单元测试">单元测试</h4>
<pre><code class="language-java">@Test
    public void doGet() {
        String str = &quot;1,2,3&quot;;
        String[] split = str.split(&quot;,&quot;);
        for (String s : split) {
            System.out.println(s);
            Integer value = Integer.valueOf(s);
            System.out.println(&quot;trans&quot; + value);
        }
    }
</code></pre>
<h4 id="dao持久层主要代码">Dao持久层主要代码</h4>
<pre><code class="language-java">	
    public boolean batchDelete(Integer id) {
        String sql = &quot;delete from product where id in (?)&quot;;
      // 若形参为String 则可直接写入
      //  String sql = &quot;delete from product where id in (+&quot;id&quot;+)&quot;;
      
        try {
            int delete = runner.update(conn, sql, id);
       //      int delete = runner.update(conn, sql); ID为String时 
            // 删除成功则大于0，直接返回
            return delete &gt; 0;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery对Checkbox的各种操作]]></title>
        <id>https://geckoc.github.io/post/jquery-cao-zuo/</id>
        <link href="https://geckoc.github.io/post/jquery-cao-zuo/">
        </link>
        <updated>2021-01-06T09:18:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="jquery对checkbox的各种操作">jQuery对Checkbox的各种操作</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="jquery对checkbox的各种操作">jQuery对Checkbox的各种操作</h3>
<!-- more -->
<pre><code>    //注意： 操作checkbox的checked,disabled属性时jquery1.6以前版本用attr,1.6以上（包含）建议用prop
    //1、根据id获取checkbox
    $(&quot;#cbCheckbox1&quot;);
    
    //2、获取所有的checkbox
    $(&quot;input[type='checkbox']&quot;);//or
    $(&quot;input[name='cb']&quot;);
    
    //3、获取所有选中的checkbox
    $(&quot;input:checkbox:checked&quot;);//or
    $(&quot;input:[type='checkbox']:checked&quot;);//or
    $(&quot;input[type='checkbox']:checked&quot;);//or
    $(&quot;input:[name='ck']:checked&quot;);
    
    //4、获取checkbox值
    //用.val()即可，比如：
    $(&quot;#cbCheckbox1&quot;).val();
    //5、获取多个选中的checkbox值
    // 创建数组将值放入数组中 push()方法 
    var vals = [];
    $('input:checkbox:checked').each(function (index, item) {
        vals.push($(this).val());
    });
    
    //6、判断checkbox是否选中（jquery 1.6以前版本 用  $(this).attr(&quot;checked&quot;)）
    $(&quot;#cbCheckbox1&quot;).click(function () {
        if ($(this).prop(&quot;checked&quot;)) {
            alert(&quot;选中&quot;);
        } else {
            alert(&quot;没有选中&quot;);
        }
    });
    
    //7、设置checkbox为选中状态
    $('input:checkbox').attr(&quot;checked&quot;, 'checked');//or
    $('input:checkbox').attr(&quot;checked&quot;, true);
    
    //8、设置checkbox为不选中状态
    $('input:checkbox').attr(&quot;checked&quot;, '');//or
    $('input:checkbox').attr(&quot;checked&quot;, false);
    
    //9、设置checkbox为禁用状态(jquery&lt;1.6用attr,jquery&gt;=1.6建议用prop)
    $(&quot;input[type='checkbox']&quot;).attr(&quot;disabled&quot;, &quot;disabled&quot;);//or
    $(&quot;input[type='checkbox']&quot;).attr(&quot;disabled&quot;, true);//or
    $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, true);//or
    $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, &quot;disabled&quot;);
    
    //10、设置checkbox为启用状态(jquery&lt;1.6用attr,jquery&gt;=1.6建议用prop)
    $(&quot;input[type='checkbox']&quot;).removeAttr(&quot;disabled&quot;);//or
    $(&quot;input[type='checkbox']&quot;).attr(&quot;disabled&quot;, false);//or
    $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, &quot;&quot;);//or
    $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, false);

</code></pre>
<h4 id="示例如下">示例如下</h4>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h3&gt;jQuery操作checkbox
    &lt;/h3&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;cbCheckbox1&quot; value=&quot;1&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;2&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; disabled=&quot;disabled&quot; value=&quot;3&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;4&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; disabled=&quot;true&quot; value=&quot;5&quot; /&gt;
    &lt;br /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDisabled&quot; value=&quot;禁用&quot; onclick=&quot;fn_disabled();&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;Button1&quot; value=&quot;启用&quot; onclick=&quot;fn_enable();&quot; /&gt;&lt;br /&gt;
    &lt;input type=&quot;button&quot; id=&quot;Button2&quot; value=&quot;获取选中的值&quot; onclick=&quot;getCheckedValues();&quot; /&gt;&lt;br /&gt;
    &lt;input type=&quot;button&quot; id=&quot;Button3&quot; value=&quot;选中第二个&quot; onclick=&quot;checkedSecond();&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;Button4&quot; value=&quot;取消选中第二个&quot; onclick=&quot;uncheckedSecond();&quot; /&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script src=&quot;js/jquery-1.9.1.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

    function fn_disabled() {
        //$(&quot;input[type='checkbox']&quot;).attr(&quot;disabled&quot;, &quot;disabled&quot;);
        //$(&quot;input[type='checkbox']&quot;).attr(&quot;disabled&quot;, true);
        $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, true);
        //  $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, &quot;disabled&quot;);
    }

    function fn_enable() {
        //  $(&quot;input[type='checkbox']&quot;).removeAttr(&quot;disabled&quot;);
        // $(&quot;input[type='checkbox']&quot;).attr(&quot;disabled&quot;, false);
        // $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;,&quot;&quot;);
        $(&quot;input[type='checkbox']&quot;).prop(&quot;disabled&quot;, false);
    }

    //获取选中的 checkbox的值
    function getCheckedValues() {
        var arr = [];
        $(&quot;input[type='checkbox']:checked&quot;).each(function (index, item) {//
            arr.push($(this).val());
        });
        alert(arr);
    }

    function checkedSecond() {
        // $(&quot;input[type='checkbox']:eq(1)&quot;).prop(&quot;checked&quot;, &quot;checked&quot;);
        $(&quot;input[type='checkbox']:eq(1)&quot;).prop(&quot;checked&quot;, true);
    }

    function uncheckedSecond() {
        //  $(&quot;input[type='checkbox']:eq(1)&quot;).prop(&quot;checked&quot;, &quot;&quot;);
        $(&quot;input[type='checkbox']:eq(1)&quot;).prop(&quot;checked&quot;, false);
    }

    $(&quot;#cbCheckbox1&quot;).click(function () {
        if ($(this).prop(&quot;checked&quot;)) {//jquery 1.6以前版本 用  $(this).attr(&quot;checked&quot;)
            alert(&quot;选中&quot;);
        } else {
            alert(&quot;没有选中&quot;);
        }
    });

&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种页面刷新]]></title>
        <id>https://geckoc.github.io/post/ge-chong-ye-mian-shua-xin/</id>
        <link href="https://geckoc.github.io/post/ge-chong-ye-mian-shua-xin/">
        </link>
        <updated>2021-01-06T09:16:39.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>		top.location.reload();//刷新顶级页面
		parent.location.reload();//刷新父级页面
		window.parent.location.reload();//刷新父级页面
		window.location.reload();//刷新当前页面
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>		top.location.reload();//刷新顶级页面
		parent.location.reload();//刷新父级页面
		window.parent.location.reload();//刷新父级页面
		window.location.reload();//刷新当前页面
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串&数组练习]]></title>
        <id>https://geckoc.github.io/post/zi-fu-chuan-andshu-zu-lian-xi/</id>
        <link href="https://geckoc.github.io/post/zi-fu-chuan-andshu-zu-lian-xi/">
        </link>
        <updated>2020-11-21T04:25:49.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="stringarray">String&amp;Array</h2>
<ul>
<li>练习</li>
<li>关于String类的方法和Array的操作</li>
<li>字符串分割，数组排序，字符串赋值给自定义对象并添加到数组中</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="stringarray">String&amp;Array</h2>
<ul>
<li>练习</li>
<li>关于String类的方法和Array的操作</li>
<li>字符串分割，数组排序，字符串赋值给自定义对象并添加到数组中</li>
</ul>
<!-- more -->
<h5 id="题目">题目：</h5>
<ol>
<li>
<p>从键盘上输入身份证号, 判断出生日期,性别，<br>
身份证倒数第二位表示性别，双数为女性，单为男</p>
</li>
<li>
<p>有字符串: ”101,lisi,98;</p>
<p>202,wangwu,76;</p>
<p>303,chenqi,84;</p>
<p>404,zhangsan,49;</p>
<p>505,xiaoming,67”,</p>
<p>保存的学生的学号,姓名,成绩信息.</p>
<p>要求把字符串中学生信息取出来,创建Student对象,</p>
<p>把Student对象保存到数组中;遍历学生对象数组;</p>
<p>在数组中查找名字为xiaoxiao同学是否存在.对数组中学生对象根据成绩降序排序</p>
</li>
</ol>
<hr>
<pre><code>import java.util.Scanner;

/**
 * @ClassName Judge
 * @Deacription TODO 1. 从键盘上输入身份证号, 判断出生日期,性别
 *                   2. 身份证倒数第二位表示性别，双数为女性，单为男
 * @Version 1.0
 */
public class Judge {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        boolean verify = true;
        while (verify){
            System.out.print(&quot;请输入你的身份证号码:&quot;);
            String id = sc.next();
            // 用正则表达验证控制台输入
            boolean control = id.matches(&quot;\\d{17}(\\d|X|x)&quot;);
            if (control){
                // 截取身份证中出生日期
                String birth = id.substring(6, 14);
                // 取出倒数第二位的元素，偶数为女性
                char c = id.charAt(id.length() - 2);
                if (c % 2 == 0){
                    System.out.println(&quot;女性\t&quot; + &quot;出生日期：&quot; + birth);
                    // 判断成功结束
                    verify = false;
                }else {
                    System.out.println(&quot;男性\t&quot; + &quot;出生日期：&quot; + birth);
                    verify = false;
                }
            }else{
                //不合法继续循环
                System.out.println(&quot;身份证输入不合法...请重新输入！&quot;);
            }
        }
    }
}
</code></pre>
<h5 id="student类">Student类</h5>
<pre><code>public class Student implements Comparable&lt;Student&gt;{
    private String id;
    private String name;
    private String score;

    public Student(String id, String name, String score) {
        this.id = id;
        this.name = name;
        this.score = score;
    }
    public Student() {
    }

    public String getId() {
        return id;
    }

    public Student setId(String id) {
        this.id = id;
        return this;
    }

    public String getName() {
        return name;
    }

    public Student setName(String name) {
        this.name = name;
        return this;
    }

    public String getScore() {
        return score;
    }

    public Student setScore(String score) {
        this.score = score;
        return this;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id='&quot; + id + '\'' +
                &quot;, name='&quot; + name + '\'' +
                &quot;, score='&quot; + score + '\'' +
                '}';
    }

    @Override
    public int compareTo(Student o) {
        return o.getScore().compareTo(this.getScore());
    }
}
</code></pre>
<h5 id="测试类">测试类</h5>
<pre><code>/**
 * @ClassName StudentTest
 * @Deacription
 *  TODO
 *     有字符串: ”101,lisi,98;
 *              202,wangwu,76;
 *              303,chenqi,84;
 *              404,zhangsan,49;
 *              505,xiaoming,67”,
 *      保存的学生的学号,姓名,成绩信息.
 *      要求把字符串中学生信息取出来,创建Student对象,
 *      把Student对象保存到数组中;遍历学生对象数组;
 *      在数组中查找名字为xiaoxiao同学是否存在.对数组中学生对象根据成绩降序排序
 * @Version 1.0
 */
public class StudentTest {
    public static void main(String[] args) {
        String src = &quot;101,lisi,98;202,wangwu,76;303,chenqi,84;404,zhangsan,49;505,xiaoming,67&quot;;
        // 分号替换成逗号
        String replace = src.replace(&quot;;&quot;, &quot;,&quot;);
        // 通过逗号分隔字符串
        String[] split = replace.split(&quot;,&quot;);
        for (String s : split) {
            System.out.print(s + &quot; &quot;);
        }
        //创建学生数组
        Student[] stus = new Student[5];
        // 思路，内循环，分隔字符串后并按照每3个字符分别赋值给不同的对象
        /*
        for (int i = 0; i &lt; stus.length ; i++) {
            // 创建五个学生对象，内循环控制赋值
            Student student = new Student();
            for (int j = 0; j &lt; split.length ; j++) {
                String id = split[j];
                String name = split[j+1];
                String score = split[j+2];
                student = new Student(); //这是重新new对象.
                stus[i] = student;
            }
        }
        */
        // 此步骤暂时没有想到解决方法，只能手动通过数组下标赋值.....
        /*
        Student stu1 = new Student(split[0],split[1],split[2]);
        Student stu2 = new Student(split[3],split[4],split[5]);
        Student stu3 = new Student(split[6],split[7],split[8]);
        Student stu4 = new Student(split[9],split[10],split[11]);
        Student stu5 = new Student(split[12],split[13],split[14]);
        */
        // ！！！内循环会破坏创建对象结构，
        // 会有NullPointException或ArrayIndexOutOfBoundsException
        // split[i]元素下标为持续+1，定义初始值，循环自增
        int index = 0;
        for (int i = 0; i &lt; stus.length ; i++) {
                String id = split[index++];
                String name = split[index++];
                String score = split[index++];
                Student student = new Student(id,name,score);
                stus[i] = student;
        }
        System.out.println();
        // 遍历学生对象，未排序
        for (Student student : stus) {
            System.out.println(student);
        }
//        // 学生对象放入数组中
//        Student[] stus = {stu1,stu2,stu3,stu4,stu5};
//        对自定义类型进行排序需要实现Comparable并实现CompareTo方法重写规则
//        否则报错Exception in thread &quot;main&quot; java.lang.ClassCastException
        Arrays.sort(stus); // sort默认升序，已在Student类重新编写排序规则
        //判断学生是否存在
        if (isExist1(stus,&quot;xiaoxiao&quot;)){
            System.out.println(&quot;学生存在&quot;);
        }else{
            System.out.println(&quot;不存在&quot;);
        }
        // 按照成绩降序输出
        System.out.println(&quot;按照学生成绩降序输出&quot;);
        for (Student student : stus) {
            System.out.println(student);
        }
    }

    public static boolean isExist1(Student[] stus ,String target){
        for (int i = 0; i &lt; stus.length; i++) {
            if (target.equals(stus[i].getName())){
                return true;
            }
        }
        return false;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TreeSet]]></title>
        <id>https://geckoc.github.io/post/treeset/</id>
        <link href="https://geckoc.github.io/post/treeset/">
        </link>
        <updated>2020-11-21T03:13:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="treeset">TreeSet</h2>
<h3 id="概念">概念</h3>
<blockquote>
<ul>
<li>
<ol>
<li>treeSet 被称为可排序集合</li>
</ol>
</li>
<li>
<ol start="2">
<li>无序不可重复，可以自动排序，没有下标</li>
</ol>
</li>
</ul>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="treeset">TreeSet</h2>
<h3 id="概念">概念</h3>
<blockquote>
<ul>
<li>
<ol>
<li>treeSet 被称为可排序集合</li>
</ol>
</li>
<li>
<ol start="2">
<li>无序不可重复，可以自动排序，没有下标</li>
</ol>
</li>
</ul>
</blockquote>
<!-- more -->
<blockquote>
<ul>
<li>
<ol start="3">
<li>底层是TreeMap数据结构，TreeMap底层是二叉树</li>
</ol>
</li>
<li>
<ol start="4">
<li>放到TreeSet集合中的元素，等于放到TreeMap集合中的key部分</li>
</ol>
</li>
</ul>
</blockquote>
<pre><code>/**
 *      注意：TreeSet可以自动排序自定义类型吗？
 *       不可以，会出现类型转换异常 ClassCaseException
 *       实现自定义类排序，需实现Comparable接口并且编写排序规则
 */
public class TreeSetTest {
    public static void main(String[] args) {
        User user1 = new User(87);
        User user2 = new User(35);
        User user3 = new User(65);
        Set&lt;User&gt; set = new TreeSet&lt;&gt;();
//       User类未实现Comparable接口，并编写排序规则，出现ClassCaseException异常
        try {
            set.add(user1);
            set.add(user2);
            set.add(user3);
        } catch (ClassCastException e) {
            e.printStackTrace();
        }
        for (User user : set) {
            System.out.println(user);
        }
    }
}
// 为了方便，User类就不贴不出来了，封装一个int类型属性即可，较好比较
</code></pre>
<ul>
<li>自定义类型排序要实现<em>Comparable</em>接口,并且实现**compareTo()**方法</li>
</ul>
<pre><code>// 实现Comparable接口,并且实现compareTo()方法
public class SomeOne implements Comparable&lt;SomeOne&gt;{
    private String name;
    private int age;

    public SomeOne() {
    }

    public SomeOne(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public SomeOne setName(String name) {
        this.name = name;
        return this;
    }

    public int getAge() {
        return age;
    }

    public SomeOne setAge(int age) {
        this.age = age;
        return this;
    }

    @Override
    public String toString() {
        return &quot;SomeOne{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
    /*
     *     重写排序比较逻辑    k.compareTo(t.key)
     *     拿集合中的key值和另外的key比较，返回值可能是：&lt; 0, &gt;0, =0
     *  CompareTo返回值很重要
     *         返回0表示相同，value会覆盖
     *     返回&gt;0，会在右子树上继续找
     *         返回&lt;0，会在左子树上继续找
     * @see java.lang.Comparable#compareTo(java.lang.Object)
     */

    @Override
    public int compareTo(SomeOne o) {
        /*if (this.age == o.age) {
         return 0;
      }else if (this.age &gt; o.age) {
         return 1;
      }else if (this.age &lt; o.age) {
         return -1;
      } */
        int num = this.age - o.age;  // 此代码可表示上述意思
        /*
        如果年龄相同，则按姓名排序，
        String类型已实现CompareTo()方法，可直接调用
         */
        return num == 0 ? this.name.compareTo(o.name):num;
    }
}
</code></pre>
<h6 id="测试类">测试类</h6>
<pre><code>public class TreeSetTest {
    public static void main(String[] args) {
//      若年龄相同，则按姓名排序，字母大小
        SomeOne someOne1 = new SomeOne(&quot;A&quot;,99);
        SomeOne someOne2 = new SomeOne(&quot;F&quot;,88);
        SomeOne someOne3 = new SomeOne(&quot;D&quot;,88);
        SomeOne someOne4 = new SomeOne(&quot;C&quot;,88);
        SomeOne someOne5 = new SomeOne(&quot;Z&quot;,66);
        Set&lt;SomeOne&gt; tree = new TreeSet&lt;&gt;();
        tree.add(someOne1);
        tree.add(someOne2);
        tree.add(someOne3);
        tree.add(someOne4);
        tree.add(someOne5);
//        Iterator&lt;SomeOne&gt; iterator = someOnes.iterator();
        for (SomeOne someOne : tree) {
            System.out.println(someOne);
        }
    }
}
</code></pre>
<ul>
<li><strong>TreeSet</strong>集合中实现元素可排序的方法有两种</li>
<li>
<ol>
<li>实现<em>java.lang.Comparable</em>接口，并且实现**CompareTo()**方法</li>
</ol>
</li>
<li>
<ol start="2">
<li>通过构造方法传递比较器对象，自定义编写实现***java.util.Comparator***接口</li>
</ol>
</li>
<li><strong>Comparable</strong> 和 <strong>Comparator</strong> 如何选择？
<ul>
<li>
<pre><code> 比较规则多个，需要频繁切换，建议使用 **Comparator**
</code></pre>
</li>
<li>
<pre><code> 比较规则无需改变，建议使用 **Comparable**
</code></pre>
</li>
</ul>
</li>
<li><strong>Comparator</strong> 符合<strong>OCP</strong>原则  <em>(open close principle)</em></li>
</ul>
<h5 id="自定义编写实现comparator接口">自定义编写实现Comparator接口</h5>
<pre><code>public class ComparatorImpl implements Comparator&lt;Human&gt; {
    @Override
    public int compare(Human o1, Human o2) {
        int num =o1.getAge() - o2.getAge();
        // 年龄相同时，比较姓名
        return num == 0 ? o1.getName().compareTo(o2.getName()):num;
    }
}
</code></pre>
<p>自定义模板类</p>
<pre><code>public class Human {
    private String name;
    private int age;

    public Human() {
    }

    public Human(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Human setName(String name) {
        this.name = name;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Human setAge(int age) {
        this.age = age;
        return this;
    }

    @Override
    public String toString() {
        return &quot;Human{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<h6 id="测试类-2">测试类</h6>
<pre><code>public class TreeSetTest04 {
    public static void main(String[] args) {
//       通过构造方法传递比较器
//        Set&lt;Human&gt; humans = new TreeSet&lt;&gt;(new ComparatorImpl());
//       也可直接通过匿名内部类实现
        Set&lt;Human&gt; humans = new TreeSet&lt;&gt;(new Comparator&lt;Human&gt;() {
            @Override
            public int compare(Human o1, Human o2) {
                int num = o1.getAge() - o2.getAge();
                return num == 0 ? o1.getName().compareTo(o2.getName()):num;
            }
        });
        humans.add(new Human(&quot;Richard&quot;,24));
        humans.add(new Human(&quot;Jordan&quot;,80));
        humans.add(new Human(&quot;James&quot;,65));
        humans.add(new Human(&quot;Kobe&quot;,88));
        humans.add(new Human(&quot;Crazy&quot;,24));
        humans.add(new Human(&quot;Alex&quot;,24));
        humans.add(new Human(&quot;Richard&quot;,99));
        for (Human human : humans) {
            System.out.println(human);
        }
    }
}
</code></pre>
<h5 id="tips">Tips</h5>
<pre><code>        /*对于自定义类型，集合工具类无法直接调用排序
        Collections.sort(bodyList);  错误
        reason: no instance(s) of type variable(s) T
        exist so that Body conforms to Comparable&lt;? super T&gt;
        需实现Comparable接口
        */
       Set&lt;Integer&gt; hash = new HashSet&lt;&gt;();
        hash.add(5);
        hash.add(4);
        hash.add(3);
        hash.add(2);
        hash.add(1);
        System.out.println(&quot;\n****hashSet****&quot;);
        /*
        Collections.sort(hash);  错误
        reason: no instance(s) of type variable(s) T
        exist so that Set&lt;Integer&gt; conforms to List&lt;T
        Set集合如何排序，Collections.Sort只能传递List类型，可转换再排序
         */
        List&lt;Integer&gt; exList = new ArrayList&lt;Integer&gt;(hash);
        Collections.sort(exList);
        for (Integer integer : exList) {
            System.out.print(integer + &quot;**&gt;&quot;);
        }
		/*
		 java.util.Arrays的数组工具类排序也是无法直接排序自定义类型
		 对自定义类型进行排序需要实现Comparable并实现CompareTo方法重写规则
	      否则报错Exception in thread &quot;main&quot; java.lang.ClassCastException
		*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thread 线程]]></title>
        <id>https://geckoc.github.io/post/thread-xian-cheng/</id>
        <link href="https://geckoc.github.io/post/thread-xian-cheng/">
        </link>
        <updated>2020-11-11T08:40:40.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>创建线程的方式
<ul>
<li>第一种：编写类，直接继承 <em>java.lang.Thread</em>  重写<em>run()</em></li>
<li>第二种：实现<em>Runnable</em>接口重写<em>run()</em></li>
</ul>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>创建线程的方式
<ul>
<li>第一种：编写类，直接继承 <em>java.lang.Thread</em>  重写<em>run()</em></li>
<li>第二种：实现<em>Runnable</em>接口重写<em>run()</em></li>
</ul>
</li>
</ul>
<!-- more -->
<ul>
<li>第二种方法用的较多，实现接口后仍可继承其他类，比较灵活</li>
</ul>
<pre><code>public class ThreadTest01 {
   public static void main(String[] args) {
      MyThread myThread = new MyThread();
      /*
       *      run()不会启动线程，未分配新的分支栈，不能并发(单线程)
       *      start()方法：启动一个分支线程，在JVM中开辟一个新的栈空间
       *      开辟新空间后，start()方法就结束了，线程即启动成功
       *      线程会自动调用run()，且run()在分支栈的栈底（压栈）
       *     run和main是平级的，均在栈的底部
       */
//    myThread.run(); 
      myThread.start();
      
      System.out.println(&quot;Thread Running...&quot;);
      for (int i = 100; i &gt; 0; i--) {
         System.out.println(&quot;doing: &quot; + i);
      }
   }
}

class MyThread extends Thread{
   @Override
   public void run() {
      for (int i = 0; i &lt; 100; i++) {
         System.out.println(&quot;ThreadRunning...&quot;+i);
      }
   }
}
</code></pre>
<hr>
<pre><code>/*
 *     启动线程的第二种方法 
 */
public class ThreadTest02 {
   public static void main(String[] args) {
      //创建线程把可运行对象放入参数中
      Thread t = new Thread(new MyRunnable());
      t.start(); //开辟空间 自动调用run()
      for (int i = 0; i &lt; 666; i++) {
         System.out.println(&quot;Main Thread--&gt;&quot; + i);
      }
      
//    可直接实现Runnable接口，匿名内部类
      Thread t2 = new Thread(new Runnable() {
         public void run() {
            System.out.println(&quot;Anonymous---&gt;&quot;);
         }
      });
      t2.start();
   }
}

// 不是线程，是可运行的类
class MyRunnable implements Runnable{
   @Override
   public void run() {
      for (int i = 0; i &lt; 666; i++) {
         System.out.println(&quot;---Thread---&gt;&quot; + i);
      }
   }
}
</code></pre>
<ul>
<li>获取线程当前对象</li>
<li>Thread t = Thread.currentThread()</li>
<li>关于线程的sleep()方法</li>
<li>static void sleep(long millis)</li>
<li>静态方法，参数是毫秒</li>
<li>作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片（执行权），让其他线程使用</li>
<li>此段代码出现在A线程中，A线程会进入休眠</li>
<li>此段代码出现在B线程中，B线程会进入休眠</li>
<li>Thread.sleep() 间隔特定时间，去执行一段特定代码，每隔一段时间执行一次</li>
</ul>
<pre><code>public class ThreadTest01 {
   public static void main(String[] args) {
      MyThread thread = new MyThread();
      String name = Thread.currentThread().getName();
      System.out.println(name);
      thread.start();
   }
}

class MyThread extends Thread {
   @Override
   public void run() {
      for (int i = 0; i &lt; 10; i++) {
         String name = Thread.currentThread().getName();
         System.out.println(name +&quot;---&gt;&quot; + i);
         // 睡眠1秒
         try {
            sleep(1000);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }
}
</code></pre>
<ul>
<li>关于终止线程的睡眠，如何唤醒正在睡眠的线程？</li>
<li>t.interrupt(); ----&gt; 注：非结束线程的执行，是中断线程的睡眠</li>
<li>关于终止线程的执行</li>
<li>t.stop();  //强行终止线程，已过时不建议使用</li>
</ul>
<pre><code>public class ThreadTest02 {
	public static void main(String[] args) {
		Runnable flag = new OverThread();
		Thread t = new Thread(flag);
		t.setName(&quot;Branch Thread&quot;);
		t.start();
		try {
			Thread.sleep(1000*3);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
//		这种方式（依靠了java的异常处理机制）
		t.interrupt(); //中断T线程的睡眠
//		t.stop();  //强行终止线程，已过时不建议使用
	}
}

class OverThread implements Runnable {
	
	@Override
	public void run() {
	    System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + &quot;begin&quot;);
//		为什么只能捕捉异常而不能抛出，因子类不能抛出比父类更宽泛的异常
		try {
			Thread.sleep(1000 * 60 * 60 * 24 * 365); //睡眠一年
		} catch (InterruptedException e) {
				e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + &quot;end&quot;);
	}
}
</code></pre>
<hr>
<pre><code>/*
 *     合适终止线程的方式。添加Boolean标记
 */
public class ThreadTest03 {
   public static void main(String[] args) {
      stopThread flag = new stopThread();
      Thread t = new Thread(flag);
      t.setName(&quot;BranchThread&quot;);
      t.start();
      try {
         Thread.sleep(1000*3);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
//    什么时候想要终止线程，只要把标记改为false即可
//    以上代码，表示main线程休眠3秒，后flag.run执行，终止线程
      flag.run = false;
   }
}

class stopThread implements Runnable{
// 添加布尔标记
   boolean run = true;
   @Override
   public void run() {
      for (int i = 0; i &lt; 100; i++) {
         if (run) {
            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + i);
            try {
               Thread.sleep(1000);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }else {
//          线程结束前可以执行save，保存数据
            return;
         }
      }
   }
}
</code></pre>
<hr>
<pre><code>/*
 *     线程让位
 */
public class ThreadYield {
   public static void main(String[] args) {
      
      Thread t = new yieldThread();
      t.start();
      
      for (int i = 0; i &lt; 2000; i++) {
         System.out.println(Thread.currentThread().getName() + i);
      }
   }
}

class yieldThread extends Thread{
   @Override
   public void run() {
      for (int i = 0; i &lt; 2000; i++) {
//       每10个让位一次
         if (i % 10 == 0) {
            yield(); //当前线程暂停一下，让其其他线程
         }
         System.out.println(&quot;Branch--&quot;+i);
      }
   }
}
</code></pre>
<hr>
<ul>
<li>面试题</li>
</ul>
<pre><code>public class ThreadInterView {
   public static void main(String[] args) {
      Thread t = new MyThread1();
      t.setName(&quot;X&quot;);
      t.start();
      try {
//       问题：这段代码会让线程t进入休眠状态吗？
         t.sleep(1000*3);
         /*
          *     不会！在执行时仍会转换为Thread.sleep(1000*3);
          *     这段代码的作用是让当前线程进入休眠状态，即是main线程进入休眠
          *     这段代码出现在main方法中，main线程休眠
          */
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
      System.out.println(&quot;Down...&quot;);
   }
}

class MyThread1 extends Thread{
   @Override
   public void run() {
      for (int i = 0; i &lt; 20; i++) {
  		System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+ i);
      }
   }
}
</code></pre>
<h4 id="loading"><em><strong>loading...</strong></em></h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[34道MySQL经典]]></title>
        <id>https://geckoc.github.io/post/34-dao-mysql-jing-dian/</id>
        <link href="https://geckoc.github.io/post/34-dao-mysql-jing-dian/">
        </link>
        <updated>2020-09-10T06:58:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-取得每个部门最高薪水的人员名称">1. 取得每个部门最高薪水的人员名称。</h4>
<pre><code>// 第一步，找出每个部门的最高薪水
select e.deptno,max(e.sal) as maxsal from emp e
group by e.deptno;
+--------+---------+
| deptno | maxsal  |
+--------+---------+
|     10 | 5000.00 |
|     20 | 3000.00 |
|     30 | 2850.00 |
+--------+---------+
// 将以上查询结果当成一个临时表t(deptno,maxsal)
select t.*,e.ename from emp e
join (select e.deptno,max(e.sal) as maxsal from emp e group by e.deptno) t
on t.deptno = e.deptno and t.maxsal = e.sal
order by t.deptno;
+--------+---------+-------+
| deptno | maxsal  | ename |
+--------+---------+-------+
|     10 | 5000.00 | KING  |
|     20 | 3000.00 | SCOTT |
|     20 | 3000.00 | FORD  |
|     30 | 2850.00 | BLAKE |
+--------+---------+-------+

------------------------------------------------------------------------------

select e.deptno, e.ename, t.maxsal from 
(select e.deptno,max(e.sal) as maxsal from emp e group by e.deptno) t
join emp e on t.deptno = e.deptno
where t.maxsal = e.sal
order by e.deptno;
+--------+-------+---------+
| deptno | ename | maxsal  |
+--------+-------+---------+
|     10 | KING  | 5000.00 |
|     20 | SCOTT | 3000.00 |
|     20 | FORD  | 3000.00 |
|     30 | BLAKE | 2850.00 |
+--------+-------+---------+

// 显示部门名称,多表连接
select e.deptno, d.dname, e.ename, t.maxsal from 
(select e.deptno,max(e.sal) as maxsal from emp e group by e.deptno) t
join emp e on t.deptno = e.deptno
join dept d on d.deptno = e.deptno
where t.maxsal = e.sal
order by e.deptno;
</code></pre>
<h4 id="2-哪些人的薪水在部门平均薪水之上">2. 哪些人的薪水在部门平均薪水之上</h4>
<pre><code>// 第一步找出每个部门的平均薪水
select deptno, avg(sal) as avgsal from emp group by deptno;
    +--------+-------------+
    | deptno | avg(sal)    |
    +--------+-------------+
    |     10 | 2916.666667 |
    |     20 | 2175.000000 |
    |     30 | 1566.666667 |
    +--------+-------------+
// 将以上查询结果当成一个临时表t(deptno,avgsal)
// 条件是部门编号相同,薪资大于平均值 t.deptno = e.deptno and e.sal &gt; t.avgsal;
select e.ename,e.sal,t.* from emp e
join (select deptno, avg(sal) as avgsal from emp group by deptno) t
on t.deptno = e.deptno and e.sal &gt; t.avgsal;
    +-------+---------+--------+-------------+
    | ename | sal     | deptno | avgsal      |
    +-------+---------+--------+-------------+
    | ALLEN | 1600.00 |     30 | 1566.666667 |
    | JONES | 2975.00 |     20 | 2175.000000 |
    | BLAKE | 2850.00 |     30 | 1566.666667 |
    | SCOTT | 3000.00 |     20 | 2175.000000 |
    | KING  | 5000.00 |     10 | 2916.666667 |
    | FORD  | 3000.00 |     20 | 2175.000000 |
    +-------+---------+--------+-------------+
    6 rows in set (0.00 sec) 
    ---------------------------------------------
select e.ename,e.sal,t.deptno,t.avgsal from emp e
join (select deptno, avg(sal) as avgsal from emp group by deptno) t
on t.deptno = e.deptno and e.sal &gt; t.avgsal
order by e.sal;
</code></pre>
<h4 id="3-取得部门中所有人的平均薪水等级">3. 取得部门中（所有人的）平均薪水等级</h4>
<ul>
<li>平均的薪水等级：先计算每一个人薪水的等级，然后找出薪水等级的平均值。</li>
<li>平均薪水的等级：先计算平均薪水，然后找出每个平均薪水的等级值。</li>
</ul>
<pre><code>平均的薪水等级
// 第一步：找出每个人的薪水等级
// emp e 和 salgrade s表连接
// 连接条件: e.sal between s.losal and s.hisal

select e.ename,e.sal,e.deptno,s.grade from emp e 
join salgrade s on e.sal between s.losal and s.hisal;
    +--------+---------+--------+-------+
    | ename  | sal     | deptno | grade |
    +--------+---------+--------+-------+
    | SMITH  |  800.00 |     20 |     1 |
    | ALLEN  | 1600.00 |     30 |     3 |
    | WARD   | 1250.00 |     30 |     2 |
    | JONES  | 2975.00 |     20 |     4 |
    | MARTIN | 1250.00 |     30 |     2 |
    | BLAKE  | 2850.00 |     30 |     4 |
    | CLARK  | 2450.00 |     10 |     4 |
    | SCOTT  | 3000.00 |     20 |     4 |
    | KING   | 5000.00 |     10 |     5 |
    | TURNER | 1500.00 |     30 |     3 |
    | ADAMS  | 1100.00 |     20 |     1 |
    | JAMES  |  950.00 |     30 |     1 |
    | FORD   | 3000.00 |     20 |     4 |
    | MILLER | 1300.00 |     10 |     2 |
    +--------+---------+--------+-------+
    14 rows in set (0.00 sec)
-----------------------------------------------
// 第二步 基于以上结果继续按照 group by 分组，求 grade的平均值
select e.deptno,avg(s.grade) from emp e
join salgrade s 
on e.sal between s.losal and s.hisal
group by e.deptno;


平均薪水的等级
// 第一步，找出每个部门的平均薪水
select e.deptno , avg(e.sal) as avgsal from emp e group by deptno;
    +--------+-------------+
    | deptno | avgsal      |
    +--------+-------------+
    |     10 | 2916.666667 |
    |     20 | 2175.000000 |
    |     30 | 1566.666667 |
    +--------+-------------+
    3 rows in set (0.00 sec)
// 查询结果当成临时表 t ,查询每个部门平均薪水的等级
select t.*,s.grade 
from (select e.deptno , avg(e.sal) as avgsal from emp e group by deptno) t
join salgrade s
on t.avgsal between s.losal and s.hisal;
+--------+-------------+-------+
| deptno | avgsal      | grade |
+--------+-------------+-------+
|     30 | 1566.666667 |     3 |
|     10 | 2916.666667 |     4 |
|     20 | 2175.000000 |     4 |
+--------+-------------+-------+
3 rows in set (0.00 sec)
</code></pre>
<h4 id="4不准用组函数max取得最高薪水给出两种解决方案">4.不准用组函数（MAX），取得最高薪水（给出两种解决方案）</h4>
<pre><code>// 第一种  降序+limit
select ename,sal from emp order by sal desc limit 1;
    +-------+---------+
    | ename | sal     |
    +-------+---------+
    | KING  | 5000.00 |
    +-------+---------+
//第二种 表的自连接 ,emp 当成两张表 a,b
select 
distinct a.sal
from emp a
join emp b
on a.sal &lt; b.sal;
    +---------+
    | sal     |
    +---------+
    |  800.00 |
    | 1250.00 |
    | 1500.00 |
    | 1100.00 |
    |  950.00 |
    | 1300.00 |
    | 1600.00 |
    | 2850.00 |
    | 2450.00 |
    | 2975.00 |
    | 3000.00 |
    +---------+
11 rows in set (0.00 sec)

select ename,sal from emp
where sal not in
(select distinct a.sal from emp a join emp b on a.sal &lt; b.sal);
    +-------+---------+
    | ename | sal     |
    +-------+---------+
    | KING  | 5000.00 |
    +-------+---------+
    1 row in set (0.00 sec)
</code></pre>
<h4 id="5取得平均薪水最高的部门的部门编号">5.取得平均薪水最高的部门的部门编号</h4>
<pre><code>// 第一种方案，降序取一个 limit
select deptno,avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1;

// 第二种方案，max
找出最大值
select max(t.avgsal) from 
(select avg(sal) as avgsal from emp group by deptno) t;
//根据以上结果
select deptno,avg(sal) as avgsal from emp
group by deptno
having avgsal = 
(select max(t.avgsal) from 
(select avg(sal) as avgsal from emp group by deptno) t);


-------------------------------(自研)-----------------------------------

select t.deptno,max(t.avgsal) from 
(select e.deptno,avg(e.sal) as avgsal from emp e group by deptno) t;
+--------+---------------+
| deptno | max(t.avgsal) |
+--------+---------------+
|     10 |   2916.666667 |
+--------+---------------+
------------------------------------------------------------------------

----------(自研)-------------
select d.dname,d.deptno 
from (select avg(sal) avgsal, deptno de from emp group by deptno) t
join dept d
on t.de = d.deptno 
having max(avgsal);
-----------------------------
</code></pre>
<h4 id="6取得平均薪水最高的部门的部门名称">6.取得平均薪水最高的部门的部门名称</h4>
<pre><code>// 降序 + limit
select d.dname,avg(e.sal) avgsal from emp e
join dept d
on d.deptno = e.deptno
group by dname
order by avgsal desc
limit 1;
+------------+-------------+
| dname      | avgsal      |
+------------+-------------+
| ACCOUNTING | 2916.666667 |
+------------+-------------+

------------------------（ME）--------------------------
select d.dname from (select avg(sal) avgsal, deptno de from emp group by deptno)t
join dept d
on t.de = d.deptno having max(avgsal);
--------------------------------------------------------
</code></pre>
<h4 id="7求平均薪水的等级最低的部门的部门名称">7.求平均薪水的等级最低的部门的部门名称</h4>
<pre><code>// 第一步，按照部门名称分组，找出每个部门的平均薪水
select d.dname,avg(e.sal) from emp e join dept d on d.deptno = e.deptno
group by d.dname;
+------------+-------------+
| dname      | avg(e.sal)  |
+------------+-------------+
| ACCOUNTING | 2916.666667 |
| RESEARCH   | 2175.000000 |
| SALES      | 1566.666667 |
+------------+-------------+
// 临时表 t
select t.dname,s.grade from 
(select d.dname,avg(e.sal) avgsal from emp e join dept d on d.deptno = e.deptno
group by d.dname)t
join salgrade s
on t.avgsal between s.losal and s.hisal
where s.grade = 
(select grade from salgrade where 
(select avg(sal) avgsal from emp group by deptno order by avgsal asc limit 1)
between losal and hisal);
        +-------+-------+
        | dname | grade |
        +-------+-------+
        | SALES |     3 |
        +-------+-------+
        1 row in set (0.00 sec)
-----------------------------------------------
where s.grade = 3;
-----------------------------------------------
where子句后，以下为思路逻辑

// 找出最低的平均薪资
select avg(sal) avgsal from emp group by deptno order by avgsal asc limit 1;
        +-------------+
        | avgsal      |
        +-------------+
        | 1566.666667 |
        +-------------+
    1 row in set (0.00 sec)
 -------------------------------------------------
// 根据以上结果直接找出最低等级
select grade from salgrade where 
(select avg(sal) avgsal from emp group by deptno order by avgsal asc limit 1)
between losal and hisal;
    +-------+
    | grade |
    +-------+
    |     3 |
    +-------+
-----------------------------------------------------

</code></pre>
<h4 id="8取得比普通员工员工代码没有在mgr上出现的的最高薪水还要高的经理人姓名">8.取得比普通员工（员工代码没有在mgr上出现的）的最高薪水还要高的经理人姓名</h4>
<pre><code>select distinct mgr from emp where mgr is not null;
    +------+
    | mgr  |
    +------+
    | 7902 |
    | 7698 |
    | 7839 |
    | 7566 |
    | 7788 |
    | 7782 |
    +------+
------------------------------------------------
// 员工编号没有在以上范围内的都是普通员工
// 找出普通员工的最高薪水
注意!not in在使用的时候，后面小括号的条件中记得排除NULL
select max(sal) from emp 
where empno 
not in(select distinct mgr from emp where mgr is not null);
        +----------+
        | max(sal) |
        +----------+
        |  1600.00 |
        +----------+
------------------------------------------- 
// 第二步，找出高于1600的经理
select ename,sal from emp where sal &gt; 
(select max(sal) from emp where empno 
not in(select distinct mgr from emp where mgr is not null));
        +-------+---------+
        | ename | sal     |
        +-------+---------+
        | JONES | 2975.00 |
        | BLAKE | 2850.00 |
        | CLARK | 2450.00 |
        | SCOTT | 3000.00 |
        | KING  | 5000.00 |
        | FORD  | 3000.00 |
        +-------+---------+
6 rows in set (0.00 sec)

</code></pre>
<h4 id="9取得薪水最高的前五名员工">9.取得薪水最高的前五名员工</h4>
<pre><code>select ename , sal from emp order by sal desc limit 5;
    +-------+---------+
    | ename | sal     |
    +-------+---------+
    | KING  | 5000.00 |
    | SCOTT | 3000.00 |
    | FORD  | 3000.00 |
    | JONES | 2975.00 |
    | BLAKE | 2850.00 |
    +-------+---------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="10取得薪水最高的第六到第十名员工">10.取得薪水最高的第六到第十名员工</h4>
<pre><code>select ename,sal from emp order by sal desc limit 5,5;
    +--------+---------+
    | ename  | sal     |
    +--------+---------+
    | CLARK  | 2450.00 |
    | ALLEN  | 1600.00 |
    | TURNER | 1500.00 |
    | MILLER | 1300.00 |
    | MARTIN | 1250.00 |
    +--------+---------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="11取得最后入职的5名员工">11.取得最后入职的5名员工</h4>
<pre><code>// 日期也可以升序降序
select ename,hiredate from emp order by hiredate desc limit 5;
    +--------+------------+
    | ename  | hiredate   |
    +--------+------------+
    | ADAMS  | 1987-05-23 |
    | SCOTT  | 1987-04-19 |
    | MILLER | 1982-01-23 |
    | FORD   | 1981-12-03 |
    | JAMES  | 1981-12-03 |
    +--------+------------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="12取得每个薪水等级有多少员工">12.取得每个薪水等级有多少员工</h4>
<pre><code>// 找出每个员工的薪水等级
select e.ename,e.sal,s.grade from emp e
join salgrade s
on e.sal between s.losal and hisal;
+--------+---------+-------+
| ename  | sal     | grade |
+--------+---------+-------+
| SMITH  |  800.00 |     1 |
| ALLEN  | 1600.00 |     3 |
| WARD   | 1250.00 |     2 |
| JONES  | 2975.00 |     4 |
| MARTIN | 1250.00 |     2 |
| BLAKE  | 2850.00 |     4 |
| CLARK  | 2450.00 |     4 |
| SCOTT  | 3000.00 |     4 |
| KING   | 5000.00 |     5 |
| TURNER | 1500.00 |     3 |
| ADAMS  | 1100.00 |     1 |
| JAMES  |  950.00 |     1 |
| FORD   | 3000.00 |     4 |
| MILLER | 1300.00 |     2 |
+--------+---------+-------+
14 rows in set (0.00 sec)
----------------------------------------------
// 第二步，继续按照 group by 分组统计数量
select s.grade,count(*) from emp e
join salgrade s
on e.sal between s.losal and hisal
group by s.grade;
+-------+----------+
| grade | count(*) |
+-------+----------+
|     1 |        3 |
|     2 |        3 |
|     3 |        2 |
|     4 |        5 |
|     5 |        1 |
+-------+----------+
5 rows in set (0.02 sec)
</code></pre>
<h4 id="13-面试题">13. 面试题</h4>
<h4 id="14列出所有员工及领导的名字">14.列出所有员工及领导的名字</h4>
<pre><code class="language-mysql">// 表连接，左外连接
select e.ename '员工' , d.ename '领导' from emp e
left outer join emp d
on e.mgr = d.empno;
</code></pre>
<h4 id="15列出受雇日期早于其直接上级的所有员工编号-姓名-部门名称">15.列出受雇日期早于其直接上级的所有员工编号、姓名、部门名称</h4>
<pre><code>select e.empno,e.ename '员工',d.dname from emp e
join emp b
on e.mgr = b.empno and e.hiredate &lt; b.hiredate
join dept d
on e.deptno = d.deptno;
+-------+-------+------------+
| empno | 员工  | dname      |
+-------+-------+------------+
|  7782 | CLARK | ACCOUNTING |
|  7369 | SMITH | RESEARCH   |
|  7566 | JONES | RESEARCH   |
|  7499 | ALLEN | SALES      |
|  7521 | WARD  | SALES      |
|  7698 | BLAKE | SALES      |
+-------+-------+------------+
6 rows in set (0.00 sec)
--------------------(优化)----------------------------
select e.empno,e.ename '员工', e.hiredate,b.ename '领导',b.hiredate,d.dname from emp e
join emp b
on e.mgr = b.empno and e.hiredate &lt; b.hiredate
join dept d
on e.deptno = d.deptno;
+-------+-------+------------+-------+------------+------------+
| empno | 员工  | hiredate   | 领导  | hiredate   | dname      |
+-------+-------+------------+-------+------------+------------+
|  7782 | CLARK | 1981-06-09 | KING  | 1981-11-17 | ACCOUNTING |
|  7369 | SMITH | 1980-12-17 | FORD  | 1981-12-03 | RESEARCH   |
|  7566 | JONES | 1981-04-02 | KING  | 1981-11-17 | RESEARCH   |
|  7499 | ALLEN | 1981-02-20 | BLAKE | 1981-05-01 | SALES      |
|  7521 | WARD  | 1981-02-22 | BLAKE | 1981-05-01 | SALES      |
|  7698 | BLAKE | 1981-05-01 | KING  | 1981-11-17 | SALES      |
+-------+-------+------------+-------+------------+------------+
</code></pre>
<h4 id="16列出部门名称和这些部门的员工信息同时列出那些没有员工的部门">16.列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门</h4>
<pre><code>// 右外连接
select d.*,e.* from emp e 
right join dept d
on e.deptno = d.deptno;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://geckoc.github.io//post-images/1599721472090.png" alt="" loading="lazy"></figure>
<h4 id="17列出至少有5个员工的所有部门">17.列出至少有5个员工的所有部门</h4>
<pre><code>// 第一步：先求出每个部门的员工数量
select deptno,count(*) from emp group by deptno;
+--------+----------+
| deptno | count(*) |
+--------+----------+
|     10 |        3 |
|     20 |        5 |
|     30 |        6 |
+--------+----------+
3 rows in set (0.00 sec)
// 第二步
select deptno,count(ename) 'TotalEmp' from emp group by deptno having count('TotalEmp') &gt;= 5;
+--------+----------+
| deptno | TotalEmp |
+--------+----------+
|     20 |        5 |
|     30 |        6 |
+--------+----------+
2 rows in set (0.00 sec)
</code></pre>
<h4 id="18列出薪水比smith多的所有员工信息">18.列出薪水比“SMITH”多的所有员工信息</h4>
<pre><code>select sal from emp where ename = 'smith';
+--------+
| sal    |
+--------+
| 800.00 |
+--------+

select ename,sal from emp where sal &gt; (select sal from emp where ename = 'smith');
+--------+---------+
| ename  | sal     |
+--------+---------+
| ALLEN  | 1600.00 |
| WARD   | 1250.00 |
| JONES  | 2975.00 |
| MARTIN | 1250.00 |
| BLAKE  | 2850.00 |
| CLARK  | 2450.00 |
| SCOTT  | 3000.00 |
| KING   | 5000.00 |
| TURNER | 1500.00 |
| ADAMS  | 1100.00 |
| JAMES  |  950.00 |
| FORD   | 3000.00 |
| MILLER | 1300.00 |
+--------+---------+
13 rows in set (0.00 sec)
</code></pre>
<h4 id="19列出所有clerk办事员的姓名及其部门名称部门人数">19.列出所有“CLERK”（办事员）的姓名及其部门名称，部门人数</h4>
<pre><code>select e.job,e.ename,d.dname,d.deptno from emp e 
join dept d
on e.deptno = d.deptno and e.job = 'clerk';
+-------+--------+------------+--------+
| job   | ename  | dname      | deptno |
+-------+--------+------------+--------+
| CLERK | MILLER | ACCOUNTING |     10 |
| CLERK | SMITH  | RESEARCH   |     20 |
| CLERK | ADAMS  | RESEARCH   |     20 |
| CLERK | JAMES  | SALES      |     30 |
+-------+--------+------------+--------+

select deptno,count(*) as deptcount from emp group by deptno;
+--------+-----------+
| deptno | deptcount |
+--------+-----------+
|     10 |         3 |
|     20 |         5 |
|     30 |         6 |
+--------+-----------+

// 将以上结果当做两张表 t1 ,t2
select t1.* ,t2.deptcount 
from (select e.job,e.ename,d.dname,d.deptno from emp e 
join dept d
on e.deptno = d.deptno and e.job = 'clerk')t1
join (select deptno,count(*) as deptcount from emp group by deptno)t2
on t1.deptno = t2.deptno;

+-------+--------+------------+--------+-----------+
| job   | ename  | dname      | deptno | deptcount |
+-------+--------+------------+--------+-----------+
| CLERK | MILLER | ACCOUNTING |     10 |         3 |
| CLERK | SMITH  | RESEARCH   |     20 |         5 |
| CLERK | ADAMS  | RESEARCH   |     20 |         5 |
| CLERK | JAMES  | SALES      |     30 |         6 |
+-------+--------+------------+--------+-----------+
4 rows in set (0.00 sec)

</code></pre>
<h4 id="20列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数">20.列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数</h4>
<pre><code>select job,count(*) from emp group by job having min(sal) &gt; 1500;
+-----------+----------+
| job       | count(*) |
+-----------+----------+
| ANALYST   |        2 |
| MANAGER   |        3 |
| PRESIDENT |        1 |
+-----------+----------+
3 rows in set (0.00 sec)
</code></pre>
<h4 id="21列出在部门sales销售部工作的员工的姓名假定不知道销售部门的部门编号">21.列出在部门“SALES”&lt;销售部&gt;工作的员工的姓名，假定不知道销售部门的部门编号</h4>
<pre><code>select deptno from dept where dname = 'sales';
select ename,deptno from emp where deptno = (select deptno from dept where dname = 'sales');
+--------+--------+
| ename  | deptno |
+--------+--------+
| ALLEN  |     30 |
| WARD   |     30 |
| MARTIN |     30 |
| BLAKE  |     30 |
| TURNER |     30 |
| JAMES  |     30 |
+--------+--------+
6 rows in set (0.00 sec)

</code></pre>
<h4 id="22列出薪金高于公司平均薪金的所有员工所在部门-上级领导-雇员的工资等级">22.列出薪金高于公司平均薪金的所有员工，所在部门、上级领导、雇员的工资等级</h4>
<pre><code>select avg(sal) from emp;  // 公司平均薪水

select e.ename '员工',d.dname , l.ename '领导',s.grade
from emp e
join dept d
on d.deptno = e.deptno
left join emp l
on e.mgr = l.empno
join salgrade s
on e.sal between s.losal and s.hisal
where e.sal &gt; (select avg(sal) from emp);

</code></pre>
<h4 id="23列出与scott从事相同工作的所有员工及部门名称">23.列出与“SCOTT”从事相同工作的所有员工及部门名称</h4>
<pre><code>select job from emp where ename = 'scott';

select e.job,e.ename,d.dname
from emp e 
join dept d 
on e.deptno = d.deptno
where job = (select job from emp where ename = 'scott')
and e.ename &lt;&gt; 'scott';
+---------+-------+----------+
| job     | ename | dname    |
+---------+-------+----------+
| ANALYST | FORD  | RESEARCH |
+---------+-------+----------+
</code></pre>
<h4 id="24列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金">24.列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金</h4>
<pre><code>select distinct sal from emp where deptno = 30;			
+---------+
| sal     |
+---------+
| 1600.00 |
| 1250.00 |
| 2850.00 |
| 1500.00 |
|  950.00 |
+---------+

select ename,sal from emp
where sal in(select distinct sal from emp where deptno = 30)
and deptno &lt;&gt; 30;

Empty set (0.00 sec)   //无记录
</code></pre>
<h4 id="25列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金-部门名称">25.列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金、部门名称</h4>
<pre><code>select max(sal) from emp where deptno = 30;
+----------+
| max(sal) |
+----------+
|  2850.00 |
+----------+
select e.ename,e.sal,d.dname
from emp e
join dept d
on d.deptno = e.deptno
where sal &gt; (select max(sal) from emp where deptno = 30);

+-------+---------+------------+
| ename | sal     | dname      |
+-------+---------+------------+
| KING  | 5000.00 | ACCOUNTING |
| JONES | 2975.00 | RESEARCH   |
| SCOTT | 3000.00 | RESEARCH   |
| FORD  | 3000.00 | RESEARCH   |
+-------+---------+------------+
4 rows in set (0.00 sec)
</code></pre>
<h4 id="26列出在每个部门工作的员工数量-平均工资和平均服务期限">26.列出在每个部门工作的员工数量、平均工资和平均服务期限</h4>
<pre><code class="language-mysql">
</code></pre>
<h4 id="27列出所有员工的姓名-部门名称和工资">27.列出所有员工的姓名、部门名称和工资</h4>
<pre><code>select e.ename,d.dname,e.sal
from emp e
join dept d
on e.deptno = d.deptno;

+--------+------------+---------+
| ename  | dname      | sal     |
+--------+------------+---------+
| CLARK  | ACCOUNTING | 2450.00 |
| KING   | ACCOUNTING | 5000.00 |
| MILLER | ACCOUNTING | 1300.00 |
| SMITH  | RESEARCH   |  800.00 |
| JONES  | RESEARCH   | 2975.00 |
| SCOTT  | RESEARCH   | 3000.00 |
| ADAMS  | RESEARCH   | 1100.00 |
| FORD   | RESEARCH   | 3000.00 |
| ALLEN  | SALES      | 1600.00 |
| WARD   | SALES      | 1250.00 |
| MARTIN | SALES      | 1250.00 |
| BLAKE  | SALES      | 2850.00 |
| TURNER | SALES      | 1500.00 |
| JAMES  | SALES      |  950.00 |
+--------+------------+---------+
14 rows in set (0.00 sec)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL三部曲之驾轻就熟]]></title>
        <id>https://geckoc.github.io/post/mysql-san-bu-qu-zqjs/</id>
        <link href="https://geckoc.github.io/post/mysql-san-bu-qu-zqjs/">
        </link>
        <updated>2020-08-21T06:53:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="约束-constraint"><em>约束 Constraint</em></h3>
<blockquote>
<p>在创建表时，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性、有效性、完整性，以下为常见的约束：</p>
</blockquote>
<ol>
<li>非空约束(not null) ：约束的字段不能为null。</li>
<li>唯一约束(unique) ：约束的字段不能重复。</li>
<li>主键约束(primary key) ：约束的字段不能为null，也不能重复。（简称PK）</li>
<li>外检约束(foreign key) ：...（简称FK）</li>
<li>检查约束(check) ：注意Oracle数据库有check约束，MySQL目前不支持该约束，MySQL中没有。</li>
</ol>
<h4 id="not-null-非空约束">not null 非空约束</h4>
<pre><code>drop table if exists t_user;
create table t_user(
	id int,
	username varchar(255) NOT NULL,
	password varchar(255)
);
insert into t_user(id,password) values(1,'psw');
ERROR 1364 ..........  报错

insert into t_user(id,usename,password) values(1,'ric','psw');
</code></pre>
<h4 id="unique-唯一性约束">unique 唯一性约束</h4>
<ul>
<li>唯一性约束修饰的字段具有唯一性，不能重复，但可以为null。
<ul>
<li>案例：给某一列添加unique</li>
</ul>
</li>
</ul>
<pre><code>drop table if exists t_user;

mysql&gt; create table t_user(
    -&gt; id int,
    -&gt; username varchar(255) unique);   //列级约束
Query OK, 0 rows affected (0.14 sec)

insert into t_user(id,username) values(1,'rich');
Query OK, 1 row affected (0.14 sec)

insert into t_user(id,username) values(2,'rich');
ERROR 1062 (23000): Duplicate entry 'rich' for key 'username'

//字段具有唯一性，不能重复，可以为null
insert into t_user(id) value(2);
insert into t_user(id) value(3);
mysql&gt; select * from t_user;
    +------+----------+
    | id   | username |
    +------+----------+
    |    1 | rich     |
    |    2 | NULL     |
    |    3 | NULL     |
    +------+----------+
3 rows in set (0.00 sec)
</code></pre>
<ul>
<li>案例：给两个列或者多个列添加unique</li>
<li><em>not null</em> 约束只有列级约束，没有表级约束</li>
</ul>
<pre><code>create table t_user(
id int,
usercode varchar(255),
username varchar(255),
    unique(usercode,username) //多个字段联合起来添加一个约束unique (表级约束)
);

// 联合约束
mysql&gt; insert into t_user values (1,'111','rich');
mysql&gt; insert into t_user values (1,'222','rich');
mysql&gt; insert into t_user values (1,'333','rich');

//两个字段都重复，报错
mysql&gt; insert into t_user values (1,'111','rich');
ERROR 1062 (23000): Duplicate entry '111-rich' for key 'usercode'


</code></pre>
<h4 id="primary-key-主键约束">primary key 主键约束</h4>
<ul>
<li>约束的字段不能为null，也不能重复。（简称PK）</li>
<li>主键相关术语： 主键约束、主键字段、主键值</li>
<li>主键有什么作用？
<ul>
<li>表的设计三范式：第一范式就是要求任何一张表都应该有主键</li>
<li>作用：主键值是这行记录在这张表中的唯一标识。(像人的身份证一样)</li>
</ul>
</li>
</ul>
<pre><code>drop table if exists t_user;
create table t_user(
	id int primary key,   // 列级约束
    username varchar(255),
    email varchar(255)
);

insert into t_user(id,username,email) values(1,'rich','text@gmail.com');
insert into t_user(id,username,email) values(2,'monica','demo@gmail.com');
insert into t_user(id,username,email) values(3,'denish','google@gmail.com');

//主键不可重复
insert into t_user(id,username,email)values(1,'jack','jack@gmail.com');
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
//主键不可为Null
insert into t_user(username,email) values ('jack','jack@gmail.com');
ERROR 1364 (HY000): Field 'id' doesn't have a default value
</code></pre>
<h5 id="主键的分类">主键的分类</h5>
<p><em><strong>一张表的主键约束只能有一个（记住）</strong></em></p>
<ul>
<li>
<p>根据主键字段的字段数量划分</p>
<ul>
<li>单一主键(推荐，常用的)</li>
<li>复合主键(多字段联合起来添加一个主键约束)---&gt;[复合主键不建议使用，因违背三范式]</li>
</ul>
</li>
<li>
<p>根据主键性质划分</p>
<ul>
<li>
<p>自然主键：主键值最好就是和一个业务没有任何关系的自然数。(推荐)</p>
</li>
<li>
<p>业务主键：主键值和系统业务挂钩</p>
<blockquote>
<p>例如拿着银行卡的卡号做主键，拿身份证做主键（不推荐用）</p>
<p>最好不要使用和业务挂钩的字段作为主键，因为以后的业务一旦发生改变的时候，主键值也需要随着发生改变，但有的时候没有办法改变，因为改变可能会导致主键值重复。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>使用表级约束方式定义主键</p>
</li>
</ul>
<pre><code>drop table if exists t_user;
create table t_user(
     id int,
     username varchar(255),
     primary key(id)
 	);
 	
//演示复合主键，无需掌握
create table t_user(
	id int ,
    username varchar(255),
    password varchar(255),
    primary key(id,username)
);
</code></pre>
<ul>
<li>MySQL提供主键值自增（重点）</li>
</ul>
<pre><code>drop table if exists t_user;

//auto_increment  主键值自增
create table t_user(
	id int primary key auto_increment, //id字段自动维护一个自增的数字，从1开始，以1递增
    username varchar(255)
); 
insert into t_user(username) value('ric');
insert into t_user(username) value('1ic');
insert into t_user(username) value('2ic');
insert into t_user(username) value('3ic');
select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | ric      |
|  2 | 1ic      |
|  3 | 2ic      |
|  4 | 3ic      |
+----+----------+
4 rows in set (0.00 sec)
</code></pre>
<ul>
<li>Oracle当中也提供了一种自增机制，叫做序列（sequence）对象。</li>
</ul>
<h4 id="foreign-key外键约束">foreign key外键约束</h4>
<ul>
<li>外键约束的相关术语：外键约束、外键字段、外键值
<ul>
<li>业务背景：请设计数据库表，用来维护学生和班级信息？</li>
</ul>
</li>
</ul>
<pre><code>第一种方案：一张表
no(pk)		name			classno			classname
----------------------------------------------------------------------------------------
1			zs1				1101			高三1班
2			zs2				1101			高三1班
3			zs3				1102			高三2班
4			zs4				1102			高三2班
5			zs5				1102			高三2班
----------------------------------------------------------------------------------------
缺点：数据冗余！

第二种方案：两张表（班级表和学生表）
t_class:
cno(pk)		classname
----------------------------------------
1101		高三1班
1102		高三2班
----------------------------------------
t_student
sno(pk)		sname		classno(fk)该字段添加外键约束
----------------------------------------
1			zs1				1101
2			zs2				1101
3			zs3				1102
4			zs4				1102
5			zs5				1102
------------------------------------------
classno如果不添加fk外键约束，则可以任意自定义添加，所以需添加 foreign key约束

t_student中的classno引用t_class表中的cno字段，此时t_student叫做子表，t_class叫做父表。

顺序要求：
    删除数据的时候，先删除子表，在删除父表。
    添加数据的时候，先添加父表，再添加子表。
    删除表的时候，先删除子表，再删除父表。
    创建表的时候，先创建父表，再创建子表。

drop table if exists t_student;
drop table if exists t_class;

create table t_class(
	cno int primary key,
    classname varchar(255)
);
create table t_student(
	sno int primary key auto_increment,
    sname varchar(255),
    classno int,
    foreign key(classno) references t_class(cno)
);

insert into t_class(cno,classname) values(1101,'xxxx');
insert into t_class(cno,classname) values(1102,'yyyy');

insert into t_student(sname,classno) values ('zs1',1101);
insert into t_student(sname,classno) values ('zs2',1101);
insert into t_student(sname,classno) values ('zs3',1102);
insert into t_student(sname,classno) values ('zs4',1102);
insert into t_student(sname,classno) values ('zs5',1102);

select * from t_class;
select * from t_student;
+------+-----------+
| cno  | classname |
+------+-----------+
| 1101 | xxxx      |
| 1102 | yyyy      |
+------+-----------+
2 rows in set (0.00 sec)

+-----+-------+---------+
| sno | sname | classno |
+-----+-------+---------+
|   1 | zs1   |    1101 |
|   2 | zs2   |    1101 |
|   3 | zs3   |    1102 |
|   4 | zs4   |    1102 |
|   5 | zs5   |    1102 |
+-----+-------+---------+
5 rows in set (0.00 sec)

//外键约束，插入的数据在引用数据中没有，报错1452
insert into t_student(sname,classno) values('lisi',103);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bjpowernode`.`t_student`, CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))
</code></pre>
<ul>
<li>外键值可以为NULL</li>
<li>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？
<ul>
<li>注意：被引用的字段不一定是主键，但至少具有<em>unique</em>约束。</li>
</ul>
</li>
</ul>
<h3 id="存储引擎了解内容"><em>存储引擎(了解内容)</em></h3>
<h3 id="事务-transaction"><em>事务 Transaction</em></h3>
<ul>
<li>
<p>一个事务是一个完整的业务逻辑单元。不可再分。</p>
</li>
<li>
<p>比如银行账户转账：A账户向B账户转账10000，需执行两条Update语句。</p>
<pre><code>update t_act set balance = balance - 10000 where actno = 'act-A';
update t_act set balance = balance + 10000 where actno = 'act-B';
</code></pre>
<ul>
<li>以上两条DML语句必须同时成功或同时失败，不允许出现一条成功，一条失败。</li>
</ul>
<p>要想保证以上的DML语句同时成功或失败，则需要使用数据库的“事务机制”。</p>
<hr>
</li>
<li>
<p>和事务相关的语句只有DML语句 (insert、delete、update)</p>
<ul>
<li>因为他们三个语句都是和数据库表当中的“数据”相关的。</li>
<li>事务的存在是为了保证数据的完整性，安全性。</li>
</ul>
</li>
<li>
<p>假设事务只需要一条DML语句可以解决，则不需要事务机制。</p>
<ul>
<li>但实际情况不是如此，通常一个“事务（业务）”需要多条DML语句共同联合完成。</li>
</ul>
</li>
</ul>
<h4 id="事务的特性-acid">事务的特性  <em>ACID</em></h4>
<ul>
<li>事务的四大特性： <strong>Atomicity、Consistency、Isolation、Durability</strong></li>
</ul>
<p>A：原子性：事务是最小的工作单元，不可再分；要么全部完成，要么均不执行。</p>
<p>C：一致性：事务必须保证多条DML语句同时成功或同时失败。</p>
<p>I ：隔离性：事务A和事务B之间具有隔离，事务的执行不受其他事务的干扰。</p>
<p>D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p>
<h4 id="isolation-隔离性"><strong>Isolation</strong> 隔离性</h4>
<ul>
<li>事务隔离性存在隔离级别，理论上隔离级别包括4个
<ul>
<li>第一级别：读未提交（<strong>read uncommitted</strong>）
<ul>
<li>对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。</li>
<li>读未提交有存在脏读（<strong>dirty read</strong>）现象：表示读到了脏数据。</li>
</ul>
</li>
<li>第二级别：读已提交（<strong>read committed</strong>）
<ul>
<li>对方事务提交之后的数据我方可以读取到</li>
<li>读已提交存在的问题：不可重复读。(每次读取数据都不一样)</li>
</ul>
</li>
<li>第三级别：可重复读（<strong>repeatable read</strong>）
<ul>
<li>对方事务提交之后的数据我方读不到。</li>
<li>这种隔离级别解决了：不可重复读问题。只要当前事务没结束，读到的数据永远都是一样的。</li>
<li>此种隔离级别存在的问题是：读取到的数据是幻像，不是真实的。（幻读）</li>
</ul>
</li>
<li>第四级别：序列化读/串行化读（<strong>Serializable</strong>）
<ul>
<li>解决了所有问题</li>
<li>事务A和事务B不能并发，效率低，需要事务排队。</li>
<li>隔离级别最高，效率最低，数据最安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Oracle数据库默认的隔离级别是：读已提交</strong></p>
<p><strong>MySQL数据库默认的隔离级别是：可重复读</strong></p>
<h4 id="自动提交">自动提交</h4>
<ul>
<li>
<p>MySQL事务默认情况下是自动提交的</p>
<ul>
<li>什么是自动提交？只要执行一句DML语句则提交一次。</li>
<li>如何关闭自动提交？ ---&gt;  <strong>Start transaction;</strong></li>
</ul>
</li>
</ul>
<pre><code>  //演示自动提交机制
  //插入数据后，回滚rollback;
  //回滚后数据还是一条，回滚rollback无法回去。
  
  drop table if exists t_user;
  create table t_user(
  	id int primary key auto_increment,
  	username varchar(255)
  );
  
  mysql&gt;  insert into t_user(username) value ('richard');
  Query OK, 1 row affected (0.11 sec)
  
  mysql&gt; select * from t_user;
  +----+----------+
  | id | username |
  +----+----------+
  |  1 | richard  |
  +----+----------+
  1 row in set (0.00 sec)
  
  mysql&gt; rollback;
  Query OK, 0 rows affected (0.01 sec)
  
  mysql&gt; select * from t_user;
  +----+----------+
  | id | username |
  +----+----------+
  |  1 | richard  |
  +----+----------+
  1 row in set (0.00 sec)
  
</code></pre>
<h5 id="关闭自动提交-start-transaction">关闭自动提交 <em>start transaction</em></h5>
<pre><code>// start transaction 
// 关闭自动提交后，插入数据再回滚rollback
// 可以回到之前 start transaction 的点

mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t_user(username) value('monica');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value('denish');
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
|  2 | monica   |
|  3 | denish   |
+----+----------+
3 rows in set (0.00 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.11 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
+----+----------+
1 row in set (0.00 sec)
-------------------------------------------------------

// rollback 代表事务结束，需重新开始事务
// start transaction 关闭自动提交后插入数据
// 需手动提交，提交后无法再回滚 rollback;

mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('rose');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('jordan');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('kobe');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('James');
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
|  4 | rose     |
|  5 | jordan   |
|  6 | kobe     |
|  7 | James    |
+----+----------+
5 rows in set (0.00 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.11 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
|  4 | rose     |
|  5 | jordan   |
|  6 | kobe     |
|  7 | James    |
+----+----------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="隔离级别设置">隔离级别设置</h4>
<ul>
<li>演示：read uncommitted</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 读未提交
set global transaction isolation level read uncommitted;

//查看事务目前全局隔离级别
select @@global.tx_isolation;

// 两个事务进程同时开启，A事务可读取到B事务未提交的数据
// 脏读现象 （dirty read） 
</code></pre>
<ul>
<li>演示：read committed</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 读已提交
set global transaction isolation level read committed;

select @@global.tx_isolation;

// 两个事务进程同时开启，A事务可读取到B事务已提交的数据
// 不可重复读。B事务每提交一次，A事务读取数据都会发生改变
</code></pre>
<ul>
<li>演示：repeatable read</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 可重复读
set global transaction isolation level repeatable read;

select @@global.tx_isolation;

// 可重复读，A事务提交，也不影响B事务读取数据
// 存在的问题是：读取到的数据是幻像，不是真实的。（幻读）
</code></pre>
<ul>
<li>演示：Serializable</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 序列化读
set global transaction isolation level serializable;

select @@global.tx_isolation;

// A事务与B事务需要排队进行，不能并发
// A事务提交后，B事务才能进行操作
</code></pre>
<h3 id="索引-index"><em>索引 index</em></h3>
<h5 id="什么是索引有什么作用">什么是索引？有什么作用？</h5>
<ul>
<li>索引相当于一本书的目录，通过目录可快速找到对应的资源。</li>
<li>在数据库中，查询一张表时有两种检索方式：
<ul>
<li>第一种：全表扫描</li>
<li>第二种：根据索引检索（效率很高）</li>
</ul>
</li>
<li>索引为什么可提高检索效率？
<ul>
<li>根本原理：缩小了检索范围。</li>
</ul>
</li>
</ul>
<blockquote>
<p>索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也行需要数据库不断的维护。</p>
<p>比如：表中的数据经常被修改，这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p>
<p>添加索引是给某一字段，或者说某些字段添加索引。</p>
<p>select ename, sal from emp where ename = 'SMITH';</p>
<p>当ename字段上没有添加索引时，以上SQL语句会进行全表扫描，扫描ename字段中所有的值。</p>
<p>当ename字段上添加索引时，以上SQL语句会根据索引扫描，快速定位。</p>
</blockquote>
<h5 id="怎么创建索引对象怎么删除索引">怎么创建索引对象？怎么删除索引？</h5>
<ul>
<li>
<p><em>create index 索引名称 on 表名(字段名);</em></p>
</li>
<li>
<p><em>drop index 索引名称 on 表名</em></p>
</li>
<li>
<p>什么时候考虑给字段添加索引?（满足什么条件）</p>
<ul>
<li>数据量庞大（根据客户需求，根据线上环境）</li>
<li>字段很少使用DML操作 （字段修改，索引也需维护）</li>
<li>该字段经常出现在where子句中（经常查询）</li>
</ul>
</li>
<li>
<p>注意：主键和具有unique约束的字段会自动添加索引。</p>
<ul>
<li>根据主键查询效率较高，尽量根据主键检索。</li>
</ul>
</li>
</ul>
<h5 id="查看sql语句的执行计划">查看SQL语句的执行计划</h5>
<pre><code>// type = ALL  表示全表扫描
// rows = 14   表示扫描了14条记录
mysql&gt; explain select ename,sal from emp where sal=5000;
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.04 sec)

// 给薪资添加索引
create index emp_sal_index on emp(sal);


// 添加索引后， rows = 1 只扫描一条记录
mysql&gt; explain select ename,sal from emp where sal=5000;
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
1 row in set (0.04 sec)
</code></pre>
<h5 id="索引原理">索引原理</h5>
<ul>
<li>索引底层数据结构采用的 ：B + Tree</li>
</ul>
<p>通过B Tree缩小扫描范围，底层索引进行了排序、分区、索引会携带数据在表中的“物理地址”</p>
<p>最终通过索引检查到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。</p>
<p><strong>select ename from emp where ename = 'SMITH';</strong></p>
<p>通过索引转化为</p>
<p><strong>select ename from emp where 物理地址 = 0x3;</strong></p>
<h5 id="索引的分类">索引的分类？</h5>
<ol>
<li>单一索引：给单个字段添加索引</li>
<li>复合索引：给多个字段联合起来添加一个索引</li>
<li>主键索引：主键上会自动添加索引</li>
<li>唯一索引：有unique约束的字段上会自动添加索引</li>
<li>......</li>
</ol>
<h5 id=""></h5>
<h5 id="索引什么时候失效">索引什么时候失效？</h5>
<p><strong>select ename from emp where ename like '%A%';</strong></p>
<p>模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p>
<h3 id="视图-view"><em>视图 view</em></h3>
<h4 id="什么是视图">什么是视图？</h4>
<ul>
<li>站在不同角度去看到数据。（同一张表的数据，通过不同角度去看待）</li>
</ul>
<h4 id="怎么创建视图怎么删除视图">怎么创建视图？怎么删除视图？</h4>
<p><strong>create view myview as select empno, ename from emp;</strong></p>
<p><strong>drop view myview;</strong></p>
<p><em>注意：只有DQL语句才能以视图对象的方式创建出来。</em></p>
<p><strong>对视图进行增删改查，会影响到原表数据</strong>（通过视图会影响原表数据，不是直接操作的原表）</p>
<p><strong>可以对视图进行CRUD操作</strong></p>
<pre><code>// 复制创建表
create table emp_bak as select * from emp;

// 创建视图
create view myview as select empno,ename,sal from emp_bak;

// 通过视图修改原表数据
 update myview set ename='hehe',sal='999' where empno = 7369;
 delete from myview where empno=7369;
</code></pre>
<h4 id="视图的作用">视图的作用？</h4>
<p><strong>视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。</strong></p>
<p><em>视图并不会提高检索效率</em></p>
<h3 id="dba-命令了解"><em>DBA 命令</em>（了解）</h3>
<h4 id="数据导出">数据导出</h4>
<ul>
<li>在Windows的dos命令窗口中执行: （导出整个库）
<ul>
<li>mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -prootchan</li>
</ul>
</li>
<li>在Windows的dos命令窗口中执行: （指定导出指定数据库当中的指定表）
<ul>
<li>mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -prootchan</li>
</ul>
</li>
</ul>
<h4 id="数据导入">数据导入</h4>
<ul>
<li>create database bjpowernode;</li>
<li>use bjpowernode;</li>
<li>source D:\bjpowernode.sql;</li>
</ul>
<h3 id="数据库设计三范式"><em>数据库设计三范式</em></h3>
<p><strong>设计表的依据，按照三范式设计的表不会出现数据冗余。</strong></p>
<ul>
<li>
<p>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</p>
</li>
<li>
<p>第二范式：建立在第一范式的基础之上，所有非主键字段都完全依赖主键，不能产生部分依赖（<strong>严格意义上说：尽量不要使用联合主键</strong>）</p>
<p><strong>多对多？三张表，关系表，两个外键。</strong></p>
<blockquote>
<p>学生编号(PK) 	教师编号(PK) 	学生姓名 	教师姓名</p>
<p>1001 					001 						张三 			王老师</p>
<p>1002 					002 						李四 			赵老师</p>
<p>1003 					001 						王五 			王老师</p>
<p>1001 					002 						张三 			赵老师</p>
<p>综合分析：</p>
<p>1、以上虽然确定了主键，但此表会出现大量冗余，主要涉及到的冗余字段为“学生姓名”和 “教师姓名”；</p>
<p>2、出现冗余的原因在于：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号， 而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。</p>
</blockquote>
<pre><code>解决方案如下：
t_student学生表
sno(pk)			sname
---------------------------------
1				张三
2				李四
3				王五

t_teacher教师表
tno(pk) 		tname
---------------------------------
1				王老师 
2				张老师
3				李老师 

t_student_teacher_relation 学生教师关系表
id(pk)		sno(fk)		tno(fk)
-----------------------------------------------
1			 1			 3
2			 1			 2
3			 2			 2
4			 3			 1	
5			 3			 1
6			 2	          3
</code></pre>
</li>
<li>
<p>第三范式：建立在第二范式基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</p>
<p><strong>一对多？两张表，多的表加外键。</strong></p>
<pre><code>示例一：学生信息表
学生编号（PK） 学生姓名 	班级编号	   班级名称
---------------------------------------------------
1001 			张三 		01 			一年一班
1002 			李四		02 			一年二班
1003 			王五 		03 			一年三班
1004 			赵六 		03 			一年三班
----------------------------------------------------
综合分析：
1、从表中看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键
2、班级名称字段依赖于班级编号，班级编号依赖亍学生编号，那么这就是传递依赖
解决方案：
1、将冗余字段单独拿出来建立表
2、如下表所示：学生信息表中班级编号设为外键FK

t_class 班级表
班级编号（PK） 	班级名称
--------------------------
01 				一年一班
02 				一年二班
03 				一年三班
--------------------------

t_student 学生表
学生编号（PK） 学生姓名 	班级编号（FK）
---------------------------------------
1001 			张三 		01
1002 			李四 		02
1003 			王五 		03
1004 			赵六 		03
---------------------------------------
</code></pre>
</li>
</ul>
<blockquote>
<p>提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</p>
</blockquote>
<h4 id="一对一表设计">一对一表设计</h4>
<ul>
<li>两种方案：主键共享、外键唯一</li>
</ul>
<pre><code>一对一设计方案：主键共享
t_user_login 用户登录表
id(pk)		username		password
------------------------------------
1		 	zs				123123
2		 	ls				123122

t_user_detail 用户详细信息表
id(pk+fk)		realname		tel			...
-------------------------------------------
1				张三			 15844562141
2				李四			 17584756721
--------------------------------------------


一对一设计方案：外键唯一
t_user_login 用户登录表
id(pk)		username		password
------------------------------------
1		 	zs				123123
2		 	ls				123122

t_user_detail 用户详细信息表
id(pk+fk)		realname		tel			 	userid(fk+unique)
----------------------------------------------------------------------
1				张三			 15844562141		 2
2				李四			 17584756721		 1
----------------------------------------------------------------------


</code></pre>
]]></content>
    </entry>
</feed>