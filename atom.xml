<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geckoc.github.io/</id>
    <title>RichardTech</title>
    <updated>2020-09-10T07:22:54.264Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geckoc.github.io/"/>
    <link rel="self" href="https://geckoc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://geckoc.github.io/images/avatar.png</logo>
    <icon>https://geckoc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, RichardTech</rights>
    <entry>
        <title type="html"><![CDATA[34道MySQL经典]]></title>
        <id>https://geckoc.github.io/post/34-dao-mysql-jing-dian/</id>
        <link href="https://geckoc.github.io/post/34-dao-mysql-jing-dian/">
        </link>
        <updated>2020-09-10T06:58:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-取得每个部门最高薪水的人员名称">1. 取得每个部门最高薪水的人员名称。</h4>
<pre><code>// 第一步，找出每个部门的最高薪水
select e.deptno,max(e.sal) as maxsal from emp e
group by e.deptno;
+--------+---------+
| deptno | maxsal  |
+--------+---------+
|     10 | 5000.00 |
|     20 | 3000.00 |
|     30 | 2850.00 |
+--------+---------+
// 将以上查询结果当成一个临时表t(deptno,maxsal)
select t.*,e.ename from emp e
join (select e.deptno,max(e.sal) as maxsal from emp e group by e.deptno) t
on t.deptno = e.deptno and t.maxsal = e.sal
order by t.deptno;
+--------+---------+-------+
| deptno | maxsal  | ename |
+--------+---------+-------+
|     10 | 5000.00 | KING  |
|     20 | 3000.00 | SCOTT |
|     20 | 3000.00 | FORD  |
|     30 | 2850.00 | BLAKE |
+--------+---------+-------+

------------------------------------------------------------------------------

select e.deptno, e.ename, t.maxsal from 
(select e.deptno,max(e.sal) as maxsal from emp e group by e.deptno) t
join emp e on t.deptno = e.deptno
where t.maxsal = e.sal
order by e.deptno;
+--------+-------+---------+
| deptno | ename | maxsal  |
+--------+-------+---------+
|     10 | KING  | 5000.00 |
|     20 | SCOTT | 3000.00 |
|     20 | FORD  | 3000.00 |
|     30 | BLAKE | 2850.00 |
+--------+-------+---------+

// 显示部门名称,多表连接
select e.deptno, d.dname, e.ename, t.maxsal from 
(select e.deptno,max(e.sal) as maxsal from emp e group by e.deptno) t
join emp e on t.deptno = e.deptno
join dept d on d.deptno = e.deptno
where t.maxsal = e.sal
order by e.deptno;
</code></pre>
<h4 id="2-哪些人的薪水在部门平均薪水之上">2. 哪些人的薪水在部门平均薪水之上</h4>
<pre><code>// 第一步找出每个部门的平均薪水
select deptno, avg(sal) as avgsal from emp group by deptno;
    +--------+-------------+
    | deptno | avg(sal)    |
    +--------+-------------+
    |     10 | 2916.666667 |
    |     20 | 2175.000000 |
    |     30 | 1566.666667 |
    +--------+-------------+
// 将以上查询结果当成一个临时表t(deptno,avgsal)
// 条件是部门编号相同,薪资大于平均值 t.deptno = e.deptno and e.sal &gt; t.avgsal;
select e.ename,e.sal,t.* from emp e
join (select deptno, avg(sal) as avgsal from emp group by deptno) t
on t.deptno = e.deptno and e.sal &gt; t.avgsal;
    +-------+---------+--------+-------------+
    | ename | sal     | deptno | avgsal      |
    +-------+---------+--------+-------------+
    | ALLEN | 1600.00 |     30 | 1566.666667 |
    | JONES | 2975.00 |     20 | 2175.000000 |
    | BLAKE | 2850.00 |     30 | 1566.666667 |
    | SCOTT | 3000.00 |     20 | 2175.000000 |
    | KING  | 5000.00 |     10 | 2916.666667 |
    | FORD  | 3000.00 |     20 | 2175.000000 |
    +-------+---------+--------+-------------+
    6 rows in set (0.00 sec) 
    ---------------------------------------------
select e.ename,e.sal,t.deptno,t.avgsal from emp e
join (select deptno, avg(sal) as avgsal from emp group by deptno) t
on t.deptno = e.deptno and e.sal &gt; t.avgsal
order by e.sal;
</code></pre>
<h4 id="3-取得部门中所有人的平均薪水等级">3. 取得部门中（所有人的）平均薪水等级</h4>
<ul>
<li>平均的薪水等级：先计算每一个人薪水的等级，然后找出薪水等级的平均值。</li>
<li>平均薪水的等级：先计算平均薪水，然后找出每个平均薪水的等级值。</li>
</ul>
<pre><code>平均的薪水等级
// 第一步：找出每个人的薪水等级
// emp e 和 salgrade s表连接
// 连接条件: e.sal between s.losal and s.hisal

select e.ename,e.sal,e.deptno,s.grade from emp e 
join salgrade s on e.sal between s.losal and s.hisal;
    +--------+---------+--------+-------+
    | ename  | sal     | deptno | grade |
    +--------+---------+--------+-------+
    | SMITH  |  800.00 |     20 |     1 |
    | ALLEN  | 1600.00 |     30 |     3 |
    | WARD   | 1250.00 |     30 |     2 |
    | JONES  | 2975.00 |     20 |     4 |
    | MARTIN | 1250.00 |     30 |     2 |
    | BLAKE  | 2850.00 |     30 |     4 |
    | CLARK  | 2450.00 |     10 |     4 |
    | SCOTT  | 3000.00 |     20 |     4 |
    | KING   | 5000.00 |     10 |     5 |
    | TURNER | 1500.00 |     30 |     3 |
    | ADAMS  | 1100.00 |     20 |     1 |
    | JAMES  |  950.00 |     30 |     1 |
    | FORD   | 3000.00 |     20 |     4 |
    | MILLER | 1300.00 |     10 |     2 |
    +--------+---------+--------+-------+
    14 rows in set (0.00 sec)
-----------------------------------------------
// 第二步 基于以上结果继续按照 group by 分组，求 grade的平均值
select e.deptno,avg(s.grade) from emp e
join salgrade s 
on e.sal between s.losal and s.hisal
group by e.deptno;


平均薪水的等级
// 第一步，找出每个部门的平均薪水
select e.deptno , avg(e.sal) as avgsal from emp e group by deptno;
    +--------+-------------+
    | deptno | avgsal      |
    +--------+-------------+
    |     10 | 2916.666667 |
    |     20 | 2175.000000 |
    |     30 | 1566.666667 |
    +--------+-------------+
    3 rows in set (0.00 sec)
// 查询结果当成临时表 t ,查询每个部门平均薪水的等级
select t.*,s.grade 
from (select e.deptno , avg(e.sal) as avgsal from emp e group by deptno) t
join salgrade s
on t.avgsal between s.losal and s.hisal;
+--------+-------------+-------+
| deptno | avgsal      | grade |
+--------+-------------+-------+
|     30 | 1566.666667 |     3 |
|     10 | 2916.666667 |     4 |
|     20 | 2175.000000 |     4 |
+--------+-------------+-------+
3 rows in set (0.00 sec)
</code></pre>
<h4 id="4不准用组函数max取得最高薪水给出两种解决方案">4.不准用组函数（MAX），取得最高薪水（给出两种解决方案）</h4>
<pre><code>// 第一种  降序+limit
select ename,sal from emp order by sal desc limit 1;
    +-------+---------+
    | ename | sal     |
    +-------+---------+
    | KING  | 5000.00 |
    +-------+---------+
//第二种 表的自连接 ,emp 当成两张表 a,b
select 
distinct a.sal
from emp a
join emp b
on a.sal &lt; b.sal;
    +---------+
    | sal     |
    +---------+
    |  800.00 |
    | 1250.00 |
    | 1500.00 |
    | 1100.00 |
    |  950.00 |
    | 1300.00 |
    | 1600.00 |
    | 2850.00 |
    | 2450.00 |
    | 2975.00 |
    | 3000.00 |
    +---------+
11 rows in set (0.00 sec)

select ename,sal from emp
where sal not in
(select distinct a.sal from emp a join emp b on a.sal &lt; b.sal);
    +-------+---------+
    | ename | sal     |
    +-------+---------+
    | KING  | 5000.00 |
    +-------+---------+
    1 row in set (0.00 sec)
</code></pre>
<h4 id="5取得平均薪水最高的部门的部门编号">5.取得平均薪水最高的部门的部门编号</h4>
<pre><code>// 第一种方案，降序取一个 limit
select deptno,avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1;

// 第二种方案，max
找出最大值
select max(t.avgsal) from 
(select avg(sal) as avgsal from emp group by deptno) t;
//根据以上结果
select deptno,avg(sal) as avgsal from emp
group by deptno
having avgsal = 
(select max(t.avgsal) from 
(select avg(sal) as avgsal from emp group by deptno) t);


-------------------------------(自研)-----------------------------------

select t.deptno,max(t.avgsal) from 
(select e.deptno,avg(e.sal) as avgsal from emp e group by deptno) t;
+--------+---------------+
| deptno | max(t.avgsal) |
+--------+---------------+
|     10 |   2916.666667 |
+--------+---------------+
------------------------------------------------------------------------

----------(自研)-------------
select d.dname,d.deptno 
from (select avg(sal) avgsal, deptno de from emp group by deptno) t
join dept d
on t.de = d.deptno 
having max(avgsal);
-----------------------------
</code></pre>
<h4 id="6取得平均薪水最高的部门的部门名称">6.取得平均薪水最高的部门的部门名称</h4>
<pre><code>// 降序 + limit
select d.dname,avg(e.sal) avgsal from emp e
join dept d
on d.deptno = e.deptno
group by dname
order by avgsal desc
limit 1;
+------------+-------------+
| dname      | avgsal      |
+------------+-------------+
| ACCOUNTING | 2916.666667 |
+------------+-------------+

------------------------（ME）--------------------------
select d.dname from (select avg(sal) avgsal, deptno de from emp group by deptno)t
join dept d
on t.de = d.deptno having max(avgsal);
--------------------------------------------------------
</code></pre>
<h4 id="7求平均薪水的等级最低的部门的部门名称">7.求平均薪水的等级最低的部门的部门名称</h4>
<pre><code>// 第一步，按照部门名称分组，找出每个部门的平均薪水
select d.dname,avg(e.sal) from emp e join dept d on d.deptno = e.deptno
group by d.dname;
+------------+-------------+
| dname      | avg(e.sal)  |
+------------+-------------+
| ACCOUNTING | 2916.666667 |
| RESEARCH   | 2175.000000 |
| SALES      | 1566.666667 |
+------------+-------------+
// 临时表 t
select t.dname,s.grade from 
(select d.dname,avg(e.sal) avgsal from emp e join dept d on d.deptno = e.deptno
group by d.dname)t
join salgrade s
on t.avgsal between s.losal and s.hisal
where s.grade = 
(select grade from salgrade where 
(select avg(sal) avgsal from emp group by deptno order by avgsal asc limit 1)
between losal and hisal);
        +-------+-------+
        | dname | grade |
        +-------+-------+
        | SALES |     3 |
        +-------+-------+
        1 row in set (0.00 sec)
-----------------------------------------------
where s.grade = 3;
-----------------------------------------------
where子句后，以下为思路逻辑

// 找出最低的平均薪资
select avg(sal) avgsal from emp group by deptno order by avgsal asc limit 1;
        +-------------+
        | avgsal      |
        +-------------+
        | 1566.666667 |
        +-------------+
    1 row in set (0.00 sec)
 -------------------------------------------------
// 根据以上结果直接找出最低等级
select grade from salgrade where 
(select avg(sal) avgsal from emp group by deptno order by avgsal asc limit 1)
between losal and hisal;
    +-------+
    | grade |
    +-------+
    |     3 |
    +-------+
-----------------------------------------------------

</code></pre>
<h4 id="8取得比普通员工员工代码没有在mgr上出现的的最高薪水还要高的经理人姓名">8.取得比普通员工（员工代码没有在mgr上出现的）的最高薪水还要高的经理人姓名</h4>
<pre><code>select distinct mgr from emp where mgr is not null;
    +------+
    | mgr  |
    +------+
    | 7902 |
    | 7698 |
    | 7839 |
    | 7566 |
    | 7788 |
    | 7782 |
    +------+
------------------------------------------------
// 员工编号没有在以上范围内的都是普通员工
// 找出普通员工的最高薪水
注意!not in在使用的时候，后面小括号的条件中记得排除NULL
select max(sal) from emp 
where empno 
not in(select distinct mgr from emp where mgr is not null);
        +----------+
        | max(sal) |
        +----------+
        |  1600.00 |
        +----------+
------------------------------------------- 
// 第二步，找出高于1600的经理
select ename,sal from emp where sal &gt; 
(select max(sal) from emp where empno 
not in(select distinct mgr from emp where mgr is not null));
        +-------+---------+
        | ename | sal     |
        +-------+---------+
        | JONES | 2975.00 |
        | BLAKE | 2850.00 |
        | CLARK | 2450.00 |
        | SCOTT | 3000.00 |
        | KING  | 5000.00 |
        | FORD  | 3000.00 |
        +-------+---------+
6 rows in set (0.00 sec)

</code></pre>
<h4 id="9取得薪水最高的前五名员工">9.取得薪水最高的前五名员工</h4>
<pre><code>select ename , sal from emp order by sal desc limit 5;
    +-------+---------+
    | ename | sal     |
    +-------+---------+
    | KING  | 5000.00 |
    | SCOTT | 3000.00 |
    | FORD  | 3000.00 |
    | JONES | 2975.00 |
    | BLAKE | 2850.00 |
    +-------+---------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="10取得薪水最高的第六到第十名员工">10.取得薪水最高的第六到第十名员工</h4>
<pre><code>select ename,sal from emp order by sal desc limit 5,5;
    +--------+---------+
    | ename  | sal     |
    +--------+---------+
    | CLARK  | 2450.00 |
    | ALLEN  | 1600.00 |
    | TURNER | 1500.00 |
    | MILLER | 1300.00 |
    | MARTIN | 1250.00 |
    +--------+---------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="11取得最后入职的5名员工">11.取得最后入职的5名员工</h4>
<pre><code>// 日期也可以升序降序
select ename,hiredate from emp order by hiredate desc limit 5;
    +--------+------------+
    | ename  | hiredate   |
    +--------+------------+
    | ADAMS  | 1987-05-23 |
    | SCOTT  | 1987-04-19 |
    | MILLER | 1982-01-23 |
    | FORD   | 1981-12-03 |
    | JAMES  | 1981-12-03 |
    +--------+------------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="12取得每个薪水等级有多少员工">12.取得每个薪水等级有多少员工</h4>
<pre><code>// 找出每个员工的薪水等级
select e.ename,e.sal,s.grade from emp e
join salgrade s
on e.sal between s.losal and hisal;
+--------+---------+-------+
| ename  | sal     | grade |
+--------+---------+-------+
| SMITH  |  800.00 |     1 |
| ALLEN  | 1600.00 |     3 |
| WARD   | 1250.00 |     2 |
| JONES  | 2975.00 |     4 |
| MARTIN | 1250.00 |     2 |
| BLAKE  | 2850.00 |     4 |
| CLARK  | 2450.00 |     4 |
| SCOTT  | 3000.00 |     4 |
| KING   | 5000.00 |     5 |
| TURNER | 1500.00 |     3 |
| ADAMS  | 1100.00 |     1 |
| JAMES  |  950.00 |     1 |
| FORD   | 3000.00 |     4 |
| MILLER | 1300.00 |     2 |
+--------+---------+-------+
14 rows in set (0.00 sec)
----------------------------------------------
// 第二步，继续按照 group by 分组统计数量
select s.grade,count(*) from emp e
join salgrade s
on e.sal between s.losal and hisal
group by s.grade;
+-------+----------+
| grade | count(*) |
+-------+----------+
|     1 |        3 |
|     2 |        3 |
|     3 |        2 |
|     4 |        5 |
|     5 |        1 |
+-------+----------+
5 rows in set (0.02 sec)
</code></pre>
<h4 id="13-面试题">13. 面试题</h4>
<h4 id="14列出所有员工及领导的名字">14.列出所有员工及领导的名字</h4>
<pre><code class="language-mysql">// 表连接，左外连接
select e.ename '员工' , d.ename '领导' from emp e
left outer join emp d
on e.mgr = d.empno;
</code></pre>
<h4 id="15列出受雇日期早于其直接上级的所有员工编号-姓名-部门名称">15.列出受雇日期早于其直接上级的所有员工编号、姓名、部门名称</h4>
<pre><code>select e.empno,e.ename '员工',d.dname from emp e
join emp b
on e.mgr = b.empno and e.hiredate &lt; b.hiredate
join dept d
on e.deptno = d.deptno;
+-------+-------+------------+
| empno | 员工  | dname      |
+-------+-------+------------+
|  7782 | CLARK | ACCOUNTING |
|  7369 | SMITH | RESEARCH   |
|  7566 | JONES | RESEARCH   |
|  7499 | ALLEN | SALES      |
|  7521 | WARD  | SALES      |
|  7698 | BLAKE | SALES      |
+-------+-------+------------+
6 rows in set (0.00 sec)
--------------------(优化)----------------------------
select e.empno,e.ename '员工', e.hiredate,b.ename '领导',b.hiredate,d.dname from emp e
join emp b
on e.mgr = b.empno and e.hiredate &lt; b.hiredate
join dept d
on e.deptno = d.deptno;
+-------+-------+------------+-------+------------+------------+
| empno | 员工  | hiredate   | 领导  | hiredate   | dname      |
+-------+-------+------------+-------+------------+------------+
|  7782 | CLARK | 1981-06-09 | KING  | 1981-11-17 | ACCOUNTING |
|  7369 | SMITH | 1980-12-17 | FORD  | 1981-12-03 | RESEARCH   |
|  7566 | JONES | 1981-04-02 | KING  | 1981-11-17 | RESEARCH   |
|  7499 | ALLEN | 1981-02-20 | BLAKE | 1981-05-01 | SALES      |
|  7521 | WARD  | 1981-02-22 | BLAKE | 1981-05-01 | SALES      |
|  7698 | BLAKE | 1981-05-01 | KING  | 1981-11-17 | SALES      |
+-------+-------+------------+-------+------------+------------+
</code></pre>
<h4 id="16列出部门名称和这些部门的员工信息同时列出那些没有员工的部门">16.列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门</h4>
<pre><code>// 右外连接
select d.*,e.* from emp e 
right join dept d
on e.deptno = d.deptno;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://geckoc.github.io//post-images/1599721472090.png" alt="" loading="lazy"></figure>
<h4 id="17列出至少有5个员工的所有部门">17.列出至少有5个员工的所有部门</h4>
<pre><code>// 第一步：先求出每个部门的员工数量
select deptno,count(*) from emp group by deptno;
+--------+----------+
| deptno | count(*) |
+--------+----------+
|     10 |        3 |
|     20 |        5 |
|     30 |        6 |
+--------+----------+
3 rows in set (0.00 sec)
// 第二步
select deptno,count(ename) 'TotalEmp' from emp group by deptno having count('TotalEmp') &gt;= 5;
+--------+----------+
| deptno | TotalEmp |
+--------+----------+
|     20 |        5 |
|     30 |        6 |
+--------+----------+
2 rows in set (0.00 sec)
</code></pre>
<h4 id="18列出薪水比smith多的所有员工信息">18.列出薪水比“SMITH”多的所有员工信息</h4>
<pre><code>select sal from emp where ename = 'smith';
+--------+
| sal    |
+--------+
| 800.00 |
+--------+

select ename,sal from emp where sal &gt; (select sal from emp where ename = 'smith');
+--------+---------+
| ename  | sal     |
+--------+---------+
| ALLEN  | 1600.00 |
| WARD   | 1250.00 |
| JONES  | 2975.00 |
| MARTIN | 1250.00 |
| BLAKE  | 2850.00 |
| CLARK  | 2450.00 |
| SCOTT  | 3000.00 |
| KING   | 5000.00 |
| TURNER | 1500.00 |
| ADAMS  | 1100.00 |
| JAMES  |  950.00 |
| FORD   | 3000.00 |
| MILLER | 1300.00 |
+--------+---------+
13 rows in set (0.00 sec)
</code></pre>
<h4 id="19列出所有clerk办事员的姓名及其部门名称部门人数">19.列出所有“CLERK”（办事员）的姓名及其部门名称，部门人数</h4>
<pre><code>select e.job,e.ename,d.dname,d.deptno from emp e 
join dept d
on e.deptno = d.deptno and e.job = 'clerk';
+-------+--------+------------+--------+
| job   | ename  | dname      | deptno |
+-------+--------+------------+--------+
| CLERK | MILLER | ACCOUNTING |     10 |
| CLERK | SMITH  | RESEARCH   |     20 |
| CLERK | ADAMS  | RESEARCH   |     20 |
| CLERK | JAMES  | SALES      |     30 |
+-------+--------+------------+--------+

select deptno,count(*) as deptcount from emp group by deptno;
+--------+-----------+
| deptno | deptcount |
+--------+-----------+
|     10 |         3 |
|     20 |         5 |
|     30 |         6 |
+--------+-----------+

// 将以上结果当做两张表 t1 ,t2
select t1.* ,t2.deptcount 
from (select e.job,e.ename,d.dname,d.deptno from emp e 
join dept d
on e.deptno = d.deptno and e.job = 'clerk')t1
join (select deptno,count(*) as deptcount from emp group by deptno)t2
on t1.deptno = t2.deptno;

+-------+--------+------------+--------+-----------+
| job   | ename  | dname      | deptno | deptcount |
+-------+--------+------------+--------+-----------+
| CLERK | MILLER | ACCOUNTING |     10 |         3 |
| CLERK | SMITH  | RESEARCH   |     20 |         5 |
| CLERK | ADAMS  | RESEARCH   |     20 |         5 |
| CLERK | JAMES  | SALES      |     30 |         6 |
+-------+--------+------------+--------+-----------+
4 rows in set (0.00 sec)

</code></pre>
<h4 id="20列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数">20.列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数</h4>
<pre><code>select job,count(*) from emp group by job having min(sal) &gt; 1500;
+-----------+----------+
| job       | count(*) |
+-----------+----------+
| ANALYST   |        2 |
| MANAGER   |        3 |
| PRESIDENT |        1 |
+-----------+----------+
3 rows in set (0.00 sec)
</code></pre>
<h4 id="21列出在部门sales销售部工作的员工的姓名假定不知道销售部门的部门编号">21.列出在部门“SALES”&lt;销售部&gt;工作的员工的姓名，假定不知道销售部门的部门编号</h4>
<pre><code>select deptno from dept where dname = 'sales';
select ename,deptno from emp where deptno = (select deptno from dept where dname = 'sales');
+--------+--------+
| ename  | deptno |
+--------+--------+
| ALLEN  |     30 |
| WARD   |     30 |
| MARTIN |     30 |
| BLAKE  |     30 |
| TURNER |     30 |
| JAMES  |     30 |
+--------+--------+
6 rows in set (0.00 sec)

</code></pre>
<h4 id="22列出薪金高于公司平均薪金的所有员工所在部门-上级领导-雇员的工资等级">22.列出薪金高于公司平均薪金的所有员工，所在部门、上级领导、雇员的工资等级</h4>
<pre><code>select avg(sal) from emp;  // 公司平均薪水

select e.ename '员工',d.dname , l.ename '领导',s.grade
from emp e
join dept d
on d.deptno = e.deptno
left join emp l
on e.mgr = l.empno
join salgrade s
on e.sal between s.losal and s.hisal
where e.sal &gt; (select avg(sal) from emp);

</code></pre>
<h4 id="23列出与scott从事相同工作的所有员工及部门名称">23.列出与“SCOTT”从事相同工作的所有员工及部门名称</h4>
<pre><code>select job from emp where ename = 'scott';

select e.job,e.ename,d.dname
from emp e 
join dept d 
on e.deptno = d.deptno
where job = (select job from emp where ename = 'scott')
and e.ename &lt;&gt; 'scott';
+---------+-------+----------+
| job     | ename | dname    |
+---------+-------+----------+
| ANALYST | FORD  | RESEARCH |
+---------+-------+----------+
</code></pre>
<h4 id="24列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金">24.列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金</h4>
<pre><code>select distinct sal from emp where deptno = 30;			
+---------+
| sal     |
+---------+
| 1600.00 |
| 1250.00 |
| 2850.00 |
| 1500.00 |
|  950.00 |
+---------+

select ename,sal from emp
where sal in(select distinct sal from emp where deptno = 30)
and deptno &lt;&gt; 30;

Empty set (0.00 sec)   //无记录
</code></pre>
<h4 id="25列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金-部门名称">25.列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金、部门名称</h4>
<pre><code>select max(sal) from emp where deptno = 30;
+----------+
| max(sal) |
+----------+
|  2850.00 |
+----------+
select e.ename,e.sal,d.dname
from emp e
join dept d
on d.deptno = e.deptno
where sal &gt; (select max(sal) from emp where deptno = 30);

+-------+---------+------------+
| ename | sal     | dname      |
+-------+---------+------------+
| KING  | 5000.00 | ACCOUNTING |
| JONES | 2975.00 | RESEARCH   |
| SCOTT | 3000.00 | RESEARCH   |
| FORD  | 3000.00 | RESEARCH   |
+-------+---------+------------+
4 rows in set (0.00 sec)
</code></pre>
<h4 id="26列出在每个部门工作的员工数量-平均工资和平均服务期限">26.列出在每个部门工作的员工数量、平均工资和平均服务期限</h4>
<pre><code class="language-mysql">
</code></pre>
<h4 id="27列出所有员工的姓名-部门名称和工资">27.列出所有员工的姓名、部门名称和工资</h4>
<pre><code>select e.ename,d.dname,e.sal
from emp e
join dept d
on e.deptno = d.deptno;

+--------+------------+---------+
| ename  | dname      | sal     |
+--------+------------+---------+
| CLARK  | ACCOUNTING | 2450.00 |
| KING   | ACCOUNTING | 5000.00 |
| MILLER | ACCOUNTING | 1300.00 |
| SMITH  | RESEARCH   |  800.00 |
| JONES  | RESEARCH   | 2975.00 |
| SCOTT  | RESEARCH   | 3000.00 |
| ADAMS  | RESEARCH   | 1100.00 |
| FORD   | RESEARCH   | 3000.00 |
| ALLEN  | SALES      | 1600.00 |
| WARD   | SALES      | 1250.00 |
| MARTIN | SALES      | 1250.00 |
| BLAKE  | SALES      | 2850.00 |
| TURNER | SALES      | 1500.00 |
| JAMES  | SALES      |  950.00 |
+--------+------------+---------+
14 rows in set (0.00 sec)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL三部曲之驾轻就熟]]></title>
        <id>https://geckoc.github.io/post/mysql-san-bu-qu-zqjs/</id>
        <link href="https://geckoc.github.io/post/mysql-san-bu-qu-zqjs/">
        </link>
        <updated>2020-08-21T06:53:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="约束-constraint"><em>约束 Constraint</em></h3>
<blockquote>
<p>在创建表时，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性、有效性、完整性，以下为常见的约束：</p>
</blockquote>
<ol>
<li>非空约束(not null) ：约束的字段不能为null。</li>
<li>唯一约束(unique) ：约束的字段不能重复。</li>
<li>主键约束(primary key) ：约束的字段不能为null，也不能重复。（简称PK）</li>
<li>外检约束(foreign key) ：...（简称FK）</li>
<li>检查约束(check) ：注意Oracle数据库有check约束，MySQL目前不支持该约束，MySQL中没有。</li>
</ol>
<h4 id="not-null-非空约束">not null 非空约束</h4>
<pre><code>drop table if exists t_user;
create table t_user(
	id int,
	username varchar(255) NOT NULL,
	password varchar(255)
);
insert into t_user(id,password) values(1,'psw');
ERROR 1364 ..........  报错

insert into t_user(id,usename,password) values(1,'ric','psw');
</code></pre>
<h4 id="unique-唯一性约束">unique 唯一性约束</h4>
<ul>
<li>唯一性约束修饰的字段具有唯一性，不能重复，但可以为null。
<ul>
<li>案例：给某一列添加unique</li>
</ul>
</li>
</ul>
<pre><code>drop table if exists t_user;

mysql&gt; create table t_user(
    -&gt; id int,
    -&gt; username varchar(255) unique);   //列级约束
Query OK, 0 rows affected (0.14 sec)

insert into t_user(id,username) values(1,'rich');
Query OK, 1 row affected (0.14 sec)

insert into t_user(id,username) values(2,'rich');
ERROR 1062 (23000): Duplicate entry 'rich' for key 'username'

//字段具有唯一性，不能重复，可以为null
insert into t_user(id) value(2);
insert into t_user(id) value(3);
mysql&gt; select * from t_user;
    +------+----------+
    | id   | username |
    +------+----------+
    |    1 | rich     |
    |    2 | NULL     |
    |    3 | NULL     |
    +------+----------+
3 rows in set (0.00 sec)
</code></pre>
<ul>
<li>案例：给两个列或者多个列添加unique</li>
<li><em>not null</em> 约束只有列级约束，没有表级约束</li>
</ul>
<pre><code>create table t_user(
id int,
usercode varchar(255),
username varchar(255),
    unique(usercode,username) //多个字段联合起来添加一个约束unique (表级约束)
);

// 联合约束
mysql&gt; insert into t_user values (1,'111','rich');
mysql&gt; insert into t_user values (1,'222','rich');
mysql&gt; insert into t_user values (1,'333','rich');

//两个字段都重复，报错
mysql&gt; insert into t_user values (1,'111','rich');
ERROR 1062 (23000): Duplicate entry '111-rich' for key 'usercode'


</code></pre>
<h4 id="primary-key-主键约束">primary key 主键约束</h4>
<ul>
<li>约束的字段不能为null，也不能重复。（简称PK）</li>
<li>主键相关术语： 主键约束、主键字段、主键值</li>
<li>主键有什么作用？
<ul>
<li>表的设计三范式：第一范式就是要求任何一张表都应该有主键</li>
<li>作用：主键值是这行记录在这张表中的唯一标识。(像人的身份证一样)</li>
</ul>
</li>
</ul>
<pre><code>drop table if exists t_user;
create table t_user(
	id int primary key,   // 列级约束
    username varchar(255),
    email varchar(255)
);

insert into t_user(id,username,email) values(1,'rich','text@gmail.com');
insert into t_user(id,username,email) values(2,'monica','demo@gmail.com');
insert into t_user(id,username,email) values(3,'denish','google@gmail.com');

//主键不可重复
insert into t_user(id,username,email)values(1,'jack','jack@gmail.com');
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
//主键不可为Null
insert into t_user(username,email) values ('jack','jack@gmail.com');
ERROR 1364 (HY000): Field 'id' doesn't have a default value
</code></pre>
<h5 id="主键的分类">主键的分类</h5>
<p><em><strong>一张表的主键约束只能有一个（记住）</strong></em></p>
<ul>
<li>
<p>根据主键字段的字段数量划分</p>
<ul>
<li>单一主键(推荐，常用的)</li>
<li>复合主键(多字段联合起来添加一个主键约束)---&gt;[复合主键不建议使用，因违背三范式]</li>
</ul>
</li>
<li>
<p>根据主键性质划分</p>
<ul>
<li>
<p>自然主键：主键值最好就是和一个业务没有任何关系的自然数。(推荐)</p>
</li>
<li>
<p>业务主键：主键值和系统业务挂钩</p>
<blockquote>
<p>例如拿着银行卡的卡号做主键，拿身份证做主键（不推荐用）</p>
<p>最好不要使用和业务挂钩的字段作为主键，因为以后的业务一旦发生改变的时候，主键值也需要随着发生改变，但有的时候没有办法改变，因为改变可能会导致主键值重复。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>使用表级约束方式定义主键</p>
</li>
</ul>
<pre><code>drop table if exists t_user;
create table t_user(
     id int,
     username varchar(255),
     primary key(id)
 	);
 	
//演示复合主键，无需掌握
create table t_user(
	id int ,
    username varchar(255),
    password varchar(255),
    primary key(id,username)
);
</code></pre>
<ul>
<li>MySQL提供主键值自增（重点）</li>
</ul>
<pre><code>drop table if exists t_user;

//auto_increment  主键值自增
create table t_user(
	id int primary key auto_increment, //id字段自动维护一个自增的数字，从1开始，以1递增
    username varchar(255)
); 
insert into t_user(username) value('ric');
insert into t_user(username) value('1ic');
insert into t_user(username) value('2ic');
insert into t_user(username) value('3ic');
select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | ric      |
|  2 | 1ic      |
|  3 | 2ic      |
|  4 | 3ic      |
+----+----------+
4 rows in set (0.00 sec)
</code></pre>
<ul>
<li>Oracle当中也提供了一种自增机制，叫做序列（sequence）对象。</li>
</ul>
<h4 id="foreign-key外键约束">foreign key外键约束</h4>
<ul>
<li>外键约束的相关术语：外键约束、外键字段、外键值
<ul>
<li>业务背景：请设计数据库表，用来维护学生和班级信息？</li>
</ul>
</li>
</ul>
<pre><code>第一种方案：一张表
no(pk)		name			classno			classname
----------------------------------------------------------------------------------------
1			zs1				1101			高三1班
2			zs2				1101			高三1班
3			zs3				1102			高三2班
4			zs4				1102			高三2班
5			zs5				1102			高三2班
----------------------------------------------------------------------------------------
缺点：数据冗余！

第二种方案：两张表（班级表和学生表）
t_class:
cno(pk)		classname
----------------------------------------
1101		高三1班
1102		高三2班
----------------------------------------
t_student
sno(pk)		sname		classno(fk)该字段添加外键约束
----------------------------------------
1			zs1				1101
2			zs2				1101
3			zs3				1102
4			zs4				1102
5			zs5				1102
------------------------------------------
classno如果不添加fk外键约束，则可以任意自定义添加，所以需添加 foreign key约束

t_student中的classno引用t_class表中的cno字段，此时t_student叫做子表，t_class叫做父表。

顺序要求：
    删除数据的时候，先删除子表，在删除父表。
    添加数据的时候，先添加父表，再添加子表。
    删除表的时候，先删除子表，再删除父表。
    创建表的时候，先创建父表，再创建子表。

drop table if exists t_student;
drop table if exists t_class;

create table t_class(
	cno int primary key,
    classname varchar(255)
);
create table t_student(
	sno int primary key auto_increment,
    sname varchar(255),
    classno int,
    foreign key(classno) references t_class(cno)
);

insert into t_class(cno,classname) values(1101,'xxxx');
insert into t_class(cno,classname) values(1102,'yyyy');

insert into t_student(sname,classno) values ('zs1',1101);
insert into t_student(sname,classno) values ('zs2',1101);
insert into t_student(sname,classno) values ('zs3',1102);
insert into t_student(sname,classno) values ('zs4',1102);
insert into t_student(sname,classno) values ('zs5',1102);

select * from t_class;
select * from t_student;
+------+-----------+
| cno  | classname |
+------+-----------+
| 1101 | xxxx      |
| 1102 | yyyy      |
+------+-----------+
2 rows in set (0.00 sec)

+-----+-------+---------+
| sno | sname | classno |
+-----+-------+---------+
|   1 | zs1   |    1101 |
|   2 | zs2   |    1101 |
|   3 | zs3   |    1102 |
|   4 | zs4   |    1102 |
|   5 | zs5   |    1102 |
+-----+-------+---------+
5 rows in set (0.00 sec)

//外键约束，插入的数据在引用数据中没有，报错1452
insert into t_student(sname,classno) values('lisi',103);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bjpowernode`.`t_student`, CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))
</code></pre>
<ul>
<li>外键值可以为NULL</li>
<li>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？
<ul>
<li>注意：被引用的字段不一定是主键，但至少具有<em>unique</em>约束。</li>
</ul>
</li>
</ul>
<h3 id="存储引擎了解内容"><em>存储引擎(了解内容)</em></h3>
<h3 id="事务-transaction"><em>事务 Transaction</em></h3>
<ul>
<li>
<p>一个事务是一个完整的业务逻辑单元。不可再分。</p>
</li>
<li>
<p>比如银行账户转账：A账户向B账户转账10000，需执行两条Update语句。</p>
<pre><code>update t_act set balance = balance - 10000 where actno = 'act-A';
update t_act set balance = balance + 10000 where actno = 'act-B';
</code></pre>
<ul>
<li>以上两条DML语句必须同时成功或同时失败，不允许出现一条成功，一条失败。</li>
</ul>
<p>要想保证以上的DML语句同时成功或失败，则需要使用数据库的“事务机制”。</p>
<hr>
</li>
<li>
<p>和事务相关的语句只有DML语句 (insert、delete、update)</p>
<ul>
<li>因为他们三个语句都是和数据库表当中的“数据”相关的。</li>
<li>事务的存在是为了保证数据的完整性，安全性。</li>
</ul>
</li>
<li>
<p>假设事务只需要一条DML语句可以解决，则不需要事务机制。</p>
<ul>
<li>但实际情况不是如此，通常一个“事务（业务）”需要多条DML语句共同联合完成。</li>
</ul>
</li>
</ul>
<h4 id="事务的特性-acid">事务的特性  <em>ACID</em></h4>
<ul>
<li>事务的四大特性： <strong>Atomicity、Consistency、Isolation、Durability</strong></li>
</ul>
<p>A：原子性：事务是最小的工作单元，不可再分；要么全部完成，要么均不执行。</p>
<p>C：一致性：事务必须保证多条DML语句同时成功或同时失败。</p>
<p>I ：隔离性：事务A和事务B之间具有隔离，事务的执行不受其他事务的干扰。</p>
<p>D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p>
<h4 id="isolation-隔离性"><strong>Isolation</strong> 隔离性</h4>
<ul>
<li>事务隔离性存在隔离级别，理论上隔离级别包括4个
<ul>
<li>第一级别：读未提交（<strong>read uncommitted</strong>）
<ul>
<li>对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。</li>
<li>读未提交有存在脏读（<strong>dirty read</strong>）现象：表示读到了脏数据。</li>
</ul>
</li>
<li>第二级别：读已提交（<strong>read committed</strong>）
<ul>
<li>对方事务提交之后的数据我方可以读取到</li>
<li>读已提交存在的问题：不可重复读。(每次读取数据都不一样)</li>
</ul>
</li>
<li>第三级别：可重复读（<strong>repeatable read</strong>）
<ul>
<li>对方事务提交之后的数据我方读不到。</li>
<li>这种隔离级别解决了：不可重复读问题。只要当前事务没结束，读到的数据永远都是一样的。</li>
<li>此种隔离级别存在的问题是：读取到的数据是幻像，不是真实的。（幻读）</li>
</ul>
</li>
<li>第四级别：序列化读/串行化读（<strong>Serializable</strong>）
<ul>
<li>解决了所有问题</li>
<li>事务A和事务B不能并发，效率低，需要事务排队。</li>
<li>隔离级别最高，效率最低，数据最安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Oracle数据库默认的隔离级别是：读已提交</strong></p>
<p><strong>MySQL数据库默认的隔离级别是：可重复读</strong></p>
<h4 id="自动提交">自动提交</h4>
<ul>
<li>
<p>MySQL事务默认情况下是自动提交的</p>
<ul>
<li>什么是自动提交？只要执行一句DML语句则提交一次。</li>
<li>如何关闭自动提交？ ---&gt;  <strong>Start transaction;</strong></li>
</ul>
</li>
</ul>
<pre><code>  //演示自动提交机制
  //插入数据后，回滚rollback;
  //回滚后数据还是一条，回滚rollback无法回去。
  
  drop table if exists t_user;
  create table t_user(
  	id int primary key auto_increment,
  	username varchar(255)
  );
  
  mysql&gt;  insert into t_user(username) value ('richard');
  Query OK, 1 row affected (0.11 sec)
  
  mysql&gt; select * from t_user;
  +----+----------+
  | id | username |
  +----+----------+
  |  1 | richard  |
  +----+----------+
  1 row in set (0.00 sec)
  
  mysql&gt; rollback;
  Query OK, 0 rows affected (0.01 sec)
  
  mysql&gt; select * from t_user;
  +----+----------+
  | id | username |
  +----+----------+
  |  1 | richard  |
  +----+----------+
  1 row in set (0.00 sec)
  
</code></pre>
<h5 id="关闭自动提交-start-transaction">关闭自动提交 <em>start transaction</em></h5>
<pre><code>// start transaction 
// 关闭自动提交后，插入数据再回滚rollback
// 可以回到之前 start transaction 的点

mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t_user(username) value('monica');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value('denish');
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
|  2 | monica   |
|  3 | denish   |
+----+----------+
3 rows in set (0.00 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.11 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
+----+----------+
1 row in set (0.00 sec)
-------------------------------------------------------

// rollback 代表事务结束，需重新开始事务
// start transaction 关闭自动提交后插入数据
// 需手动提交，提交后无法再回滚 rollback;

mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('rose');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('jordan');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('kobe');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t_user(username) value ('James');
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
|  4 | rose     |
|  5 | jordan   |
|  6 | kobe     |
|  7 | James    |
+----+----------+
5 rows in set (0.00 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.11 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from t_user;
+----+----------+
| id | username |
+----+----------+
|  1 | richard  |
|  4 | rose     |
|  5 | jordan   |
|  6 | kobe     |
|  7 | James    |
+----+----------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="隔离级别设置">隔离级别设置</h4>
<ul>
<li>演示：read uncommitted</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 读未提交
set global transaction isolation level read uncommitted;

//查看事务目前全局隔离级别
select @@global.tx_isolation;

// 两个事务进程同时开启，A事务可读取到B事务未提交的数据
// 脏读现象 （dirty read） 
</code></pre>
<ul>
<li>演示：read committed</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 读已提交
set global transaction isolation level read committed;

select @@global.tx_isolation;

// 两个事务进程同时开启，A事务可读取到B事务已提交的数据
// 不可重复读。B事务每提交一次，A事务读取数据都会发生改变
</code></pre>
<ul>
<li>演示：repeatable read</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 可重复读
set global transaction isolation level repeatable read;

select @@global.tx_isolation;

// 可重复读，A事务提交，也不影响B事务读取数据
// 存在的问题是：读取到的数据是幻像，不是真实的。（幻读）
</code></pre>
<ul>
<li>演示：Serializable</li>
</ul>
<pre><code>//设置全局事务隔离级别为: 序列化读
set global transaction isolation level serializable;

select @@global.tx_isolation;

// A事务与B事务需要排队进行，不能并发
// A事务提交后，B事务才能进行操作
</code></pre>
<h3 id="索引-index"><em>索引 index</em></h3>
<h5 id="什么是索引有什么作用">什么是索引？有什么作用？</h5>
<ul>
<li>索引相当于一本书的目录，通过目录可快速找到对应的资源。</li>
<li>在数据库中，查询一张表时有两种检索方式：
<ul>
<li>第一种：全表扫描</li>
<li>第二种：根据索引检索（效率很高）</li>
</ul>
</li>
<li>索引为什么可提高检索效率？
<ul>
<li>根本原理：缩小了检索范围。</li>
</ul>
</li>
</ul>
<blockquote>
<p>索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也行需要数据库不断的维护。</p>
<p>比如：表中的数据经常被修改，这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p>
<p>添加索引是给某一字段，或者说某些字段添加索引。</p>
<p>select ename, sal from emp where ename = 'SMITH';</p>
<p>当ename字段上没有添加索引时，以上SQL语句会进行全表扫描，扫描ename字段中所有的值。</p>
<p>当ename字段上添加索引时，以上SQL语句会根据索引扫描，快速定位。</p>
</blockquote>
<h5 id="怎么创建索引对象怎么删除索引">怎么创建索引对象？怎么删除索引？</h5>
<ul>
<li>
<p><em>create index 索引名称 on 表名(字段名);</em></p>
</li>
<li>
<p><em>drop index 索引名称 on 表名</em></p>
</li>
<li>
<p>什么时候考虑给字段添加索引?（满足什么条件）</p>
<ul>
<li>数据量庞大（根据客户需求，根据线上环境）</li>
<li>字段很少使用DML操作 （字段修改，索引也需维护）</li>
<li>该字段经常出现在where子句中（经常查询）</li>
</ul>
</li>
<li>
<p>注意：主键和具有unique约束的字段会自动添加索引。</p>
<ul>
<li>根据主键查询效率较高，尽量根据主键检索。</li>
</ul>
</li>
</ul>
<h5 id="查看sql语句的执行计划">查看SQL语句的执行计划</h5>
<pre><code>// type = ALL  表示全表扫描
// rows = 14   表示扫描了14条记录
mysql&gt; explain select ename,sal from emp where sal=5000;
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.04 sec)

// 给薪资添加索引
create index emp_sal_index on emp(sal);


// 添加索引后， rows = 1 只扫描一条记录
mysql&gt; explain select ename,sal from emp where sal=5000;
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
1 row in set (0.04 sec)
</code></pre>
<h5 id="索引原理">索引原理</h5>
<ul>
<li>索引底层数据结构采用的 ：B + Tree</li>
</ul>
<p>通过B Tree缩小扫描范围，底层索引进行了排序、分区、索引会携带数据在表中的“物理地址”</p>
<p>最终通过索引检查到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。</p>
<p><strong>select ename from emp where ename = 'SMITH';</strong></p>
<p>通过索引转化为</p>
<p><strong>select ename from emp where 物理地址 = 0x3;</strong></p>
<h5 id="索引的分类">索引的分类？</h5>
<ol>
<li>单一索引：给单个字段添加索引</li>
<li>复合索引：给多个字段联合起来添加一个索引</li>
<li>主键索引：主键上会自动添加索引</li>
<li>唯一索引：有unique约束的字段上会自动添加索引</li>
<li>......</li>
</ol>
<h5 id=""></h5>
<h5 id="索引什么时候失效">索引什么时候失效？</h5>
<p><strong>select ename from emp where ename like '%A%';</strong></p>
<p>模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p>
<h3 id="视图-view"><em>视图 view</em></h3>
<h4 id="什么是视图">什么是视图？</h4>
<ul>
<li>站在不同角度去看到数据。（同一张表的数据，通过不同角度去看待）</li>
</ul>
<h4 id="怎么创建视图怎么删除视图">怎么创建视图？怎么删除视图？</h4>
<p><strong>create view myview as select empno, ename from emp;</strong></p>
<p><strong>drop view myview;</strong></p>
<p><em>注意：只有DQL语句才能以视图对象的方式创建出来。</em></p>
<p><strong>对视图进行增删改查，会影响到原表数据</strong>（通过视图会影响原表数据，不是直接操作的原表）</p>
<p><strong>可以对视图进行CRUD操作</strong></p>
<pre><code>// 复制创建表
create table emp_bak as select * from emp;

// 创建视图
create view myview as select empno,ename,sal from emp_bak;

// 通过视图修改原表数据
 update myview set ename='hehe',sal='999' where empno = 7369;
 delete from myview where empno=7369;
</code></pre>
<h4 id="视图的作用">视图的作用？</h4>
<p><strong>视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。</strong></p>
<p><em>视图并不会提高检索效率</em></p>
<h3 id="dba-命令了解"><em>DBA 命令</em>（了解）</h3>
<h4 id="数据导出">数据导出</h4>
<ul>
<li>在Windows的dos命令窗口中执行: （导出整个库）
<ul>
<li>mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -prootchan</li>
</ul>
</li>
<li>在Windows的dos命令窗口中执行: （指定导出指定数据库当中的指定表）
<ul>
<li>mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -prootchan</li>
</ul>
</li>
</ul>
<h4 id="数据导入">数据导入</h4>
<ul>
<li>create database bjpowernode;</li>
<li>use bjpowernode;</li>
<li>source D:\bjpowernode.sql;</li>
</ul>
<h3 id="数据库设计三范式"><em>数据库设计三范式</em></h3>
<p><strong>设计表的依据，按照三范式设计的表不会出现数据冗余。</strong></p>
<ul>
<li>
<p>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</p>
</li>
<li>
<p>第二范式：建立在第一范式的基础之上，所有非主键字段都完全依赖主键，不能产生部分依赖（<strong>严格意义上说：尽量不要使用联合主键</strong>）</p>
<p><strong>多对多？三张表，关系表，两个外键。</strong></p>
<blockquote>
<p>学生编号(PK) 	教师编号(PK) 	学生姓名 	教师姓名</p>
<p>1001 					001 						张三 			王老师</p>
<p>1002 					002 						李四 			赵老师</p>
<p>1003 					001 						王五 			王老师</p>
<p>1001 					002 						张三 			赵老师</p>
<p>综合分析：</p>
<p>1、以上虽然确定了主键，但此表会出现大量冗余，主要涉及到的冗余字段为“学生姓名”和 “教师姓名”；</p>
<p>2、出现冗余的原因在于：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号， 而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。</p>
</blockquote>
<pre><code>解决方案如下：
t_student学生表
sno(pk)			sname
---------------------------------
1				张三
2				李四
3				王五

t_teacher教师表
tno(pk) 		tname
---------------------------------
1				王老师 
2				张老师
3				李老师 

t_student_teacher_relation 学生教师关系表
id(pk)		sno(fk)		tno(fk)
-----------------------------------------------
1			 1			 3
2			 1			 2
3			 2			 2
4			 3			 1	
5			 3			 1
6			 2	          3
</code></pre>
</li>
<li>
<p>第三范式：建立在第二范式基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</p>
<p><strong>一对多？两张表，多的表加外键。</strong></p>
<pre><code>示例一：学生信息表
学生编号（PK） 学生姓名 	班级编号	   班级名称
---------------------------------------------------
1001 			张三 		01 			一年一班
1002 			李四		02 			一年二班
1003 			王五 		03 			一年三班
1004 			赵六 		03 			一年三班
----------------------------------------------------
综合分析：
1、从表中看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键
2、班级名称字段依赖于班级编号，班级编号依赖亍学生编号，那么这就是传递依赖
解决方案：
1、将冗余字段单独拿出来建立表
2、如下表所示：学生信息表中班级编号设为外键FK

t_class 班级表
班级编号（PK） 	班级名称
--------------------------
01 				一年一班
02 				一年二班
03 				一年三班
--------------------------

t_student 学生表
学生编号（PK） 学生姓名 	班级编号（FK）
---------------------------------------
1001 			张三 		01
1002 			李四 		02
1003 			王五 		03
1004 			赵六 		03
---------------------------------------
</code></pre>
</li>
</ul>
<blockquote>
<p>提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</p>
</blockquote>
<h4 id="一对一表设计">一对一表设计</h4>
<ul>
<li>两种方案：主键共享、外键唯一</li>
</ul>
<pre><code>一对一设计方案：主键共享
t_user_login 用户登录表
id(pk)		username		password
------------------------------------
1		 	zs				123123
2		 	ls				123122

t_user_detail 用户详细信息表
id(pk+fk)		realname		tel			...
-------------------------------------------
1				张三			 15844562141
2				李四			 17584756721
--------------------------------------------


一对一设计方案：外键唯一
t_user_login 用户登录表
id(pk)		username		password
------------------------------------
1		 	zs				123123
2		 	ls				123122

t_user_detail 用户详细信息表
id(pk+fk)		realname		tel			 	userid(fk+unique)
----------------------------------------------------------------------
1				张三			 15844562141		 2
2				李四			 17584756721		 1
----------------------------------------------------------------------


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL三部曲之渐入佳境]]></title>
        <id>https://geckoc.github.io/post/mysql-san-bu-qu-zhi-jian-ru-jia-jing/</id>
        <link href="https://geckoc.github.io/post/mysql-san-bu-qu-zhi-jian-ru-jia-jing/">
        </link>
        <updated>2020-08-16T03:03:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="连接查询"><em>连接查询</em></h3>
<ul>
<li>
<p>什么是连接查询</p>
<ul>
<li>在实际开发中，大部分的情况都不是从单表中查询数据，一般是多张表联合查询取出最终结果。</li>
<li>实际开发中，一般一个业务会对应多张表，如学生和班级，起码两张表。</li>
</ul>
<pre><code>stuno    stuname		classno			classname
------------------------------------------------------------
1		 张三				1				深圳中学高三1班
2		 李四				1				深圳中学高三1班
</code></pre>
<ul>
<li>学生和班级信息存储到一张表中，数据会存在大量的重复，导致数据冗余。</li>
</ul>
</li>
</ul>
<h4 id="连接查询的分类">连接查询的分类？</h4>
<ul>
<li>根据语法出现的年代划分，包括
<ul>
<li>SQL92 （一些老的DBA可能还在用这种语法。DBA ：Database Administrator 数据库管理员）</li>
<li>SQL99 （比较新的语法）</li>
</ul>
</li>
<li>根据表的连接方式划分，包括
<ul>
<li>内连接
<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li>外连接
<ul>
<li>左外连接（左连接）</li>
<li>右外连接（右连接）</li>
</ul>
</li>
<li>全连接（很少用，略！）</li>
</ul>
</li>
</ul>
<h5 id="笛卡尔积现象">笛卡尔积现象</h5>
<ul>
<li>
<p>在表的连接查询方面有一种现象被称为：笛卡尔积现象（笛卡尔乘积现象）</p>
</li>
<li>
<p>笛卡尔积现象：当两张表进行连接查询时候，没有任何条件限制，最终的查询结果条数是两张表记录条数的乘积。</p>
<ul>
<li>案例：找出每一个员工的部门名称，要求显示员工名和部门名。</li>
</ul>
<pre><code>mysql&gt; select ename,dname from emp,dept;
+--------+------------+
| ename  | dname      |
+--------+------------+
| SMITH  | ACCOUNTING |
| SMITH  | RESEARCH   |
| SMITH  | SALES      |
| SMITH  | OPERATIONS |
| ALLEN  | ACCOUNTING |
| ALLEN  | RESEARCH   |
| ALLEN  | SALES      |
| ALLEN  | OPERATIONS |
......
56 rows in set (0.00 sec)
</code></pre>
</li>
</ul>
<ul>
<li>
<p>关于表的别名</p>
<ul>
<li>表别名的好处？
<ol>
<li>执行效率高</li>
<li>可读性好</li>
</ol>
</li>
</ul>
<pre><code>mysql&gt; select e.ename, d.dname from emp e, dept d;
</code></pre>
</li>
</ul>
<h5 id="如何避免笛卡尔积现象">如何避免笛卡尔积现象？</h5>
<ul>
<li>
<p>加条件过滤；</p>
<ul>
<li>避免了笛卡尔积现象，会减少记录的匹配次数吗？</li>
<li>不会！次数还是56次，只不过显示的是有效记录。</li>
</ul>
</li>
<li>
<p>案例：找出每一个员工的部门名称，要求显示员工名和部门名。</p>
<pre><code>mysql&gt; select e.ename, d.dname from emp e , dept d
    -&gt; where e.deptno = d.deptno;	// SQL92，老语法，以后不用
        +--------+------------+
        | ename  | dname      |
        +--------+------------+
        | CLARK  | ACCOUNTING |
        | KING   | ACCOUNTING |
        | MILLER | ACCOUNTING |
        | SMITH  | RESEARCH   |
        | JONES  | RESEARCH   |
        | SCOTT  | RESEARCH   |
        | ADAMS  | RESEARCH   |
        | FORD   | RESEARCH   |
        | ALLEN  | SALES      |
        | WARD   | SALES      |
        | MARTIN | SALES      |
        | BLAKE  | SALES      |
        | TURNER | SALES      |
        | JAMES  | SALES      |
        +--------+------------+
        14 rows in set (0.09 sec)
</code></pre>
</li>
</ul>
<h5 id="内连接之等值连接">内连接之等值连接</h5>
<ul>
<li>
<p>最大的特点是：条件是等量关系。</p>
<ul>
<li>案例：找出每一个员工的部门名称，要求显示员工名和部门名。</li>
</ul>
<pre><code>mysql&gt; select e.ename, d.dname from emp e , dept d
    -&gt; where e.deptno = d.deptno;	// SQL 92，老语法，以后不用
(SQL 99)  常用的
mysql&gt; select e.ename, d.dname from emp e
    -&gt; join dept d
    -&gt; on d.deptno = e.deptno;
//内连接中的 inner 可以省略，带着 inner 目的是可读性好一些
mysql&gt; select e.ename, d.dname from emp e
    -&gt; inner join dept d
    -&gt; on d.deptno = e.deptno;
    语法格式：
    ... A join B on 连接条件 where...  //还可加 where 过滤
    
</code></pre>
<ul>
<li>SQL99的语法更加清晰一些，表的连接条件和where条件分离了</li>
</ul>
</li>
</ul>
<h5 id="内连接之非等值连接">内连接之非等值连接</h5>
<ul>
<li>
<p>最大的特点是：连接条件中的关系是非等量关系。</p>
<ul>
<li>案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级。</li>
</ul>
<pre><code>// inner 可以省略
mysql&gt; select e.ename, e.sal , s.grade from emp e
    -&gt; join salgrade s on e.sal between s.losal and s.hisal;
+--------+---------+-------+
| ename  | sal     | grade |
+--------+---------+-------+
| SMITH  |  800.00 |     1 |
| ALLEN  | 1600.00 |     3 |
| WARD   | 1250.00 |     2 |
| JONES  | 2975.00 |     4 |
| MARTIN | 1250.00 |     2 |
| BLAKE  | 2850.00 |     4 |
| CLARK  | 2450.00 |     4 |
| SCOTT  | 3000.00 |     4 |
| KING   | 5000.00 |     5 |
| TURNER | 1500.00 |     3 |
| ADAMS  | 1100.00 |     1 |
| JAMES  |  950.00 |     1 |
| FORD   | 3000.00 |     4 |
| MILLER | 1300.00 |     2 |
+--------+---------+-------+
14 rows in set (0.00 sec)
</code></pre>
</li>
</ul>
<h5 id="自连接">自连接</h5>
<ul>
<li>
<p>最大的特点是：一张表看做两张表，自己连接自己。</p>
<ul>
<li>案例：找出每个员工的上级领导，要求显示员工名和对应的领导名字。</li>
</ul>
<pre><code>mysql&gt; select a.ename as '员工', b.ename as '领导' 
    -&gt; from emp a
    -&gt; join emp b
    -&gt; on a.mgr = b.empno;
    (员工的领导编号 = 领导的员工编号)
+--------+-------+
| 员工   | 领导  |
+--------+-------+
| SMITH  | FORD  |
| ALLEN  | BLAKE |
| WARD   | BLAKE |
| JONES  | KING  |
| MARTIN | BLAKE |
| BLAKE  | KING  |
| CLARK  | KING  |
| SCOTT  | JONES |
| TURNER | BLAKE |
| ADAMS  | SCOTT |
| JAMES  | BLAKE |
| FORD   | JONES |
| MILLER | CLARK |
+--------+-------+
13 rows in set (0.06 sec)
</code></pre>
</li>
</ul>
<h5 id="外连接">外连接</h5>
<ul>
<li>
<p>什么是外连接？和内连接有什么区别？</p>
<ul>
<li>
<p>内连接：假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。</p>
</li>
<li>
<p>A表和B表没有主副之分，两张表是平等的。</p>
</li>
</ul>
<hr>
<ul>
<li>外连接：假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张是副表，主要查询主表 中的数据，连带着查询副表，当副表中的数据没有和主表的数据匹配上，副表自动模拟出null与之匹配。</li>
</ul>
</li>
</ul>
<h5 id="外连接的分类">外连接的分类</h5>
<ul>
<li>
<p>左外连接：（左连接）：表示左边的这张表是主表</p>
</li>
<li>
<p>右外连接：（右连接）：表示右边的这张表是主表</p>
</li>
<li>
<p>左连接有右连接的写法，右连接也会有对应的左连接的写法。</p>
</li>
<li>
<p>全连接，省</p>
<pre><code>内连接：
mysql&gt; select a.ename as '员工', b.ename as '领导' 
    -&gt; from emp a
    -&gt; join emp b
    -&gt; on a.mgr = b.empno;
    (员工的领导编号 = 领导的员工编号)
外连接: （左边表是主表，此时king也显示出来，模拟出null） left / right 
outer 可以省略
mysql&gt;select a.ename as '员工', b.ename as '领导' 
    -&gt; from emp a
    -&gt; left outer join emp b
    -&gt; on a.mgr = b.empno;
    +--------+-------+
    | ename  | ename |
    +--------+-------+
    | SMITH  | FORD  |
    | ALLEN  | BLAKE |
    | WARD   | BLAKE |
    | JONES  | KING  |
    | MARTIN | BLAKE |
    | BLAKE  | KING  |
    | CLARK  | KING  |
    | SCOTT  | JONES |
    | KING   | NULL  |
    | TURNER | BLAKE |
    | ADAMS  | SCOTT |
    | JAMES  | BLAKE |
    | FORD   | JONES |
    | MILLER | CLARK |
    +--------+-------+
14 rows in set (0.00 sec)	
</code></pre>
</li>
<li>
<p>案例：找出没有员工的部门</p>
<pre><code>mysql&gt; select d.* from emp e
    -&gt; right outer join
    -&gt; dept d
    -&gt; on e.deptno = d.deptno
    -&gt; where e.deptno is null;
+--------+------------+--------+
| DEPTNO | DNAME      | LOC    |
+--------+------------+--------+
|     40 | OPERATIONS | BOSTON |
+--------+------------+--------+
1 row in set (0.04 sec)
</code></pre>
</li>
</ul>
<h4 id="三张表连接">三张表连接</h4>
<ul>
<li>
<p>案例：找出每一个员工的部门名称以及工资等级。</p>
<pre><code>表示A表和B表现进行表连接，连接之后A表继续和C表进行连接。
mysql&gt; select e.ename, d.dname, e.sal, s.grade
    -&gt; from emp e
    -&gt; join dept d
    -&gt; on d.deptno = e.deptno
    -&gt; join salgrade s
    -&gt; on e.sal between s.losal and s.hisal;
+--------+------------+---------+-------+
| ename  | dname      | sal     | grade |
+--------+------------+---------+-------+
| SMITH  | RESEARCH   |  800.00 |     1 |
| ALLEN  | SALES      | 1600.00 |     3 |
| WARD   | SALES      | 1250.00 |     2 |
| JONES  | RESEARCH   | 2975.00 |     4 |
| MARTIN | SALES      | 1250.00 |     2 |
| BLAKE  | SALES      | 2850.00 |     4 |
| CLARK  | ACCOUNTING | 2450.00 |     4 |
| SCOTT  | RESEARCH   | 3000.00 |     4 |
| KING   | ACCOUNTING | 5000.00 |     5 |
| TURNER | SALES      | 1500.00 |     3 |
| ADAMS  | RESEARCH   | 1100.00 |     1 |
| JAMES  | SALES      |  950.00 |     1 |
| FORD   | RESEARCH   | 3000.00 |     4 |
| MILLER | ACCOUNTING | 1300.00 |     2 |
+--------+------------+---------+-------+
14 rows in set (0.00 sec)

</code></pre>
</li>
<li>
<p>案例：找出每一个员工的部门名称以及工资等级、以及上级领导。</p>
<pre><code>select e.ename '员工' , d.dname '部门名称',e.sal '工资',s.grade '工资等级', g.ename '领导'
from emp e
join dept d
on e.deptno = d.deptno
join salgrade s
on e.sal between losal and hisal
left join emp g			
on e.mgr = g.empno;  
// 员工的领导编号=领导的员工编号(左外连接，自连接)
</code></pre>
</li>
</ul>
<h3 id="子查询"><em>子查询</em></h3>
<ul>
<li>
<p>什么是子查询？子查询都可以出现在哪里？</p>
<ul>
<li>select语句当中嵌套select语句，被嵌套的select语句是子查询。</li>
<li>子查询出现在哪里？</li>
</ul>
<pre><code>select ...(select)  from ... (select)  where... (select)
</code></pre>
</li>
</ul>
<h4 id="where-子句中使用子查询">where 子句中使用子查询</h4>
<pre><code>找出高于平均工资的员工信息
mysql&gt; select * from emp where sal &gt; (select avg(sal) from emp);
</code></pre>
<h4 id="from后面嵌套查询">from后面嵌套查询</h4>
<ul>
<li>from后面跟的是表，嵌套查询的结果被当成一个表</li>
</ul>
<pre><code>找出每个部门平均薪水的薪资等级
第一步找出部门平均工作
mysql&gt; select deptno,avg(sal) from emp group by deptno;	//每个部门平均薪水
+--------+-------------+
| deptno | avg(sal)    |
+--------+-------------+
|     10 | 2916.666667 |
|     20 | 2175.000000 |
|     30 | 1566.666667 |
+--------+-------------+
3 rows in set (0.00 sec)
将以上查询结果当做一个临时表t，让t表和salgrade s 表做连接，条件是：on t.avgsal between s.losal and s.hisal;
-------------------------------------------------------------------
select t.*, s.grade
from (select deptno, avg(sal) as avgsal from emp group by deptno) t
join salgrade s
on t.avgsal between s.losal and s.hisal;
--------------------------------------------------------------------
+--------+-------------+-------+
| deptno | avgsal      | grade |
+--------+-------------+-------+
|     10 | 2916.666667 |     4 |
|     20 | 2175.000000 |     4 |
|     30 | 1566.666667 |     3 |
+--------+-------------+-------+
3 rows in set (0.00 sec)
</code></pre>
<pre><code>找出每个部门平均的薪水等级。
第一步: 找出每个员工的薪水等级。
mysql&gt; select e.deptno, e.ename, e.sal, s.grade
    -&gt; from emp e
    -&gt; join salgrade s
    -&gt; on e.sal between s.losal and hisal;
    +--------+--------+---------+-------+
    | deptno | ename  | sal     | grade |
    +--------+--------+---------+-------+
    |     20 | SMITH  |  800.00 |     1 |
    |     30 | ALLEN  | 1600.00 |     3 |
    |     30 | WARD   | 1250.00 |     2 |
    |     20 | JONES  | 2975.00 |     4 |
    |     30 | MARTIN | 1250.00 |     2 |
    |     30 | BLAKE  | 2850.00 |     4 |
    |     10 | CLARK  | 2450.00 |     4 |
    |     20 | SCOTT  | 3000.00 |     4 |
    |     10 | KING   | 5000.00 |     5 |
    |     30 | TURNER | 1500.00 |     3 |
    |     20 | ADAMS  | 1100.00 |     1 |
    |     30 | JAMES  |  950.00 |     1 |
    |     20 | FORD   | 3000.00 |     4 |
    |     10 | MILLER | 1300.00 |     2 |
    +--------+--------+---------+-------+
    14 rows in set (0.06 sec)
第二步：基于以上结果，继续按照deptno分组，求grade平均值
mysql&gt; select e.deptno , avg(s.grade)
    -&gt; from emp e
    -&gt; join salgrade s
    -&gt; on e.sal between s.losal and hisal
    -&gt; group by e.deptno;
    +--------+--------------+
    | deptno | avg(s.grade) |
    +--------+--------------+
    |     10 |       3.6667 |
    |     20 |       2.8000 |
    |     30 |       2.5000 |
    +--------+--------------+
    3 rows in set (0.00 sec)

</code></pre>
<h4 id="在select后面嵌套子查询">在select后面嵌套子查询</h4>
<ul>
<li>
<p>案例：找出每个员工所在的部门名称，要求显示员工名和部门名。</p>
<pre><code>mysql&gt; select e.ename,d.dname from
    -&gt; emp e
    -&gt; join dept d
    -&gt; on e.deptno = d.deptno;
--------------------------------------------------------------------------
mysql&gt; select e.ename,
    -&gt; (select d.dname from dept d where e.deptno = d.deptno) as dname
    -&gt; from emp e;
</code></pre>
</li>
</ul>
<h3 id="union"><em>union</em></h3>
<ul>
<li>
<p><em><strong>union</strong></em> 可以将查询结果集相加</p>
</li>
<li>
<p>特点：第一个查询的列的数量和第二个查询的列数量要一致</p>
</li>
<li>
<p>可将两张不想干的表中的数据拼接在一起显示</p>
</li>
<li>
<p>案例：找出工作岗位是SALESMAN和MANAGER的员工</p>
<pre><code>第一种：
mysql&gt; select ename,job from emp where job ='salesman' or job = 'manager';
第二种：
mysql&gt; select ename,job from emp where job in('manager','salesman');
第三种：
mysql&gt; select ename,job from emp where job = 'manager'
    -&gt; union
    -&gt; select ename,job from emp where job = 'salesman';
+--------+----------+

可将两张不想干的表中的数据拼接在一起显示
mysql&gt; select ename from emp
    -&gt; union
    -&gt; select dname from dept;
+------------+
| ename      |
+------------+
| SMITH      |
| ALLEN      |
| WARD       |
| JONES      |
| MARTIN     |
| BLAKE      |
| CLARK      |
| SCOTT      |
| KING       |
| TURNER     |
| ADAMS      |
| JAMES      |
| FORD       |
| MILLER     |
| ACCOUNTING |
| RESEARCH   |
| SALES      |
| OPERATIONS |
+------------+
--------------------------------------------------------------

第一个查询的列的数量和第二个查询的列数量要一致，否则报错
mysql&gt; select ename , sal from emp
    -&gt; union
    -&gt; select dname from dept;
ERROR 1222 (21000): The used SELECT statements have a different number of columns

</code></pre>
</li>
</ul>
<h3 id="limit-重点"><em>limit</em> <em>（重点）</em></h3>
<ul>
<li>
<p><em>limit</em>是MySQL特有的，其他数据库没有，不通用（Oracle中有一个相同的机制，叫做 rownum）</p>
</li>
<li>
<p><em>limit</em>取结果集中的部分数据，这是它的作用。</p>
</li>
<li>
<p>语法机制：<em>limit starIndex, length</em></p>
<ul>
<li>starIndex ： 表示起始位置</li>
<li>length ：表示取几个</li>
</ul>
</li>
<li>
<p>案例：取出工资前五名的员工（思路：降序取前五个）</p>
<pre><code>mysql&gt; select ename,sal from emp order by sal desc;
// 取前五个
mysql&gt; select ename,sal from emp order by sal desc limit 0,5;
// 直接写一个数字，前面默认的是0
mysql&gt; select ename,sal from emp order by sal desc limit 5;
</code></pre>
</li>
<li>
<p><em>limit</em> 是SQL语句最后执行的一个环节</p>
<pre><code>执行顺序
select...		5
from...   		1
where...		2
group by...		3
having...		4
order by...		6
limit...;		7
</code></pre>
</li>
<li>
<p>案例：找出工资排名在第4到第9名的员工</p>
<pre><code>mysql&gt; select ename,sal from emp order by sal desc limit 3,6;
    +--------+---------+
    | ename  | sal     |
    +--------+---------+
    | JONES  | 2975.00 |
    | BLAKE  | 2850.00 |
    | CLARK  | 2450.00 |
    | ALLEN  | 1600.00 |
    | TURNER | 1500.00 |
    | MILLER | 1300.00 |
    +--------+---------+
    6 rows in set (0.00 sec)
</code></pre>
</li>
</ul>
<h4 id="通用的标准分页sql">通用的标准分页SQL</h4>
<ul>
<li>
<p>每页显示pageSize条记录</p>
</li>
<li>
<p>第pageNo页：( pageNo - 1 ) * pageSize</p>
<blockquote>
<p>每页显示3条记录</p>
<p>第一页：0，3</p>
<p>第二页：3，3</p>
<p>第三页：6，3</p>
<p>第四页：9，3</p>
<p>第五页：12，3</p>
</blockquote>
</li>
</ul>
<h3 id="dml数据操作语言"><em>DML数据操作语言</em></h3>
<blockquote>
<p>DML（数据操作语言）：insert ， delete ， update 对表当中的数据进行增删改</p>
</blockquote>
<h4 id="create-创建表">create 创建表</h4>
<ul>
<li>
<p>建表语句的语法格式：</p>
<blockquote>
<p>create table 表名 (</p>
<p>​	字段名1 数据类型,</p>
<p>​	字段名2 数据类型,</p>
<p>​	字段名3 数据类型,</p>
<p>​	...</p>
<p>);</p>
</blockquote>
</li>
<li>
<p>关于MySQL当中字段的数据类型？常见的有</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:left">MySQL当中字段的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td style="text-align:left">整数型（java中的int）</td>
</tr>
<tr>
<td>bigint</td>
<td style="text-align:left">长整型（java中的long）</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:left">浮点型（java中的float double）</td>
</tr>
<tr>
<td>char</td>
<td style="text-align:left">定长字符串（String）</td>
</tr>
<tr>
<td>varchar</td>
<td style="text-align:left">可变长字符串（StringBuffer/StringBuilder）</td>
</tr>
<tr>
<td>date</td>
<td style="text-align:left">日期类型（对应java中的java.sql.Date类型）</td>
</tr>
<tr>
<td>BLOB</td>
<td style="text-align:left">二进制大对象（存储图片、视频等流媒体信息）Binary Large OBject ---&gt; java中的Object</td>
</tr>
<tr>
<td>CLOB</td>
<td style="text-align:left">字符大对象（存储较大的文本，可存储4G的字符串）Character Large OBject ---&gt; java中的Object</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>varchar和char如何选择使用？</p>
<ul>
<li>字段中的数据不发生改变时，是定长的；例如：性别、生日等等用char</li>
<li>字段中的数据长度不确定时，例如：简介、姓名等等都是用varchar</li>
</ul>
<pre><code>建表：学生表---&gt; 学号 姓名 性别 班级编号 生日
create table t_student(
	num bigint,
	name varchar(255),
	sex char(1),
	classnum varchar(255),
	birth char(10)
);
</code></pre>
</li>
</ul>
<h4 id="insert-插入数据">insert 插入数据</h4>
<ul>
<li>
<p>insert 语句插入数据</p>
<ul>
<li>语法格式
<ul>
<li>insert into 表名(字段名1，字段名2，字段名3，... ) values (值1，值2，值3，...)</li>
<li>要求：字段的数量和值的数量相同，并且数据类型要对应相同。</li>
</ul>
</li>
</ul>
<pre><code>insert into t_student (num,name,sex,classnum,birth) values (1,'Richard','M','1105','1999-10-02');
insert into t_student (num,name,sex,classnum,birth) values (2,'Gilfoyle','M','1105','2000-08-24');
//字段名可以调换，但后面value值要对应上
insert into t_student (name,sex,classnum) values ('Monica','F','1101');

//其他字段值若没有，会默认为Null，插入数据后，只能使用update进行更新
insert into t_student(name) value ('Richard'); 

//字段可以省略不写，但是后面的value对数量和顺序都需要相对应(谨慎)
insert into t_student values(1,'Jack','M','1102','1997-03-22');

//一次插入多行数据
insert into t_student (num,name,sex,classnum,birth) 
values (3,'Kobe','M','1108','1996-10-01'),(6,'Jordan','M','1001','1980-06-08');

</code></pre>
</li>
<li>
<p>表的复制</p>
<ul>
<li>语法： create table 表名 as select语句</li>
<li>将查询结果当做表创建出来</li>
</ul>
</li>
<li>
<p>将查询结果插入到一张表中</p>
<ul>
<li>语法：insert into 表名 select * from dept;</li>
</ul>
<pre><code>insert into dept1 select * from dept;
select * from dept1;
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
</code></pre>
</li>
</ul>
<h4 id="update-修改数据">update 修改数据</h4>
<ul>
<li>
<p>语法格式：update 表名 set 字段名1=值1,字段名2=值2... where 条件；</p>
</li>
<li>
<p><em>注意：</em> 没有条件整张表数据全部更新；</p>
<ul>
<li>将部门10的LOC修改为SHANGHAI，将部门名称修改为RENSHUBU。</li>
</ul>
</li>
</ul>
<pre><code>    mysql&gt; update dept1 set loc='SHANGHAI',dname='RENSHIBU'
        -&gt; where deptno = 10;
    Query OK, 2 rows affected (0.17 sec)
    Rows matched: 2  Changed: 2  Warnings: 0
    
    mysql&gt; select * from dept1;
    +--------+------------+----------+
    | DEPTNO | DNAME      | LOC      |
    +--------+------------+----------+
    |     10 | RENSHIBU   | SHANGHAI |
    |     20 | RESEARCH   | DALLAS   |
    |     30 | SALES      | CHICAGO  |
    |     40 | OPERATIONS | BOSTON   |
    |     10 | RENSHIBU   | SHANGHAI |
    |     20 | RESEARCH   | DALLAS   |
    |     30 | SALES      | CHICAGO  |
    |     40 | OPERATIONS | BOSTON   |
    +--------+------------+----------+
    8 rows in set (0.00 sec)
    
    更新所有数据 (不加过滤条件)
    update dept1 set loc='x',dname='y';
        mysql&gt; select * from dept1;
        +--------+-------+------+
        | DEPTNO | DNAME | LOC  |
        +--------+-------+------+
        |     10 | y     | x    |
        |     20 | y     | x    |
        |     30 | y     | x    |
        |     40 | y     | x    |
        |     10 | y     | x    |
        |     20 | y     | x    |
        |     30 | y     | x    |
        |     40 | y     | x    |
        +--------+-------+------+
        8 rows in set (0.00 sec)
    
</code></pre>
<h4 id="delete-删除数据">delete 删除数据</h4>
<ul>
<li>
<p>语法格式：delete from 表名 where 条件;</p>
</li>
<li>
<p>*注意：*没有条件全部删除</p>
<ul>
<li>删除10部门所有数据？</li>
</ul>
</li>
</ul>
<pre><code>    delete from dept1 where deptno = 10;
    
    //删除所有记录
    delete from dept1 ;
    
    //怎么删除大表中的数据？（重点）
    truncate table emp1;    //表被截断，不可回滚。永久丢失
    
    //删除表
    drop table 表名; //通用
    drop table if exists 表名; //Oracle不支持这种写法
</code></pre>
<ul>
<li>
<p><em>对于表结构的修改，使用工具完成即可，因为实际开发中表一旦涉及好之后，对表结构的修改是很少的</em></p>
</li>
<li>
<p>增删改查有一个术语：<em><strong>CRUD</strong></em></p>
<ul>
<li><em>Create</em>（增）<em>Retrieve</em>（检索）<em>Update</em>（修改）<em>Delete</em>（删除）</li>
</ul>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL三部曲之初见端倪]]></title>
        <id>https://geckoc.github.io/post/mysql-san-bu-qu-zhi-chu-jian-duan-ni/</id>
        <link href="https://geckoc.github.io/post/mysql-san-bu-qu-zhi-chu-jian-duan-ni/">
        </link>
        <updated>2020-08-14T17:20:40.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>sql、DB、DBMS分别是什么，他们之间的关系？</p>
<ul>
<li>
<p>DB：DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）</p>
</li>
<li>
<p>DBMS：DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer...）</p>
</li>
<li>
<p>SQL：结构化查询语言，是一门标准通用的语言，标准的sql适合于所有数据库产品。<br>
SQL属于高级语言，只要能看懂英语单词，写出来的sql语句，可以读懂什么意思。<br>
SQL语句在执行的时候，实际上内部也会先进行编译，然后再试下SQL（SQL语句的编译由DBMS完成）</p>
</li>
<li>
<p>DBMS负责执行SQL语句，通过执行SQL语句来操作DB当中的数据。</p>
</li>
<li>
<p>DBMS--&gt;(执行)-&gt; SQl(操作)-&gt; DB</p>
</li>
</ul>
</li>
<li>
<p>什么是表？</p>
</li>
</ol>
<ul>
<li>
<p>table是数据库当中的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。</p>
</li>
<li>
<p>一个表包括行和列<br>
行：被称为数据（data）<br>
列：被称为字段（column）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>学号(int)</th>
<th>姓名(varchar)</th>
<th>年龄(int)</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>张三</td>
<td>18</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>24</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>16</td>
</tr>
</tbody>
</table>
<ul>
<li>每一个字段应该包括哪些属性？</li>
</ul>
<ul>
<li>字段名、数据类型、相关的约束</li>
</ul>
<ol start="3">
<li>
<p>学习MySQL主要还是学习通用的SQL语句，SQL语句包括增删改查，SQL语句是如何分类的？</p>
<ul>
<li>DQL（数据查询语言）： 查询语句，凡是select语句都是DQL。</li>
<li>DML（数据操作语言）：insert ， delete ， update 对表当中的数据进行增删改。</li>
<li>DDL（数据定义语言）：create，drop ，alter  对表结构的增删改。</li>
<li>TCL（事务控制语言）：commit提交事务，rollback回滚事务、（TCL中的T是Transaction）</li>
<li>DCL（数据控制语言）：grant授权、revoke撤销权限等。</li>
</ul>
</li>
<li>
<p>导入数据（后期练习时使用）</p>
<ul>
<li>
<p>第一步：登录MySQL数据库 root</p>
</li>
<li>
<p>第二步：查看有哪些数据库</p>
<ul>
<li>
<p><em>show database</em>（这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</p>
<pre><code>mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
</code></pre>
</li>
</ul>
</li>
<li>
<p>第三步：创建属于自己的数据库</p>
<ul>
<li><em>create database bjpowernode</em>; （这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</li>
</ul>
</li>
<li>
<p>第四步：使用***bjpowernode***数据库</p>
<ul>
<li><em>use bjpowernode</em>;（这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</li>
</ul>
</li>
<li>
<p>第五步：查看数据库中有哪些表？</p>
<ul>
<li><em>show tables</em>;（这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</li>
</ul>
</li>
<li>
<p>第六步：初始化数据</p>
<ul>
<li><em>mysql&gt; source</em> ( <filename> | source <filename>) ---&gt; 文件路径</li>
<li><em>mysql&gt; source</em></li>
<li>注意：数据初始化完成之后，有三张表</li>
</ul>
<pre><code>mysql&gt; show tables;
+-----------------------+
| Tables_in_bjpowernode |
+-----------------------+
| dept                  |
| emp                   |
| salgrade              |
+-----------------------+
</code></pre>
</li>
</ul>
</li>
<li>
<p><em>bjpowernode.sql</em>,这个文件以<strong>sql</strong>结尾，这样的文件被称为&quot;sql脚本&quot;。什么是sql脚本？</p>
<ul>
<li>当一个文件的扩展名是&quot;.sql&quot;，并且该文件中编写了大量的sql语句，这样的文件叫SQL脚本。</li>
<li>注意：直接使用source命令可以执行SQL脚本。</li>
<li>SQL脚本中的数据量太大时无法打开，请使用source命令完成初始化。</li>
</ul>
</li>
<li>
<p>删除数据库：drop database bjpowernode;</p>
</li>
<li>
<p>查看表结构</p>
<pre><code>mysql&gt; show tables;
+-----------------------+
| Tables_in_bjpowernode |
+-----------------------+
| dept                  |	(部门表)
| emp                   |	(员工表)
| salgrade              |	(工资登记表)
+-----------------------+
</code></pre>
<pre><code>mysql&gt; desc dept;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| DEPTNO | int(2)      | NO   | PRI | NULL    |       |	部门编号
| DNAME  | varchar(14) | YES  |     | NULL    |       |	部门名称
| LOC    | varchar(13) | YES  |     | NULL    |       |	部门位置
+--------+-------------+------+-----+---------+-------+

mysql&gt; desc emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| EMPNO    | int(4)      | NO   | PRI | NULL    |       |	员工编号
| ENAME    | varchar(10) | YES  |     | NULL    |       |	员工姓名
| JOB      | varchar(9)  | YES  |     | NULL    |       |	工作岗位
| MGR      | int(4)      | YES  |     | NULL    |       |	上级领导编号
| HIREDATE | date        | YES  |     | NULL    |       |	入职日期
| SAL      | double(7,2) | YES  |     | NULL    |       |	月薪
| COMM     | double(7,2) | YES  |     | NULL    |       |	补助/津贴
| DEPTNO   | int(2)      | YES  |     | NULL    |       |	部门编号
+----------+-------------+------+-----+---------+-------+

mysql&gt; desc salgrade;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| GRADE | int(11) | YES  |     | NULL    |       |	等级
| LOSAL | int(11) | YES  |     | NULL    |       |	最低薪资
| HISAL | int(11) | YES  |     | NULL    |       |	最高薪资
+-------+---------+------+-----+---------+-------+
</code></pre>
</li>
<li>
<p>表中的数据</p>
<pre><code>mysql&gt; select * from dept;
mysql&gt; select * from emp;
mysql&gt; select * from salgrade;
</code></pre>
</li>
<li>
<p>MySQL常用命令？</p>
<pre><code>select database();	查看当前正在使用的数据库
select version();	查看mysql的版本号
\c	命令，结束一条语句
exit	命令，退出MySQL
</code></pre>
</li>
<li>
<p>查看创建表的语句</p>
</li>
</ol>
<pre><code>   mysql&gt; show create table emp;
   +-------+-------------------------------
   | Table | Create Table
   +-------+-------------------------------
   | emp   | CREATE TABLE `emp` (
     `EMPNO` int(4) NOT NULL,
     `ENAME` varchar(10) DEFAULT NULL,
     `JOB` varchar(9) DEFAULT NULL,
     `MGR` int(4) DEFAULT NULL,
     `HIREDATE` date DEFAULT NULL,
     `SAL` double(7,2) DEFAULT NULL,
     `COMM` double(7,2) DEFAULT NULL,
     `DEPTNO` int(2) DEFAULT NULL,
     PRIMARY KEY (`EMPNO`)
   ) ENGINE=InnoDB DEFAULT CHARSET=latin1 |
   +-------+-------------------------------
</code></pre>
<h4 id="简单的查询dql数据查询">简单的查询（DQL数据查询）</h4>
<ul>
<li>语法格式：select 字段名1, 字段名2, 字段名3,... form 表名;</li>
<li>任何一条SQL语句以&quot;;&quot;结尾。</li>
<li>SQL与极具不区分大小写</li>
<li>注意：标准SQL语句中要求字符串使用单引号括起来，虽然MySQL支持双引号，尽量别用。</li>
</ul>
<pre><code>   查询员工的年薪
   mysql&gt; select ename,empno,sal * 12 from emp; (字段可以参与数学运算)
   mysql&gt; select ename,empno,sal * 12 as yearsal from emp;（给查询结果的列重命名 ‘as’ 关键字）
   mysql&gt; select ename,empno,sal * 12 yearsal from emp;（‘as’ 关键字可以省略）
   mysql&gt; select ename,empno,sal * 12 as '年薪' from emp; （别名中有中文，单引号括起来）
   mysql&gt; select * from emp; （查询全部字段）
   实际开发中不建议使用 * ，效率较低。
</code></pre>
<h4 id="条件查询">条件查询</h4>
<ul>
<li>语法格式：select 字段，字段... from 表名 where 条件；执行顺序： from --&gt; where --&gt; select</li>
<li>between..and..在使用时必须左小右大</li>
<li>between..and..也可以使用在字符串方面</li>
</ul>
<pre><code>    mysql&gt; select ename,sal from emp where sal = 3000; （查询薪资等于3000的员工）
    mysql&gt; select ename,sal from emp where sal &lt;&gt; 3000; （不等于3000，也可以用 != ）
    mysql&gt; select ename,sal from emp where ename = 'smith'; （查询员工姓名为Smith的工资）
    mysql&gt; select ename,sal from emp where sal &gt;= 1500 and sal &lt;= 5000;(1500~5000薪资的员工)
    mysql&gt; select ename,sal from emp where sal between 100 and 3100;（between...and...是闭区间）
    between..and..在使用时必须左小右大
    mysql&gt; select ename from emp where ename between 'A' and 'D'; （左闭右开）
</code></pre>
<h4 id="is-null-is-not-null-and-or-innot-in-like"><em><strong>is null (is not null) ,  and , or , in，not in , like</strong></em></h4>
<ul>
<li>在数据库当中null不是一个值，代表什么也没有，为空。</li>
<li>空不是一个值，不能用等号衡量。</li>
<li>必须使用 is null 或者 is not null</li>
<li>注意：当运算符的优先级不确定的时候加小括号。</li>
</ul>
<pre><code>mysql&gt; select ename,sal,comm from emp where comm is null or comm = 0;(找出无津贴员工)
    mysql&gt; select ename,sal,comm from emp where comm is not null;（找出有津贴员工）

(找出工作岗位是salasman和manager的员工)
mysql&gt; select ename,job,hiredate from emp where job='salesman' or job ='manager';
（and和or联合起来使用：找出薪资大于1000的并且部门编号是20或者30部门的员工）
mysql&gt; select ename,sal,deptno from emp where sal &gt; 1000 and deptno = 20 or deptno =30; //错误
mysql&gt; select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno =30); // 正确
</code></pre>
<ul>
<li><strong>in</strong> 等同于 <strong>or</strong>，找出工作岗位是salasman和manager的员工(in后面的值不是区间，是具体的值)</li>
</ul>
<pre><code>mysql&gt; select ename,job,hiredate from emp where job='salesman' or job ='manager';
mysql&gt; select ename,sal,job from emp where job in ('salesman','manager');
mysql&gt; select ename,sal from emp where sal in (800, 3000); //in后面的值不是区间，是具体的值
</code></pre>
<ul>
<li><strong>not in :</strong> 不在这几个值当中</li>
</ul>
<pre><code>mysql&gt; select ename, sal from emp where sal not in(800,5000); (查询不是800，5000的值)
</code></pre>
<ul>
<li>
<p>模糊查询 <strong>like</strong></p>
<ul>
<li>在模糊查询中，必须掌握的两个特殊的符号，一个是 <strong>%</strong> ，一个是 <strong>_</strong></li>
<li><strong>%</strong> 代表任意多个字符， <strong>_</strong> 代表任意一个字符。</li>
</ul>
<pre><code>mysql&gt; select ename from emp where ename like '%A%'; (找出名字中含有A字母的)
mysql&gt; select ename from emp where ename like '_A%'; (找出第二个字母是A的)
(找出名字中有下划线的，可以使用反斜杠转义，表示一个普通的下划线)
mysql&gt; select ename from emp where	 ename like '%\_%';
(找出最后一个字母是S的名字)
mysql&gt; select ename from emp where ename like '%S';
</code></pre>
</li>
</ul>
<h4 id="排序升序-降序order-by">排序（升序、降序）Order by</h4>
<ul>
<li>
<p>---&gt; 默认是升序</p>
</li>
<li>
<p>指定升降序，<strong>asc</strong> 表示升序，<strong>desc</strong> 表示降序</p>
<pre><code>mysql&gt; select ename , sal from emp order by sal; （默认升序）

mysql&gt; select ename ,sal from emp order by sal desc; (指定降序)

mysql&gt; select ename ,sal from emp order by sal asc; (指定升序)

（按照工资的降序排列，当工资相同的时候再按照名字的升序排列）
mysql&gt; select ename , sal from emp order by sal desc , ename asc;
(找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列)
mysql&gt; select ename,sal,job from emp
    -&gt; where job = 'salesman'
    -&gt; order by sal desc;
    
    执行顺序  from---&gt; where ---&gt; select ---&gt; order by...
</code></pre>
<ul>
<li>注意：越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序的时候，才会启用后面的字段。</li>
</ul>
</li>
</ul>
<h4 id="分组函数">分组函数</h4>
<ul>
<li><em><strong>count（计数），sum（求和）， avg（平均值）， max（最大值）， min（最小值）</strong></em>
<ul>
<li>所有的分组函数都是对“某一组”数据进行操作的</li>
<li>分组函数又称：多行处理函数</li>
<li>多行处理函数特点：输入多行，最终输出的结果是一行。</li>
<li>分组函数有一个特点：自动忽略null。</li>
<li><strong>在数据库中只要有null进行了运算，最后结果一定是null，所有数据库都是这样规定的</strong></li>
<li>分组函数不可直接使用在where子句当中</li>
<li>分组函数可以组合使用</li>
</ul>
</li>
</ul>
<pre><code>mysql&gt; select sum(sal) from emp;  （找出工资总和）
mysql&gt; select sum(sal) from emp;   （平均工资）
...
（找出工资高于平均工资的员工）
mysql&gt; select ename,sal from emp where sal &gt; avg(sal);
ERROR 1111 (HY000): Invalid use of group function
错误：无效的使用的了分组函数
mysql&gt; select ename, sal  from emp where sal &gt; (select avg(sal) from emp);
	因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why?
	怎么解释？
		因为 group by 是在 where 执行之后才会执行的（分组函数用不了，是因为还没有分组）
		而分组函数必须要 group by 分组才能执行
		select...	5.选择数据
		from...		1.先从表取出数据
		where...	2.条件过滤，哪个数据
		group by...	3.数据分组
		having...	4.数据过滤
		order by... 6.排序输出
count (*) 和 count(具体字段)有什么区别？
count(*) : 不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）
count(comm) : 表示统计comm字段中不为null的数据总数量。

分组函数可以组合使用
mysql&gt; select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;
+----------+----------+-------------+----------+----------+
| count(*) | sum(sal) | avg(sal)    | max(sal) | min(sal) |
+----------+----------+-------------+----------+----------+
|       14 | 29025.00 | 2073.214286 |  5000.00 |   800.00 |
+----------+----------+-------------+----------+----------+
1 row in set (0.00 sec)
</code></pre>
<h4 id="单行处理函数">单行处理函数</h4>
<ul>
<li>输入一行，输出一行</li>
<li><strong>ifnull(comm,0)</strong> ---&gt; 如果comm为null，则使其等同于0。</li>
<li><strong>ifnull(可能为null的数据，被当做什么处理)</strong>  <em>空处理函数</em></li>
</ul>
<pre><code>计算每个员工的年薪？
mysql&gt; select ename, (sal+comm) * 12 yearsal from emp;  // comm为null值时，员工薪资为null，不正确
使用ifnull函数;
mysql&gt; select ename, (sal + ifnull(comm,0)) * 12 yearsal from emp;
</code></pre>
<h4 id="group-by-having"><em><strong>Group by  || Having</strong></em></h4>
<ul>
<li>
<p>group by ：按照某个字段或者某些字段进行分组；</p>
<ul>
<li>注意：分组函数一般都会和 group by 联合使用，这也是为什么被称为分组函数的原因。</li>
<li>任何一个分组函数(count，sum，avg，max，min)都是在group by 语句执行结束后才执行的。</li>
<li>当一条SQL语句没有group by的话，整张表的数据会自成一组。</li>
<li>记住：当一条语句中有 group by 的话，select 后面只能跟分组函数和参与分组的字段。</li>
<li>找出每个工作岗位的最高薪资；</li>
</ul>
<pre><code>mysql&gt; select job,max(sal) from emp group by job;	//找出每个工作岗位的最高薪资；
+-----------+----------+
| job       | max(sal) |
+-----------+----------+
| ANALYST   |  3000.00 |
| CLERK     |  1300.00 |
| MANAGER   |  2975.00 |
| PRESIDENT |  5000.00 |
| SALESMAN  |  1600.00 |
+-----------+----------+

mysql&gt; select job,max(sal) from emp group by job;
以上在mysql当中，有查询结果，但结果没有意义，在oracle数据库中会报错，语法错误。
oracle的语法规则比MySQL语法规则严谨。
记住：当一条语句中有 group by 的话，select 后面只能跟分组函数和参与分组的字段。

找出每个工作岗位的平均薪资。
mysql&gt; select job, avg(sal) from emp group by job;

多个字段能不能联合起来一块分组？
案例：找出每个不同部门不同工作岗位的最高薪资；
mysql&gt; select deptno,job,max(sal) from emp group by deptno,job;

</code></pre>
<ul>
<li>
<p>having：对分组之后的数据进行再次过滤；</p>
<ul>
<li>找出每个部门的最高薪资，要求显示薪资大于2900的数据。
<ul>
<li>sql语句一般多层逻辑建议拆分思考编写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    mysql&gt; select deptno, max(sal) from emp group by deptno;（找出每个部门的最高薪资）
    +--------+----------+
    | deptno | max(sal) |
    +--------+----------+
    |     10 |  5000.00 |
    |     20 |  3000.00 |
    |     30 |  2850.00 |
    +--------+----------+
    （找出每个部门的最高薪资，要求显示薪资大于2900的数据）
    //这种方式效率低,因前面算出的最大值，后面又删掉
    select deptno, max(sal) from emp group by deptno having max(sal) &gt; 2900; 
    +--------+----------+
    | deptno | max(sal) |
    +--------+----------+
    |     10 |  5000.00 |
    |     20 |  3000.00 |
    +--------+----------+
    // 效率较高， where语句，可以从一开始就过滤掉2900以下的
    mysql&gt; select deptno,max(sal) from emp where sal &gt; 2900 group by deptno;
    +--------+----------+
    | deptno | max(sal) |
    +--------+----------+
    |     10 |  5000.00 |
    |     20 |  3000.00 |
    +--------+----------+
    2 rows in set (0.00 sec)
    
    （找出每个部门的平均薪资，要求显示薪资大于2900的数据）
</code></pre>
<h4 id="去重-distinct"><strong>去重</strong> <em><strong>distinct</strong></em></h4>
<ul>
<li><em><strong>distinct</strong></em> 只能出现在所有字段的最前面</li>
</ul>
<pre><code>mysql&gt; select distinct deptno,job from emp;      (联合去重多个字段)
mysql&gt; select count(distinct job),job from emp; （统计所有岗位数量，去重）
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL修改root密码以及改密后仍可直接登录问题]]></title>
        <id>https://geckoc.github.io/post/mysql-xiu-gai-root-mi-ma-yi-ji-gai-mi-hou-reng-ke-zhi-jie-deng-lu-wen-ti/</id>
        <link href="https://geckoc.github.io/post/mysql-xiu-gai-root-mi-ma-yi-ji-gai-mi-hou-reng-ke-zhi-jie-deng-lu-wen-ti/">
        </link>
        <updated>2020-07-31T11:37:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mysql修改root密码">MySQL修改root密码</h3>
<ul>
<li>
<p>进入mysql控制台</p>
<pre><code>mysql&gt; use mysql;
Database changed
mysql&gt; update user set password = PASSWORD('你想要修改的密码') where user = 'root';
</code></pre>
</li>
<li>
<p>如果报错，则是新版变动问题</p>
<pre><code>无报错的话，直接输入
mysql&gt; flush privileges;   //刷新表，使密码生效
-----------------------------------------
新版---&gt;
mysql&gt; update user set authentication_string = PASSWORD('你想要修改的密码') 
     &gt; where user = 'root';
     &gt; 最后仍然需要刷新表
</code></pre>
</li>
<li>
<p>为什么MySQL设置密码后，仍可以不输入密码直接登录？</p>
<p>之前设置了密码，但输入mysql后，可直接进入mysql，而输入mysql -uroot -p，则需要输入密码，这是为什么呢？</p>
<ul>
<li>原来是因为数据库里面有空用户</li>
</ul>
<pre><code>use mysql;
select * from user where user='';  // 找出空账户，如果有则删除
delete from user where user = '';  // 删除空账户
flush privileges;		// 刷新表，使其生效
exit;
</code></pre>
</li>
<li>
<p><strong>注意</strong>：<strong>必要时需要重启MySQL服务器</strong></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaSE语法进阶重点提炼]]></title>
        <id>https://geckoc.github.io/post/javase-yu-fa-jin-jie-chong-dian-ti-lian/</id>
        <link href="https://geckoc.github.io/post/javase-yu-fa-jin-jie-chong-dian-ti-lian/">
        </link>
        <updated>2020-07-25T05:16:31.000Z</updated>
        <content type="html"><![CDATA[<h4 id="about-array"><em>About Array</em></h4>
<ol>
<li>
<p>Java语言中的数组Array是一种引用数据类型，数组的父类是Object；</p>
</li>
<li>
<p>数组实际是一种容器，可以同时容纳多个元素（数组是一个数据集合）字面意思是一组数据；</p>
</li>
<li>
<p>数组当中可以存储基本数据类型，也可以存储引用数据类型；</p>
</li>
<li>
<p>数组是引用数据类型，所以数组对象是堆内存当中的； （存放在堆内存中）</p>
</li>
<li>
<p>数组当中如果存储的是&quot;Java对象&quot;的话，实际上存储的是对象的引用(内存地址)；</p>
</li>
<li>
<p>数组一旦创建，长度不可变；（数组长度不可变）</p>
</li>
<li>
<p>数组的分类：一维数组、二维数组、三维数组....</p>
</li>
<li>
<p>所有数组都有length属性(Java自带的)，用来获取数组中元素的个数；</p>
</li>
<li>
<p>Java中数组中元素要求类型统一</p>
</li>
<li>
<p>数组在内存方面存储的时候，数组中的元素内存地址是连续的（有规律的，排列好的）紧挨着的，数组是一种数据结构</p>
</li>
<li>
<p>数组中首元素的内存地址作为整个数组对象的内存地址</p>
</li>
<li>
<p>数组中每一个元素都是有下标的,下标从0开始，以1递增，最后一个元素的下标是: length-1;</p>
</li>
<li>
<p>数组这种数据结构的优点和缺点？</p>
<ul>
<li>
<p>优点：查询/检索某个下标上的元素时效率极高，可以说是查询效率最高的一个数据结构；</p>
</li>
<li>
<p><strong>为什么查询效率高？</strong><br>
1、每一个元素的内存地址在空间存储上是连续的；<br>
2、每一个元素的类型相同，所以占用空间相同；<br>
3、知道第一个元素内存地址，知道元素占用空间，知道下标，可通过数学表达式快速计算<br>
出某一个下标上元素的内存地址，直接定位所以效率是最高的；</p>
<p>数组中存储100个元素，或者100万个元素，在查询/检索方面，效率是相同的；</p>
</li>
<li>
<p>缺点：由于数组上元素的内存地址是连续的，所以在数组上随机增删元素时，效率较低，因增删元素会涉及到后面元素统一向前或向后位移的操作；</p>
</li>
<li>
<p>数组不能存储大数据类型，为什么？</p>
<ul>
<li>因为很难在内存空间上找到一块特别大的连续的内存空间</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意：对于数组最后一个元素的增删，效率是不会影响的</strong></p>
<hr>
<pre><code>//		静态初始化数组
		int[] i = {12,123,124,325,523};
		for (int j = 0; j &lt; i.length; j++) {
			System.out.println(i[j]);
		}
		System.out.println(i[i.length-1]);
		
//		动态初始化数组
		Object[] obj = new Object[5];
		for (int j = 0; j &lt; obj.length; j++) {
			System.out.println(obj[j]);
		}
</code></pre>
<pre><code>/*
 * 	一维数组深入理解：数组中存储的类型为引用数据类型
 * 	对于数组来说，实际上只能存户java对象的“内存地址”，
 * 	数组中存储的每个元素是“引用”
 */
public class ArrayDeep01 {
	public static void main(String[] args) {
		Animal a1 = new Animal();
		Animal a2 = new Animal();
		Animal[] animals = {a1 , a2};
		for (int i = 0; i &lt; animals.length; i++) {
//			Animal animal = animals[i];
//			animal.move();
			animals[i].move(); // 代码合并
			//animals是一个数组 。
			//animals[0]是数组中的一个元素 所以可以调用move()方法
		}
		
		Animal[] anis = new Animal[3];
		anis[0] = new Animal();
//		anis[1] = new Product();类型不匹配，无法转换 数值中元素要求数据类型统一
		anis[2] = new Cat(); // Animal数组中可以存放Cat，因为Cat是Animal的子类
		anis[1] = new Bird(); //多态父类型引用指向子类型对象
		
		anis[0].move();
		anis[1].move();
		anis[2].move();
		System.out.println(&quot;--------------&quot;);
//		当使用子对象特有方法时，需向下类型转换   
		for (int i = 0; i &lt; anis.length; i++) {
			if (anis[i] instanceof Cat) {
				Cat cat = (Cat)anis[i];
				cat.catchMouse();
			}else if (anis[i] instanceof Bird) {
				Bird bird = (Bird)anis[i];
				bird.fly();
			}
		}
	}

}
class Animal{
	public void move() {
		System.out.println(&quot;Animal move...&quot;);
	}
}
class Product{
	
}

class Cat extends Animal{
	public void move() {
		System.out.println(&quot;Cat move...&quot;);
	}
	public void catchMouse() {
		System.out.println(&quot;猫抓老鼠&quot;);
	}
}

class Bird extends Animal{
	public void move() {
		System.out.println(&quot;Bird fly!!!&quot;);
	}
	public void fly() {
		System.out.println(&quot;鸟儿在翱翔&quot;);
	}
}
</code></pre>
<h6 id="关于java一维数组的扩容">关于Java一维数组的扩容</h6>
<pre><code>public class ArrayDeep02 {
	public static void main(String[] args) {
		//数组是如何进行拷贝的？
//		System.arraycopy(src源, srcPos源的起始位置, dest目标, destPos目标起始位置, length长度); 
		
		int[] src = {1 , 23 , 455 , 21 , 24}; //拷贝源
		int[] dest = new int[20];	//目标		
		
		System.arraycopy(src, 0, dest, 5, src.length);
		
		// 遍历目标数组
		for (int i = 0; i &lt; dest.length; i++) {
			System.out.println(dest[i]);
		}
		
		//数组中存储的元素是引用，也可以拷贝
		String[] str = {&quot;xsax&quot;, &quot;sadasd&quot;, &quot;Hello&quot;, &quot;World&quot;, &quot;Copy&quot;};
		String[] deStrings = new String[10];
		System.arraycopy(str, 0, deStrings, 2, str.length);
		for (int i = 0; i &lt; deStrings.length; i++) {
//			System.out.print(deStrings[i] + &quot;\t&quot;);
		}
		
		Object[] objs = {new Object(), new Object(), new Object()};
		Object[] destObj = new Object[10];
		System.out.println(&quot;============&quot;);
		// 拷贝的是对象的内存地址，不是拷贝对象；
		System.arraycopy(objs, 0, destObj, 2, objs.length);
		for (int i = 0; i &lt; destObj.length; i++) {
			System.out.println(destObj[i]);
		}
	}
}
</code></pre>
<h6 id="关于java中的二维数组">关于Java中的二维数组</h6>
<pre><code>/**
*
* Copyright: Copyright (c) 2020 Richard-Chan
* @Description: 关于Java中的二维数组
* 	1. 二维数组是一个特殊的一维数组，特殊在这个数组中每一个元素都是一个一维数组
* 
* 	2. 三维数组是一个特殊的一维数组，特殊在这个数组中每一个元素都是一个二维数组
* 		实际开发中使用最多的是一维数组，二维数组较少用，三维几乎不用
* 
* 	3. 二维数组静态初始化
*		int[][] y = { {100, 200, 300},{234, 234, 987},{290, 876, 230}, {0 , 1} };
*
*---------------------------------------------------------
 */
public class Array2Dimension01 {
	public static void main(String[] args) {
		// 一维数组
		int[] x = {100, 200, 300};
		System.out.println(x.length); //3
		// 二维数组  ,每一个元素都是一个一维数组
		// 二维数组的length属性
		int[][] y = {
				{100, 200, 300},
				{234, 234, 987},
				{290, 876, 230}, {0 , 1}
			};
		System.out.println(y.length); //4
		System.out.println(y[0].length);//3
	}
}
---------------------------------------------------------------
/*
 *  	关于二维数组的读和改
 *  	a[二维数组中一维数组的下标] [一维数组的下标]
 *  
 *  	a[0][0] 表示二维数组中第一个一维数组中的第一个元素
 *  
 *  	a[3][100] 表示二维数组中第四个一维数组中的第101个元素
 *  
 *  	注意：
 */
public class Array2Dimension02 {
	public static void main(String[] args) {
		int[][] y = {
				{100, 200, 300},
				{234, 234, 987},
				{290, 876, 230}, 
				{0 , 1}
			};
		// 取出二维数组中的元素
		int[] y0 = y[0];
		int x1 = y0[0];
		System.out.println(x1);
		//合并以上代码
		System.out.println(y[0][0]);
		
		//取出第二个一维数组中的第三个元素
		
		//改
		y[0][0] = 999;  //注意下标越界问题
		
	}
}
</code></pre>
<h6 id="二维数组的遍历">二维数组的遍历</h6>
<pre><code>public class Array2Dimension03 {
	public static void main(String[] args) {
		String[][] dimensionArray = {
				{&quot;Java&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;c#&quot;, &quot;PHP&quot;},
				{&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;},
				{&quot;Jack&quot;, &quot;Tom&quot;, &quot;Gilfoyle&quot;, &quot;Denish&quot;, &quot;Richard&quot;}
		};
		
		// 遍历二维数组
		for (int i = 0; i &lt; dimensionArray.length; i++) {  //外层循环 （负责纵向）
//			String[] array = dimensionArray[i]; // 一维数组
			// 遍历一维数组
			for (int j = 0; j &lt; dimensionArray[i].length; j++) {
				System.out.print(dimensionArray[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
}
</code></pre>
<h4 id="about-exception"><em>About Exception</em></h4>
<ul>
<li>什么是异常，异常在Java中的作用
<ol>
<li>程序执行过程中出现的不正常情况，叫做异常</li>
<li>java把异常信息打印输出到控制台，供开发者参考 （信息是JVM打印的）</li>
<li>看到后可以修改，让程序更加完善、健壮</li>
<li>异常在Java中以类的形式存在，只要是类就可以创建对象</li>
</ol>
</li>
</ul>
<p><strong>对于异常的理解</strong></p>
<ul>
<li>
<p>java的异常处理机制</p>
<ol>
<li>
<p>异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？</p>
<ul>
<li>我们可以使用UML图来描述一下继承结构。</li>
<li>画UML图有很多工具，例如：Rational Rose（收费的）、starUML等....</li>
<li>Object</li>
<li>Object下有Throwable（可抛出的）</li>
<li>Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）</li>
<li>Exception下有两个分支：</li>
<li>Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</li>
<li>RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</li>
</ul>
</li>
<li>
<p>编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。</p>
<ul>
<li>编译时异常因为什么而得名？</li>
<li>因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。</li>
<li>所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。</li>
<li>因为异常的发生就是new异常对象。</li>
</ul>
</li>
<li>
<p>编译时异常和运行时异常的区别？</p>
<ul>
<li>
<p>编译时异常一般发生的概率比较高。</p>
<ul>
<li>举个例子：
<ul>
<li>
<p>你看到外面下雨了，倾盆大雨的。</p>
</li>
<li>
<p>你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。</p>
</li>
<li>
<p>而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。</p>
</li>
<li>
<p>“拿一把伞”就是对“生病异常”发生之前的一种处理方式。</p>
</li>
<li>
<p>对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>运行时异常一般发生的概率比较低。</p>
<ul>
<li>举个例子：
<ul>
<li>小明走在大街上，可能会被天上的飞机轮子砸到。</li>
<li>被飞机轮子砸到也算一种异常。</li>
<li>但是这种异常发生概率较低。</li>
<li>在出门之前你没必要提前对这种发生概率较低的异常进行预处理。</li>
<li>如果你预处理这种异常，你将活的很累。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。</p>
</li>
<li>
<p>假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，</p>
</li>
<li>
<p>所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？</p>
<ul>
<li>首先，如果这样的话，程序肯定是绝对的安全的。</li>
<li>但是程序员编写程序太累，代码到处都是处理异常的代码。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编译时异常还有其他名字：</p>
<ul>
<li>受检异常（受控异常）：CheckedException</li>
</ul>
</li>
<li>
<p>运行时异常还有其它名字：</p>
<ul>
<li>未受检异常（非受控异常）：UnCheckedException</li>
</ul>
</li>
<li>
<p>再次强调：所有异常都是发生在运行阶段的。</p>
</li>
<li>
<p>Java语言中对异常的处理包括两种方式：</p>
<ul>
<li>
<p>第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。抛给上一级。</p>
</li>
<li>
<p>第二种方式：使用try..catch语句进行异常的捕捉。这件事发生了，谁也不知道，因为我给抓住了。</p>
</li>
<li>
<p>举个例子：</p>
<ul>
<li>
<p>我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，“损失1000元”这可以看做是一个异常发生了。我有两种处理方式，</p>
</li>
<li>
<p>第一种方式：我把这件事告诉我的领导【异常上抛】</p>
</li>
<li>
<p>第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】</p>
</li>
<li>
<p>张三 --&gt; 李四 ---&gt; 王五 --&gt; CEO</p>
</li>
</ul>
</li>
<li>
<p>思考：</p>
<ul>
<li>异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要</li>
<li>对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</p>
</li>
<li>
<p>不建议在main()方法中调用 throws 上抛异常，因为一旦出现异常</p>
</li>
</ol>
<ul>
<li>main()会直接抛给JVM，终止程序运行</li>
<li>在main方法中一般使用 try...catch 捕捉异常</li>
<li>throws()可以上抛多个异常，以逗号隔开</li>
</ul>
</li>
</ul>
<pre><code>* 异常对象中两个非常重要的方法
* 		1、获取异常的描述信息
* 			String msg = exception.getMessage(); 
* 
*		2、打印异常追踪的堆栈信息
*			e.printStackTrace();
/**
* Copyright: Copyright (c) 2020 Richard-Chan
* 
* @Description: 深入理解 try ... catch..
*		1、catch后面的异常类型可以是具体异常类型也可以是父类
*		2、catch后面可以写多个，建议catch的时候精确的一个个处理，利于调试
*		3、catch写多个的时候，自上而下必须遵守从小到大的原则
*
*---------------------------------------------------------
 */
public class TryCatchDeep {
	public static void main(String[] args) {
		try {
			FileInputStream fis = new FileInputStream(&quot;&quot;);
			fis.read();
			fis.close();
		} catch (FileNotFoundException e) {
			System.out.println(&quot;文件不存在&quot;);
		} catch (IOException e) {
			e.printStackTrace();
		}
		tryCatch();
	}
	
	/*
	 * 	JDK8中的新特性，可以使用 | 或 捕捉多个异常
	 */
	public static void tryCatch() {
		try {
			FileInputStream fis = new FileInputStream(&quot;&quot;);
			System.out.println(fis);
			System.out.println(100 / 0);
		} catch (FileNotFoundException | ArithmeticException | NullPointerException e) {
			System.out.println(&quot;文件不存在？算数异常？空指针异常？都有可能&quot;);
		}
	}
}
</code></pre>
<p><strong><em>Finally</em> 语句</strong></p>
<pre><code>/*      关于try...catch...中的子句Finally
*		1、即使try中出现异常，在finally子句中的代码是最后执行且一定会执行的
*			
*		2、而且必须和try...catch语句一起使用
*
*		3、通常在finally语句中完成资源的释放/关闭,因为finally语句中的代码比较有保障
 * try不可以单独使用
 * finally语句可以和try联合使用
 * finally语句中的代码是一定会执行的
 * exit()可以终止finally
 * 
 */
public class FinallyTry {
	public static void main(String[] args) {
		
		/*
		 * 	以下代码执行顺序：
		 * 	try &gt; finally &gt; return
		 * 	finally语句中即使有return也会执行
		 * 	finally语句
		 */
		try {
			System.out.println(&quot;try....&quot;);
//			System.exit(0); 退出JVM，finally语句不执行
			return;
		} finally {
			System.out.println(&quot;finally...&quot;);
		}
		//以下代码一定不会执行，所以编译错误，上面已经执行return
		//System.out.println(&quot;Hello Gilfoyle&quot;);
	}
}
</code></pre>
<p><strong><em>Finally</em></strong> <strong>面试题</strong></p>
<pre><code>public class FinallyInterview {
	public static void main(String[] args) {
		int result = finallyIV();
		System.out.println(result); // 100
	}
	/*
	 * Java语法规则，必须遵循自上而下的原则
	 * return语句必须保证是最后执行的
	 * return语句一旦执行整个方法必须结束
	 */
	public static int finallyIV() {
		int i = 100;
		try {
			return i;
		} finally {
			i++;
		}
	}
}
</code></pre>
<p><strong><em>final、finally、finalize</em></strong> <strong>的区别</strong></p>
<ul>
<li>final（关键字）</li>
<li>final 修饰的变量无法重新赋值</li>
<li>final 修饰的类无法继承</li>
<li>final 修饰的方法无法覆盖（重写）</li>
<li>finally（关键字）</li>
<li>finally和try一起联用</li>
<li>finally语句块中的代码是必须执行的</li>
<li>finalize （标识符）是一个Object类中的方法名, 这个方法是由垃圾回收器GC调用的</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程模拟车站售票]]></title>
        <id>https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/</id>
        <link href="https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/">
        </link>
        <updated>2020-07-12T18:11:23.000Z</updated>
        <summary type="html"><![CDATA[<p>深入理解synchronized，以及多线程使用，这是较为经典的例子</p>
]]></summary>
        <content type="html"><![CDATA[<p>深入理解synchronized，以及多线程使用，这是较为经典的例子</p>
<!-- more -->
<blockquote>
<p>一开始我花了比较多时间，去判断当票数为0时，Thread还会继续启动，返回-1，-2显示购票成功<br>
解决：将synchronized同步代码片放到run方法下，且while(true)，一开始写成while(user.getRemainingTicket())，改过后，线程仍会启动进入run()但会返回无法购票提示，不再显示购票成功</p>
</blockquote>
<ul>
<li>本来写的代码注释较少，为了方便阅读，适当加了注释<br>
<s>1. TicketAccount (购票账户)</s><br>
- （改进，其实可以在run添加同购票方法，有需求也可在账户类编写）<br>
- （改进代码均会在下方贴出）</li>
</ul>
<ol start="2">
<li>TicketBusinessThread（线程）</li>
<li>TicketBusinessSystem（测试类）</li>
</ol>
<h4 id="talk-is-cheapshow-me-the-code"><em>Talk is cheap，show me the code.</em></h4>
<pre><code>public class TicketAccount {
	private int remainingTicket;  //票数
// 我是直接初始化给定票数值测试，你也可以带有参构造，自己想赋值多少都可以
	public TicketAccount() {
		this.remainingTicket = 100;
	}
	
	public int getRemainingTicket() {
		return remainingTicket;
	}

	public void setRemainingTicket(int after) {
		this.remainingTicket = after;
	}
// 购票方法
	public void ticketBuy(int remainingTicket) {
//			购票前
			int before = this.getRemainingTicket();
//			购票后
			int after = before - remainingTicket;
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
//			更新票数数据
			this.setRemainingTicket(after);
	}
}
</code></pre>
<pre><code>public class TicketBusinessThread implements Runnable{
	private TicketAccount ticketAccount ;
	public TicketBusinessThread(TicketAccount ticketAccount) {
		this.ticketAccount = ticketAccount;
	}
	@Override
	public void run() {
		int tick = 1;
        /*
		 *  这里花费了一些时间，由于while()语法，前面已说过不再赘述
		 *  注：synchronized同步代码块需在while内
		 *  否则会一个线程直接买完票，其他线程窗口无用
		 */
		while (true) {
		    synchronized (ticketAccount) {
		    	if (this.ticketAccount.getRemainingTicket() &gt; 0) {
		    		ticketAccount.ticketBuy(tick);
		    		System.out.println(&quot;恭喜使用&quot;+Thread.currentThread().getName()+&quot;购票成功&quot;+&quot;剩余票数为：&quot;
                    +this.ticketAccount.getRemainingTicket());
		    	}else {
		    		System.out.println(&quot;不好意思，票已售完&quot;);
		    		break;
		    	}
			}
		}
	}
}
</code></pre>
<pre><code>public class TicketBusinessSystem {
	public static void main(String[] args) {
		TicketAccount ticketAccount1 = new TicketAccount();
        // 创建线程对象，传入可运行类
		Thread tickBuy_one = new Thread(new TicketBusinessThread(ticketAccount1));
		Thread tickBuy_two = new Thread(new TicketBusinessThread(ticketAccount1));
		Thread tickBuy_three = new Thread(new TicketBusinessThread(ticketAccount1));
		// 设置线程名字
		tickBuy_one.setName(&quot;窗口1&quot;);
		tickBuy_two.setName(&quot;窗口2&quot;);
		tickBuy_three.setName(&quot;窗口3&quot;);
		//线程启动
		tickBuy_one.start();
		tickBuy_two.start();
		tickBuy_three.start();
	}
}
</code></pre>
<blockquote>
<p>以上为初次代码 2020-7-13 02:11:16</p>
</blockquote>
<ol>
<li>[改进] TicketBusinessThread（线程）<br>
<s>2. [改进] TicketBusinessSystem（测试类）</s><br>
-  测试类，与上面如出一辙，删除了有参构造，直接New调用即可</li>
</ol>
<pre><code>public class TicketBusinessThread implements Runnable{
	private int ticks = 100;//定义初始票数，也可构造有参自定义票数
	@Override
	public void run() {
        	while (true) {
                //调用购票方法，票售完跳出死循环
			    payTicket();
			    if (ticks == 0) {
				    System.out.println(&quot;对不起，票已售完...&quot;);
				    break;
			    }
		    }
		}
	}
	
//	定义同步买票方法
	public void payTicket() {
//		判断票是否存在
			synchronized (this) {
				if (ticks &gt; 0) {
//			提高线程安全问题出现概率，使线程堵塞
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName() + &quot;正在卖出第&quot;+ticks+&quot;张票，&quot;+&quot;恭喜购票成功&quot;);
					ticks--;
				}
			}
	}
}
</code></pre>
<ol>
<li>TicketAccount (购票账户)[改]</li>
</ol>
<blockquote>
<p>第一次写是想用户输入购票数，可多张购买；由于每个身份证只能购票一张，重写编写，在账户类定义方法如下：以下只有购票方法代码其他属性根据需求自行定义</p>
</blockquote>
<pre><code>public void ticketBuy() {
		synchronized (this) {
			if (this.getRemainingTicket() &gt; 0) {
//				提高线程安全问题出现概率，使线程堵塞
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + &quot;正在卖出第&quot;+getRemainingTicket()+&quot;张票，&quot;+&quot;恭喜购票成功&quot;);
				int after = --remainingTicket;
				setRemainingTicket(after);
			}	
		}
	}
      
    改于2020-7-13 21:48:39
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gitalk配置教程]]></title>
        <id>https://geckoc.github.io/post/gitalk-pei-zhi-jiao-cheng/</id>
        <link href="https://geckoc.github.io/post/gitalk-pei-zhi-jiao-cheng/">
        </link>
        <updated>2020-07-09T17:42:50.000Z</updated>
        <summary type="html"><![CDATA[<p>gitalk配置分享，使用Gridea初步</p>
]]></summary>
        <content type="html"><![CDATA[<p>gitalk配置分享，使用Gridea初步</p>
<!-- more -->
<h3 id="获得权限">获得权限</h3>
<p>在使用该脚本之前首先要在 GitHub 创建一个新的 Oauth Application</p>
<p><a href="https://github.com/settings/apps">点击此处 Click Here</a></p>
<p>点击Oauth Apps，然后新建<br>
<img src="https://geckoc.github.io//post-images/1594317386736.png" alt="" loading="lazy"></p>
<p>Application name: 随便填写<br>
Homepage URL: 填写博客所在的仓库名。比如我的博客就填写: https://geckoc.github.io/<br>
Application description: 可以不用填写<br>
Authorization callback URL: 如果有把域名通过CNAME解析到仓库上就填写自己的域名。如果没有就填写仓库名即可</p>
<p>点击Register Application就可以创建<br>
接着就可以看到该应用的Client ID和Client Secret</p>
<h3 id="创建仓库">创建仓库</h3>
<p>完成以上步骤后，<a href="https://github.com/new">点此创建</a>仓库来保存评论<br>
<img src="https://geckoc.github.io//post-images/1594318018870.png" alt="" loading="lazy"></p>
<p>比如填写仓库名为Comments，其余都不用填写</p>
<h3 id="配置">配置</h3>
<p>博客配置</p>
<pre><code>&lt;section class=&quot;post-full-comments&quot;&gt;
    {{!-- gittalk --}}
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;
    &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var gitalk = new Gitalk({
            clientID: '修改：之前创建Oauth Apps保存的Client ID',
            clientSecret: '修改：之前创建Oauth Apps保存的Client Secret',
            repo: '修改：之前创建的repo名称，就是前面例子中的Comments',
            owner: '修改：GitHub的个人名称',
            admin: ['修改：GitHub的个人名称'], //这里可以填写具有写权限的用户名列表，用来初始化Issues的
            id: '{{comment_id}}',
            distractionFreeMode: false // Facebook-like distraction free mode
        });
        gitalk.render('gitalk-container');
    &lt;/script&gt;
&lt;/section&gt;
</code></pre>
<p>使用Gridea的话可以直接在设置中打开评论，填写以下内容</p>
<pre><code>clientID: '修改：之前创建Oauth Apps保存的Client ID',
clientSecret: '修改：之前创建Oauth Apps保存的Client Secret',
repo: '修改：之前创建的repo名称，就是前面例子中的Comments',
owner: '修改：GitHub的个人名称',
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[THE LIE WE LIVE]]></title>
        <id>https://geckoc.github.io/post/the-lie-we-live/</id>
        <link href="https://geckoc.github.io/post/the-lie-we-live/">
        </link>
        <updated>2020-07-04T15:27:37.000Z</updated>
        <summary type="html"><![CDATA[<p>人们最喜欢看的内容，不是现实和真相，而是可以让他们意淫的内容。</p>
]]></summary>
        <content type="html"><![CDATA[<p>人们最喜欢看的内容，不是现实和真相，而是可以让他们意淫的内容。</p>
<!-- more -->
<ul>
<li>微博上有不少居心不良的大V，喜欢打着女权的幌子，传播一些很倒风向的言论，比如“你负责赚钱养家，我负责貌美如花”“不舍得给你花钱的男人就是不爱你”“女孩子就应该被宠着”，如果你接触一下微博，你就会惊讶，这些一听就没道理的话，为什么会这么有市场？为什么很多女生听完以后会理直气壮的把这些话当成口号？答案就是——这些内容会让她们爽，让她们心安理得的接受别人的馈赠，不努力却要求别人努力，一身臭毛病还要让别人宠着。网络小说，给男生看的，大多是讲一个要钱没钱、要能力没能力的屌丝，忽然因为某个意外事件，获得了某种超能力，然后混的风生水起，多少女人前仆后继的陪他上床，最后甚至能统治整个宇宙；给女生看的，大多是讲一个长相普普通通的女生，某一天邂逅了一个白马王子，种种机缘巧合之下，她被白马王子追求，捧在手心，或者被n个富二代追求，最后顺理成章嫁入豪门。这些文章，但凡有脑子的人，都知道不现实，但是为什么网络小说全都这么写？就因为这些内容看完以后能让人爽，能让人通过短暂的幻想逃避现实。最残忍的是，很多人幻想的久了，竟然忘了这些事发生的概率多么低，真的以为自己可以屌丝逆袭/嫁入豪门/咸鱼翻身，然后就真的不努力了，因为幻想毁了自己的一生。而当我一板一眼的把这些残忍真相告诉他们的时候，他们竟然接受不了现实，不仅不给我继续，还扬言要屏蔽我...</li>
</ul>
<hr>
<ul>
<li>你并不比自己的父母优秀多少。现在知乎上批判自己父母的声音也很盛，诸多白领们自认为自己的表现远远优于自己的父母。其实，这不过是因为经济结构转型造成的误会。现在在公司的格子间里面哼哧哼哧做PPT的那些人，和当年踩着缝纫机的女工没有本质区别。 现在在各种购物软件上抢红包的那些人，和当年在菜市场上为了一分钱讨价还价的父母也没有区别；现在买个手机非得戴个壳、贴层膜，和当年父母非要给遥控器套个塑料袋也差不多；其实，现在每天刷微博、抖音、知乎的人，跟当年蹲在墙根晒太阳嗑瓜子的，也没什么区别。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[让子弹飞]]></title>
        <id>https://geckoc.github.io/post/rang-zi-dan-fei/</id>
        <link href="https://geckoc.github.io/post/rang-zi-dan-fei/">
        </link>
        <updated>2020-07-04T14:55:59.000Z</updated>
        <summary type="html"><![CDATA[<p>马匪：“我好不容易把女生追到手，该结婚了，居然要30万彩礼”<br>
师爷：“对。”<br>
马匪：“还必须有车有房？”<br>
师爷：“对。”</p>
]]></summary>
        <content type="html"><![CDATA[<p>马匪：“我好不容易把女生追到手，该结婚了，居然要30万彩礼”<br>
师爷：“对。”<br>
马匪：“还必须有车有房？”<br>
师爷：“对。”</p>
<!-- more -->
<p>马匪：“还必须时刻担心回到单身生活?”<br>
师爷：“对。”<br>
马匪：“我不成了跪着要饭的吗?”<br>
师爷：“那要你这么说，结婚的男性就是跪着要饭的，就这，三千万想跪还没这路子呢!”<br>
马匪：“我上大学，学毛概，学马克思，就是因为腿脚不利索，跪不下去!”<br>
师爷：“原来想站着结婚啊?那还是去欧美吧”<br>
马匪：“哎?这我就不明白了，咱们新时代独立女青年怎么就赶不上欧美资本主义的女性？”<br>
师爷：“咱们眼里，你是有志向高远的有为青年。在她们眼里，那你就是跪着要饭的。结婚嘛，跪着，不寒碜。”<br>
马匪：“寒碜!很T.M寒碜!”<br>
师爷：“那你是想站着，还是想结婚呢?”<br>
马匪：“我是想站着，还把婚结了。”<br>
师爷：“结不成。”<br>
马匪：“结不成?”<br>
师爷：“结不成!”<br>
马匪：“这个（年入百万）能不能把婚结了？”<br>
师爷：“能结，跪着。”<br>
马匪：“那这个（英俊帅气）能不能结婚？”<br>
师爷：“能结，好的不一定能找到。”<br>
马匪：“那我这个（年入百万）再加这个（英俊帅气），能不能把婚好好结了？”<br>
师爷：“敢问英雄贵姓？”马匪：“社会主义接班人”</p>
]]></content>
    </entry>
</feed>