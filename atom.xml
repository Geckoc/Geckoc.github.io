<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geckoc.github.io/</id>
    <title>RichardTech</title>
    <updated>2020-06-28T19:45:14.247Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geckoc.github.io/"/>
    <link rel="self" href="https://geckoc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://geckoc.github.io/images/avatar.png</logo>
    <icon>https://geckoc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, RichardTech</rights>
    <entry>
        <title type="html"><![CDATA[Collection Essential]]></title>
        <id>https://geckoc.github.io/post/collection-essential/</id>
        <link href="https://geckoc.github.io/post/collection-essential/">
        </link>
        <updated>2020-06-28T19:00:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="collection当中可存放-的元素"><em>Collection</em>当中可存放 的元素</h3>
<ul>
<li>没有使用&quot;泛型&quot;之前， <em>Collection</em> 中可以存储Object的所有子类型</li>
<li>使用了&quot;泛型&quot;之后，<em>Collection</em> 只能存储某个具体的类型</li>
</ul>
<blockquote>
<p>集合中不能直接存储基本数据类型和Java对象，只能存储对象的内存地址（引用）<br>
<em>Collection</em>是接口，无法实例化对象</p>
</blockquote>
<h3 id="collection中的常用方法"><em>Collection</em>中的常用方法</h3>
<ul>
<li><strong><em>boolean add(Object e)</em></strong></li>
<li><strong><em>boolean contains(Object o)</em></strong></li>
<li><strong><em>boolean remove(Object o)</em></strong></li>
<li><strong><em>nt size()</em></strong></li>
<li><strong><em>boolean isEmpty()</em></strong></li>
<li><strong><em>Object[] toArray()</em></strong>   <s>把集合转换为数组</s></li>
</ul>
<pre><code>public class ContainTest {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		String s1 = new String(&quot;abc&quot;);
		c.add(s1);
		String s2 = new String(&quot;edf&quot;);
		c.add(s2);
		
		String x = new String(&quot;abc&quot;);
		/*
		 * 	如果此集合包含指定的元素，则返回true 。 
		 * 	更正式地，返回true
		 * 	如果且仅当该集合至少包含一个元素e使得(o==null ? e==null : o.equals(e)) 
		 *  contains底层调用了equals(),而String已经重写了equals方法
		 *	所以比较的不是内存地址 ，而是内容
		 */
		System.out.println(c.contains(x)); //true
	}
}
</code></pre>
<pre><code>public class DeepContains {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		User u1 = new User(&quot;abc&quot;);
		User u2 = new User(&quot;abc&quot;);
		c.add(u1);
		/*
		 * 	User没有重写equals方法，底层Object的equals使用的是==
		 * 	比较的是内存地址，返回false
		 */
//		System.out.println(c.contains(u2));
		/*
		 * 	重写User的equals方法后，返回true
		 * 	比较的是内容
		 */
		System.out.println(c.contains(u2));
		
		Collection collection = new ArrayList();
		String x1 = new String(&quot;jack&quot;);
		String x2 = new String(&quot;jack&quot;);
		collection.add(x1);
		System.out.println(collection.size());
		/*
		 * remove方法底层调用了equals
		 * 	删除x2的时候，既是删除了x1
		 */
		collection.remove(x2);
		System.out.println(collection.size());
		
	}
	
}
class User{
	String name;
	public User() {
		// TODO Auto-generated constructor stub
	}
	public User(String name) {
		
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}
</code></pre>
<h4 id="结论存放在集合中的类型一种要重写equals方法"><strong><em>结论：存放在集合中的类型，一种要重写equals方法</em></strong></h4>
<hr>
<h3 id="关于集合遍历-迭代器"><strong>关于集合遍历 迭代器</strong></h3>
<ol>
<li><em>boolean hasNext()</em>  如果仍有元素可迭代，则返回 <em>true</em></li>
<li><em>Object next()</em> 让迭代器前进一位且返回所迭代中指向的元素。</li>
<li><em>remove()</em> 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。
<blockquote>
<p><em>Collection</em>通用迭代方法，在<em>Map</em>集合中不能使用</p>
</blockquote>
</li>
</ol>
<ul>
<li>List集合存储元素特点：有序可重复，元素有下标   实现类 <em>ArraysList、LinkedList、Vector</em></li>
<li>Set集合存储元素特点：无序不可重复，元素没有下标  实现类 <em>HashSet、TreeSet</em><br>
<img src="https://geckoc.github.io//post-images/1593373353494.jpg" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaWeb:The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path]]></title>
        <id>https://geckoc.github.io/post/javawebthe-superclass-javaxservlethttphttpservlet-was-not-found-on-the-java-build-path/</id>
        <link href="https://geckoc.github.io/post/javawebthe-superclass-javaxservlethttphttpservlet-was-not-found-on-the-java-build-path/">
        </link>
        <updated>2020-06-28T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jsp页面顶端出现红色的报错信息"><em><strong>JSP页面顶端出现“红色”的报错信息:</strong></em></h2>
<p><em><strong>The superclass &quot;javax.servlet.http.HttpServlet&quot; was not found on the Java Build Path。</strong></em><br>
<em>原来Javaweb工程类中没有添加Tomcat运行时相关类导致。<br>
下面是具体的解决方法：</em></p>
<ol>
<li><em>右击web工程-》属性或Build Path-》Java Build Path-&gt;Libraries-&gt; Add Libray...-&gt;Server Runtime -》Tomcat Server</em></li>
<li><em>切换到Java Build Path界面中的Orader and Export，选择Tomcat。</em></li>
</ol>
<h3 id="注意"><strong>注意</strong></h3>
<p>按以上方法操作时，若打开<em>Server Runtime</em>后一片空白，需要设置<em>Apache</em>服务器。设置方法为：<em>window-&gt;Preferences-&gt;Server-&gt;Runtime Environment -&gt; add --&gt;</em> 选择<em>Apache</em>的版本后点<em>Next</em>，再填入你<em>apache</em>服务器软件的安装（解压后）地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Java异常深入理解 ]]></title>
        <id>https://geckoc.github.io/post/guan-yu-java-yi-chang-shen-ru-li-jie/</id>
        <link href="https://geckoc.github.io/post/guan-yu-java-yi-chang-shen-ru-li-jie/">
        </link>
        <updated>2020-06-27T19:32:58.000Z</updated>
        <content type="html"><![CDATA[<p>throws | try catch Day_27<br>
◾不建议在main()方法中直接调用throws，因为一旦出现异常JVM将会直接终止，一般采用try catch<br>
◾关于throws和try...catch的选择，当需要反馈给调用者异常信息时，则throws<br>
◾异常在Java程序中是以类和对象存在的<br>
◾异常的作用：增强程序的j健壮性</p>
<p>异常中的关键字<br>
◾try<br>
◾try 和 finally 可以联合使用，try不可单独使用</p>
<p>◾catch<br>
◾catch可以捕捉多个异常<br>
◾catch的异常顺序必须遵循自上而下从小到大的原则</p>
<p>◾finally<br>
1.finally子语句必须和try...catch使用<br>
2.finally语句块中的代码一旦会执行且在最后执行<br>
3.finally多用于资源的释放和关闭，因执行有保障</p>
<p>◾throws<br>
◾throws可以抛出多个异常以逗号隔开<br>
◾在方法声明位置上使用，表示上报异常给调用者</p>
<p>◾throw 手动抛出异常</p>
<p>自定义异常Exception<br>
1.创建的类中继承Exception或者RuntimeException<br>
2.创建构造方法，一个无参数的，一个有参数String的</p>
<p>final	finally	finalize 三者间的区别</p>
<p>final ---- 关键字<br>
◾final修饰的类无法继承<br>
◾final修饰的方法无法重载/重写override<br>
◾final修饰的变量无法重写赋值</p>
<p>finally ---- 关键字<br>
◾finally语句块的代码必须执行<br>
◾finally和try可以联合使用<br>
◾System.exit(0)，终止JVM时finally语句块的代码无法执行</p>
<p>finalize ---- 标识符<br>
◾这是一个Object类中的方法名<br>
◾此方法是由垃圾回收器GC调用的<br>
◾finalize 已经过时<br>
在方法重写Override中，重写的方法抛出的异常不能比父类的多（宽泛性）<br>
<img src="https://geckoc.github.io//post-images/1593286607347.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>