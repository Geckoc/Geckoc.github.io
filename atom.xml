<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geckoc.github.io/</id>
    <title>RichardTech</title>
    <updated>2021-04-03T04:45:17.425Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geckoc.github.io/"/>
    <link rel="self" href="https://geckoc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://geckoc.github.io/images/avatar.png</logo>
    <icon>https://geckoc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, RichardTech</rights>
    <entry>
        <title type="html"><![CDATA[RabbitMQ]]></title>
        <id>https://geckoc.github.io/post/rabbitmq/</id>
        <link href="https://geckoc.github.io/post/rabbitmq/">
        </link>
        <updated>2021-04-03T04:41:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="rabbitmq-初见端倪"><strong>RabbitMQ 初见端倪</strong></h2>
<ol>
<li>常见消息中间件
<ul>
<li>Kafka
<ul>
<li>吞吐量最高，适合大数据</li>
</ul>
</li>
<li>rocketMQ
<ul>
<li>QPS 出自alibaba，性能10w+</li>
</ul>
</li>
<li>activeMQ
<ul>
<li>已淘汰，吞吐量较低</li>
</ul>
</li>
<li>rabbitMQ    使用<strong>AMQP</strong>协议
<ul>
<li>社区活跃度高，性能稳定  <em>响应速度唯一达到纳秒</em></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="rabbitmq应用场景"><em>RabbitMQ</em>应用场景</h3>
<ul>
<li>
<p>通过<em>NIO</em>异步处理短时间能高流量涌入服务器的线程， 解决流量高峰期的响应速度减慢以及系统崩溃。</p>
</li>
<li>
<p>对系统解耦</p>
</li>
<li>
<p>通过Exchange交换发送消息队列</p>
<ul>
<li>
<p><strong>Topic</strong> [动态路由规则]</p>
<blockquote>
<p><strong>*</strong> 表示一个且只有一个单词  <strong>#</strong> 表示0到任意个</p>
</blockquote>
</li>
<li>
<p><strong>fanout</strong> [广播类型 一对多]</p>
</li>
<li>
<p><strong>direct</strong> [一对一]</p>
</li>
<li>
<p><strong>workqueue</strong> [按需分配]</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语句执行慢的原因？]]></title>
        <id>https://geckoc.github.io/post/sql-yu-ju-zhi-xing-man-de-yuan-yin/</id>
        <link href="https://geckoc.github.io/post/sql-yu-ju-zhi-xing-man-de-yuan-yin/">
        </link>
        <updated>2021-04-02T00:56:05.000Z</updated>
        <content type="html"><![CDATA[<p>这是在某一公众号看到的腾讯面试，觉得十分受用<br>
首先要分类讨论，一条SQL语句慢分为</p>
<ul>
<li>大多数情况下执行速度正常，偶尔出现执行变慢</li>
<li>一直执行速度都很慢</li>
</ul>
<hr>
<ul>
<li>
<h2 id="针对偶尔很慢的情况">针对偶尔很慢的情况</h2>
<ul>
<li>那么原因可能就不是出现在SQL语句本身，而是其他方面因素导致的</li>
</ul>
</li>
</ul>
<p><em>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去</em></p>
<h3 id="数据库在刷新脏页flush">数据库在<strong>刷新脏页</strong>（flush）</h3>
<blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
</blockquote>
<ul>
<li>刷脏页有以下4种场景</li>
</ul>
<p>A. <strong>redo log日志满了</strong></p>
<p>redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</p>
<p>B. <strong>内存不够用了</strong></p>
<p>如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时 候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</p>
<p>C. <strong>MySQL 认为系统“空闲”的时候</strong></p>
<p>这时系统没什么压力。</p>
<p>D. <strong>MySQL 正常关闭的时候</strong></p>
<p>这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
<h3 id="拿不到锁我能怎么办">拿不到锁我能怎么办</h3>
<p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p>
<p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p>
<p>下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的</p>
<h2 id="一直执行速度都很慢">一直执行速度都很慢</h2>
<p><em>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 SQL 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</em></p>
<p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p>
<pre><code class="language-mysql">mysql&gt; CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
</code></pre>
<p>没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p>
<pre><code class="language-mysql">select * from t where 100 &lt; c and c &lt; 100000;
</code></pre>
<ul>
<li>
<p><strong>没有使用索引</strong></p>
<ul>
<li>刚好你的 c 字段上没有索引，那么抱歉，只能走全表扫描了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</li>
</ul>
</li>
<li>
<p><strong>有索引，但未引用到</strong></p>
<pre><code class="language-mysql"># 在where子句后的字段，对字段进行进行了运算操作，会导致索引失效
select * from table where b-1 = 1000;
# 应该为 select * from table where b = 1000 + 1;
# 在where子句后的字段，使用了SQL函数()
select * from table where substring(name,1,3)='abc';
# 正确应该 select * from table where name = 'abc%';
</code></pre>
</li>
<li>
<p>数据库自己选错索引选错了**</p>
<p>我们在进行查询操作的时候，例如</p>
<pre><code class="language-mysql">select * from t where 100 &lt; c and c &lt; 100000;
</code></pre>
</li>
</ul>
<p>我们知道，主键索引和非主键索引的有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。<br>
也就是说，如果走的是c这个字段的索引，最后会找到主键字段的值，然后根据主键字段的值走主键索引，查询到整行字段的数据。</p>
<p>但是，就算是C字段上有索引，系统也不一定走C字段索引，而是有可能直接扫描全表</p>
<p><strong>为什么呢</strong>？</p>
<p>其实是这样，系统在执行这条语句前，会进行预测，究竟是走C索引扫描的行数少，还是全表扫描的行数少？因为扫描行数少当然是越好的，意味着I/O操作的次数越少。</p>
<p>​       如果扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为n ;</p>
<p>而如果走索引C的话，我们通过索引c找到主键字段的值，再通过主键字段的值找到主键索引来找我们的整行数据，也就是说需要找两次索引，而且我们也不知道 100&lt;c and c &lt; 10000 这个条件的数据有多少行，万一是这个表的所有数据都符合呢？就意味着走c索引不仅扫描的行数是n，同时还得每行数据走两次索引。</p>
<p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p>
<p>判断是来自系统的预测，也就是说，如果要走C索引，系统会预测走c字段索引大概要扫描多少行，如果预测数据多的话，则很可能直接不走索引直接全表扫描了</p>
<p><strong>问题是：系统是如何预测的呢?</strong></p>
<p>系统是根据 <strong>索引的区分度</strong> 来预测的，一个索引上不同的值越多，<strong>索引的区分度</strong>越高，意味着出现相同数值的索引越少，我们也把索引区分度称之为 <strong>基数</strong>，即区分度越高，基数越大。</p>
<p>基数越大，那么符合 100 &lt; c and c &lt; 10000的条件行数就越少。</p>
<p>一个索引的基数越大，意味着走索引查询越有优势。</p>
<p>那么系统是如何知道这个索引的基数呢？</p>
<p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p>
<p><strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p>
<p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p>
<blockquote>
<p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p>
</blockquote>
<p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p>
<pre><code class="language-mysql">select * from t force index(a) where c &lt; 100 and c &lt; 100000;
</code></pre>
<p>我们也可以通过</p>
<pre><code class="language-mysql">show index from t;
</code></pre>
<p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p>
<pre><code class="language-mysql">analyze table t;
</code></pre>
<p>来重新统计分析。</p>
<p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p>
<p>好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。</p>
<p><strong>四、总结</strong></p>
<p>以上是我的总结与理解，最后一个部分，我怕很多人不大懂<strong>数据库居然会选错索引</strong>，所以我详细解释了一下，下面我对以上做一个总结。</p>
<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FastDFS On Java]]></title>
        <id>https://geckoc.github.io/post/fastdfs-on-java/</id>
        <link href="https://geckoc.github.io/post/fastdfs-on-java/">
        </link>
        <updated>2021-03-25T00:41:47.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="在java工程中操作fastdfs实现上传下载替换删除">在Java工程中操作FastDFS实现上传下载替换删除...</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="在java工程中操作fastdfs实现上传下载替换删除">在Java工程中操作FastDFS实现上传下载替换删除...</h2>
<!-- more -->
<h3 id="fastdfs依赖">FastDFS依赖</h3>
<h2 id="从-官方源码上下载fastdfs源代码到本地再通过命令-mvn-clean-install-编译打包导入-maven-本地仓库使用即可">从 <a href="https://codeload.github.com/happyfish100/fastdfs-client-java/zip/master">官方源码</a>上下载FastDFS源代码到本地<br>
再通过命令 mvn clean install 编译打包导入 Maven 本地仓库使用即可。<br>
<img src="https://geckoc.github.io//post-images/1616641994193.png" alt="" loading="lazy"></h2>
<h3 id="创建工程">创建工程</h3>
<figure data-type="image" tabindex="1"><img src="https://geckoc.github.io//post-images/1616634040489.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://geckoc.github.io//post-images/1616642202855.png" alt="" loading="lazy"></figure>
<h3 id="添加依赖-poxxml">添加依赖  pox.xml</h3>
<p>在项目的 pom.xml 中添加以下需要用到的依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt; 
    &lt;!--FastDFS的java客户端依赖--&gt;
    &lt;dependency&gt; 
      &lt;groupId&gt;org.csource&lt;/groupId&gt;  
      &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;  
      &lt;version&gt;1.27-SNAPSHOT&lt;/version&gt; 
    &lt;/dependency&gt;
    &lt;!-- apache commons lang3 工具包 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
      &lt;version&gt;3.11&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt; 
</code></pre>
<h3 id="编辑配置文件-fdfs_clientconf">编辑配置文件 fdfs_client.conf</h3>
<p>在github下载的fastdfs-client-java-master中解压缩后进入有一个fdfs_client.conf<br>
将其copy到项目中</p>
<pre><code>connect_timeout = 2
network_timeout = 30
# 字符集
charset = UTF-8
# tracker 服务器 HTTP 协议下暴露的端口
http.tracker_http_port = 8080
http.anti_steal_token = no
http.secret_key = FastDFS1234567890
# tracker 服务器的ip和端口
tracker_server = 192.168.182.128:22122
#tracker_server = 10.0.11.248:22122
#tracker_server = 10.0.11.249:22122
</code></pre>
<h3 id="创建工具类">创建工具类</h3>
<p>获取元数据时，如果你上传时没有给定元数据，则获取不到<br>
可在文件上传时给定元数据<br>
NameValuePair[] metaList = null;<br>
// 第一组元数据，文件的原始名称<br>
metaList[0] = new NameValuePair(&quot;file_name&quot;, fileName);<br>
// 第二组元数据...等等<br>
metaList[1] = new NameValuePair(&quot;file_length&quot;, fileLen);</p>
<pre><code class="language-java">package com.gecko.fastdfs.util;

import org.apache.commons.lang3.StringUtils;
import org.csource.common.MyException;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.*;

import java.io.File;
import java.io.IOException;

/**
 * FastDFS 分布式文件系统 Java 客户端工具类
 * 具体功能：文件上传、下载、替换、删除、查询文件元数据、查看文件详情
 */
public class FastDFSUtils {
    private static TrackerServer trackerServer = null;
    private static StorageServer storageServer = null;
    private static StorageClient storageClient = null;

    static {
        //1.加载配置文件，默认去classpath下加载
        try {
            ClientGlobal.init(&quot;fdfs_client.conf&quot;);
        //2.创建TrackerClient对象
        TrackerClient trackerClient = new TrackerClient();
        //3.创建TrackerServer对象
            trackerServer = trackerClient.getConnection();
        //4.创建StorageServer对象
            storageServer = trackerClient.getStoreStorage(trackerServer);
            //5.创建StorageClient对象，这个对象完成对文件的操作
            storageClient = new StorageClient(trackerServer, storageServer);
        } catch (IOException | MyException e) {
            e.printStackTrace();
        }
    }

    /**
     * 资源释放
     */
    public static void releaseFastDFS() {
        if (storageServer != null) {
            try {
                storageServer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (trackerServer != null) {
            try {
                trackerServer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * 文件上传
     * @param localFileName 本地文件名[具体位置+文件名]
     * @param fileExtName   上传文件的后缀
     */
    public static void fileUpload(String localFileName, String fileExtName) {
        try {
            //6.上传文件  第一个参数：本地文件路径 第二个参数：上传文件的后缀 第三个参数：文件信息
            String[] uploadArray = storageClient.upload_file(localFileName, fileExtName, null);
            for (String str : uploadArray) {
                System.out.println(str);
                // http:192.168.182.128/group1/M00/00/00/wKi2gGBas4aAEAdlACoeC5KngBs554.jpg
            }
        } catch (IOException | MyException e) {
            e.printStackTrace();
        } finally {
            releaseFastDFS();
        }
    }

    /**
     * 文件上传
     * @param bytes            byte字节数组
     * @param fileExtName      文件拓展名[后缀]
     * @return 组名/远程文件名   group1/M00/00/00/....
     */
    public static String fileUpload(byte[] bytes, String fileExtName) {
        try {
            String[] uploadFile = storageClient.upload_file(bytes, fileExtName, null);
            for (String str : uploadFile) {
                System.out.println(str);
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(&quot;http://192.168.182.128/&quot;);
            stringBuilder.append(uploadFile[0]);
            stringBuilder.append(&quot;/&quot;);
            stringBuilder.append(uploadFile[1]);
            return stringBuilder.toString();
        } catch (IOException | MyException e) {
            e.printStackTrace();
        } finally {
            releaseFastDFS();
        }
        return null;
    }

    /**
     * 文件下载
     * @param groupName       组/卷名，默认值：group1
     * @param remoteFileName  文件名，例如：&quot;M00/00/00/wKgKZl9tkTCAJAanAADhaCZ_RF0495.jpg&quot;
     * @param localFileName   本地文件位置  D:/222.jpg
     * @return 0为成功 ，非0为失败
     */
    public static int fileDownload(String groupName, String remoteFileName, String localFileName){

        int count = -1;
        try {
            count = storageClient.download_file(groupName == null ? &quot;group1&quot; : groupName, remoteFileName, localFileName);
            System.out.println(&quot;downloadFile : &quot; + count);
        } catch (IOException | MyException e) {
            e.printStackTrace();
        } finally {
            releaseFastDFS();
        }
        return count;
    }
    /**
     * 文件下载
     * @param groupName       组/卷名，默认值：group1
     * @param remoteFileName  文件名，例如：&quot;M00/00/00/wKgKZl9tkTCAJAanAADhaCZ_RF0495.jpg&quot;
     * @return byte[]       文件字节数组
     */
    public static byte[] fileDownload(String groupName, String remoteFileName) {
        byte[] bytes = null;
        try {
             bytes = storageClient.download_file(groupName, remoteFileName);
        } catch (IOException | MyException e) {
            e.printStackTrace();
        } finally {
            releaseFastDFS();
        }
        return bytes;
    }
    /**
     * 文件删除
     *
     * @param groupName      组/卷名，默认值：group1
     * @param remoteFileName 文件名，例如：&quot;M00/00/00/wKgKZl9tkTCAJAanAADhaCZ_RF0495.jpg&quot;
     * @return 0为成功 true，非0为失败 false
     */
    public static boolean fileDelete(String groupName, String remoteFileName) {
        int delete_file = -1;
        try {
            delete_file = storageClient.delete_file(groupName, remoteFileName);
            System.out.println(&quot;deleteCount : &quot; + delete_file);
        } catch (IOException | MyException e) {
            e.printStackTrace();
        } finally {
            releaseFastDFS();
        }
        return delete_file == 0;
    }

    /**
     * 修改一个已经存在的文件
     *
     * @param oldGroupName 旧组名
     * @param oldFileName  旧文件名
     * @param bytes         新文件
     * @param fileName     新文件名
     * @return
     */
    public static String modifyFile(String oldGroupName, String oldFileName, byte[] bytes, String fileName) {
        // 先上传
        String fileUpload = fileUpload(bytes, fileName);
        if (fileUpload == null) {
            return null;
        }
        // 再删除
        boolean delResult = fileDelete(oldGroupName, oldFileName);
        if (delResult) {
            return null;
        }
        return fileUpload;
    }
    /**
     * 获取元数据
     *
     * @param groupName      组/卷名，默认值：group1
     * @param remoteFileName 文件名，例如：&quot;M00/00/00/wKgKZl9tkTCAJAanAADhaCZ_RF0495.jpg&quot;
     * @return 文件的元数据数组
     */
    public static NameValuePair[] getMetaData(String groupName, String remoteFileName) {
        try {
            // 根据组名和文件名通过 Storage 客户端获取文件的元数据数组
            return storageClient.get_metadata(groupName == null ? &quot;group1&quot; : groupName, remoteFileName);
        } catch (IOException | MyException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 获取文件详情
     *
     * @param groupName      组/卷名，默认值：group1
     * @param remoteFileName 文件名，例如：&quot;M00/00/00/wKgKZl9tkTCAJAanAADhaCZ_RF0495.jpg&quot;
     * @return 文件详情
     */
    public static FileInfo getFileInfo(String groupName, String remoteFileName) {
        try {
            return storageClient.get_file_info(groupName == null ? &quot;group1&quot; : groupName, remoteFileName);
        } catch (IOException | MyException e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * 获取文件后缀名（不带点）
     *
     * @param fileName 文件名称
     * @return 如：&quot;jpg&quot; or &quot;&quot;
     */
    public static String getFileExt(String fileName) {
        if (StringUtils.isBlank(fileName) || !fileName.contains(&quot;.&quot;)) {
            return &quot;&quot;;
        }
        return fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1); // 不带最后的点
    }

    /**
     * 获取文件后缀名（带点）
     *
     * @param fileName 文件名称
     * @return 如：&quot;.jpg  .gif&quot; or &quot;&quot;
     */
    public static String getFileExtWithPoint(String fileName) {
        if (StringUtils.isBlank(fileName) || !fileName.contains(&quot;.&quot;)) {
            return &quot;&quot;;
        }
        return fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 带最后的点
    }

}
</code></pre>
<h3 id="测试">测试</h3>
<p>在下面创建main方法测试或单元测试  finish</p>
<pre><code class="language-java">    public static void main(String[] args) {
        fileDownload(&quot;group1&quot;, &quot;M00/00/00/wKi2gGBatYiASR5EACoeC5KngBs842.jpg&quot;, &quot;D:/888.jpg&quot;);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PathVariable和RequestParam]]></title>
        <id>https://geckoc.github.io/post/pathvariable-he-requestparam/</id>
        <link href="https://geckoc.github.io/post/pathvariable-he-requestparam/">
        </link>
        <updated>2021-03-09T10:16:20.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>在Spring中的两个注解 <strong>@PathVariable</strong>  ---- <strong>@RequestParam</strong>
<ul>
<li>我们可以从请求中获取查询参数，表单参数甚至文件</li>
<li><strong>@RequestParam</strong>和**@PathVariable**都能够完成类似的功能——因为本质上，它们都是用户的输入，只不过输入的部分不同，一个在URL路径部分，另一个在参数部分。<br>
事实上，这两种URL设计都是可以的：</li>
</ul>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>在Spring中的两个注解 <strong>@PathVariable</strong>  ---- <strong>@RequestParam</strong>
<ul>
<li>我们可以从请求中获取查询参数，表单参数甚至文件</li>
<li><strong>@RequestParam</strong>和**@PathVariable**都能够完成类似的功能——因为本质上，它们都是用户的输入，只不过输入的部分不同，一个在URL路径部分，另一个在参数部分。<br>
事实上，这两种URL设计都是可以的：</li>
</ul>
</li>
</ul>
<!-- more -->
<ul>
<li>
<p>通过**@PathVariable**，例如/blogs/1</p>
</li>
<li>
<p>通过**@RequestParam**，例如blogs?blogId=1</p>
</li>
<li>
<p>根据不同应用场景来选择使用：</p>
<ul>
<li>当<em>URL</em>指向的是某一具体业务资源（或资源列表），使用**@PathVariable**</li>
<li>当<em>URL</em>需要对资源或者资源列表进行过滤，筛选时，使用**@RequestParam**</li>
</ul>
</li>
</ul>
<hr>
<h3 id="参数的属性值">参数的属性值</h3>
<ol>
<li><strong>name</strong> (指定请求参数名称)<br>
+ 在变量名称和参数名称都相同的情况则不需制定。但有时我们希望这些不同。或者，如果我们不使用Spring Boot，我们可能需要进行特殊的编译时配置，否则参数名称实际上不会在编译后的字节码中</li>
</ol>
<pre><code class="language-java">    @GetMapping(&quot;/user/play&quot;)
    @ResponseBody
    public String toLoanInfo(@RequestParam(name = &quot;id&quot;) String userId, @RequestParam name){

        return &quot;play: &quot; + userId + name;
    }
</code></pre>
<ol start="2">
<li><strong>value</strong>
<ul>
<li>@RequestParam（value =“id”）等同于 @RequestParam（“id”）</li>
</ul>
</li>
<li><strong>required</strong>
<ul>
<li>一旦我们在方法中定义了@RequestParam变量，如果访问的uri中不带有相应的参数，就会抛出异常——这是显然的，Spring尝试帮我们进行绑定，然而没有成功。但有的时候，参数确实不一定永远都存在，这时我们可以通过定义required属性，我们可以将@RequestParam的required设置为false ，默认为true（必选）：</li>
</ul>
</li>
</ol>
<pre><code class="language-java">    @GetMapping(&quot;/user/play&quot;)
    @ResponseBody
    public String toLoanInfo(@RequestParam(required = false) String id){

        return &quot;play: &quot; + id;
    }
</code></pre>
<ol start="4">
<li><strong>defaultValue</strong>
<ul>
<li>在参数不存在的情况下，可能希望变量有一个默认值</li>
</ul>
</li>
</ol>
<p><code>@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;)</code></p>
<p>注意：在使@PathVariable成为可选时我们应该小心，以避免路径冲突。</p>
<p>在<strong>SpringBoot</strong>的<em>Thymeleaf</em>表达式中，使用@PathVariable需要符合其URL风格</p>
<pre><code class="language-html">  &lt;!-- Restful Style 需要 + 号拼接，路径后的斜杠不能忽略 --&gt;
  &lt;a th:href=&quot;@{'/user/play/'+拼接的参数}&quot;&gt;跳转&lt;/a&gt;
  &lt;!-- Normal Style --&gt;
  &lt;a th:href=&quot;@{/user/play(id=&quot;id&quot;,name=&quot;name&quot;)}&quot;&gt;跳转&lt;/a&gt;
</code></pre>
<p>而**@PathVariable**中使用required=false 还需要注意的是：当参数不存在时，需要配置多个uri映射，避免404</p>
<pre><code class="language-java">@GetMapping({&quot;/user/play/{productType}&quot;,&quot;/user/play/&quot;})
public String toLoanInfo(@PathVariable(required = false) Integer productType){
        return &quot;play&quot;;
}
</code></pre>
<hr>
<h4 id="拓展">拓展</h4>
<h5 id="uri编码">URI编码</h5>
<blockquote>
<p>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。US-ASCII字符集中没有对应的可打印字符：Url中只允许使用可打印字符。US-ASCII码中的10-7F字节全都表示控制字符，这些字符都不能直接出现在Url中。同时，对于80-FF字节（ISO-8859-1），由于已经超出了US-ACII定义的字节范围，因此也不可以放在Url中。</p>
</blockquote>
<blockquote>
<p>保留字符：Url可以划分成若干个组件，协议、主机、路径等。有一些字符（😕?#[]@）是用作分隔不同组件的。例如：冒号用于分隔协议和主机，/用于分隔主机和路径，?用于分隔路径和查询参数，等等。还有一些字符（!$&amp;’()*+,;=）用于在每个组件中起到分隔作用的，如=用于表示查询参数中的键值对，&amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行编码。RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ]</p>
</blockquote>
<p>感兴趣可以做个测试：<strong>@PathVariable</strong>和**@RequestParam<strong>两种注解的编码问题<br>
<strong>@PathVariable</strong> 从路径中获取是不用编码解码的，而</strong>@RequestParam**会进行编码解码。这种特性很少有人注意到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot-SSM-Redis-Dubbo集成]]></title>
        <id>https://geckoc.github.io/post/springboot-ssm-redis-dubbo-ji-cheng/</id>
        <link href="https://geckoc.github.io/post/springboot-ssm-redis-dubbo-ji-cheng/">
        </link>
        <updated>2021-03-02T11:50:43.000Z</updated>
        <summary type="html"><![CDATA[<h5 id="主要记录一些主要步骤">主要记录一些主要步骤：</h5>
<ul>
<li>在配置中，需要开启的服务有mysql、redis、zookeeper</li>
<li>在Linux开启，也可在windows本地开启，需要注意的是相应地址填写正确即可</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h5 id="主要记录一些主要步骤">主要记录一些主要步骤：</h5>
<ul>
<li>在配置中，需要开启的服务有mysql、redis、zookeeper</li>
<li>在Linux开启，也可在windows本地开启，需要注意的是相应地址填写正确即可</li>
</ul>
<!-- more -->
<p>总结：</p>
<ol>
<li>
<p>接口工程 [MavenJava]</p>
<ul>
<li>存放接口以及实体类</li>
</ul>
</li>
<li>
<p>服务提供者工程 [SpringBootWeb]</p>
<ul>
<li>
<p>接口实现类：[需加上@Component]</p>
<ul>
<li>@Service注解使用阿里协议下的，指定暴露服务接口的interfaceClass或interfaceName</li>
</ul>
</li>
<li>
<p>依赖：</p>
<ul>
<li>MySQL、MyBatis、Redis、Dubbo、Zookeeper<br>
-【接口工程】Mybatis逆向工程创建完成后导入，否则生成失败</li>
</ul>
</li>
<li>
<p>插件配置:</p>
<ul>
<li>mybatis逆向工程插件<br>
<strong>mybatis要求mapper和mapper.xml放在一个文件,springboot要求资源文件放在resources下,所以还要在pom.xml文件下手动指定编译资源文件</strong></li>
</ul>
</li>
<li>
<p>application.properties配置</p>
<ul>
<li>内嵌Tomcat端口号 上下文根</li>
<li>MySQL数据源连接信息</li>
<li>Dubbo配置：
<ul>
<li>spring.application.name[唯一标识 服务名称]</li>
<li>spring.dubbo.serve=true[指定工程为服务提供者]</li>
<li>spring.dubbo.registry=zookeeper://localhost:2181[注册中心地址]</li>
</ul>
</li>
<li>配置Redis端口号</li>
<li>配置Redis指定地址</li>
</ul>
</li>
<li>
<p>在主程序类添加@MapperScan()  (包扫描注解)</p>
</li>
<li>
<p>在主程序类添加@EnableDubboConfiguration (dubbo注解支持)</p>
</li>
</ul>
</li>
<li>
<p>消费者工程  [SpringBootWeb]</p>
<ul>
<li>
<p>依赖</p>
<ul>
<li>dubbo、zookeeper、接口工程</li>
</ul>
</li>
<li>
<p>application.properties配置</p>
<ul>
<li>
<p>dubbo</p>
<ul>
<li>spring.application.name[唯一标识 服务名称]</li>
<li>spring.dubbo.registry=zookeeper://localhost:2181[注册中心地址]</li>
</ul>
</li>
<li>
<p>配置Redis端口号</p>
</li>
<li>
<p>配置Redis指定地址</p>
</li>
</ul>
</li>
<li>
<p>Controller下注入使用阿里协议的@reference注解</p>
<ul>
<li>与服务提供者中的interfaceClass/interfaceName保持一致</li>
</ul>
</li>
<li>
<p>在主程序类添加@EnableDubboConfiguration (dubbo注解支持)</p>
</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li>
<p>model类需要实现序列化接口</p>
</li>
<li>
<p>如果要使用访问JSP  需要添加解析JSP依赖，且配置视图解析器</p>
<ul>
<li>解析JSP的依赖 SpringBoot内嵌Tomcat对jsp的解析依赖</li>
</ul>
<pre><code class="language-xml"> &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
 &lt;/dependency&gt;  
</code></pre>
<ul>
<li>视图解析器</li>
</ul>
<pre><code class="language-xml">spring.mvc.view.prefix=/
spring.mvc.view.suffix=.jsp
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis存取Hash对象]]></title>
        <id>https://geckoc.github.io/post/redis-cun-qu-hash-dui-xiang/</id>
        <link href="https://geckoc.github.io/post/redis-cun-qu-hash-dui-xiang/">
        </link>
        <updated>2021-02-27T12:32:46.000Z</updated>
        <summary type="html"><![CDATA[<p>在开发中，使用Redis缓存缓解MySQL数据库的压力，在存取Hash时遇到的问题</p>
<ul>
<li>StringRedisSerializer()不支持多种类型的存储</li>
<li>必须设置序列化方式，否则无法匹配序列化后的key</li>
<li>存取对象的两种方法 实体类需实现序列化接口
<ul>
<li>根据ID查询对象</li>
<li>
<ol>
<li>使用boundHashOps(String.valueOf(id)).entries();</li>
</ol>
</li>
<li>
<ol start="2">
<li>使用redisTemplate.opsForHash().entries(String.valueOf(id));</li>
</ol>
</li>
<li>entries() 从redis中获取map数据 键值对</li>
</ul>
</li>
<li>其他方案待更新</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>在开发中，使用Redis缓存缓解MySQL数据库的压力，在存取Hash时遇到的问题</p>
<ul>
<li>StringRedisSerializer()不支持多种类型的存储</li>
<li>必须设置序列化方式，否则无法匹配序列化后的key</li>
<li>存取对象的两种方法 实体类需实现序列化接口
<ul>
<li>根据ID查询对象</li>
<li>
<ol>
<li>使用boundHashOps(String.valueOf(id)).entries();</li>
</ol>
</li>
<li>
<ol start="2">
<li>使用redisTemplate.opsForHash().entries(String.valueOf(id));</li>
</ol>
</li>
<li>entries() 从redis中获取map数据 键值对</li>
</ul>
</li>
<li>其他方案待更新</li>
</ul>
<!-- more -->
<h3 id="使用boundhashops">使用boundHashOps</h3>
<pre><code class="language-java">@Component
@Service(interfaceClass = StudentService.class, timeout = 24000, version = &quot;1.0.0&quot;)
public class StudentServiceImpl implements StudentService {

    @Resource
    private StudentMapper studentMapper;
    @Resource
    private RedisTemplate&lt;Object,Object&gt; redisTemplate;

    public Map&lt;Object, Object&gt; queryStudentById(Integer id) {
        // 设置 redisTemplate 对象 key 的序列化方式
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        // 先从Redis缓存中查找获取，没有则从MySQL数据中查找并获取
        // entries() 从redis中获取map数据 键值对
        Map&lt;Object, Object&gt; student = redisTemplate.boundHashOps(String.valueOf(id)).entries();
        assert student != null;
        //  如果为空(第一次查询) 则去数据库查询并存放到Redis缓存中
        if (student.size() == 0 ){
            student = studentMapper.selectByKey(id);
            redisTemplate.boundHashOps(String.valueOf(id)).put(&quot;id&quot;,student.get(&quot;id&quot;));
            redisTemplate.boundHashOps(String.valueOf(id)).put(&quot;name&quot;,student.get(&quot;name&quot;));
            redisTemplate.boundHashOps(String.valueOf(id)).put(&quot;age&quot;,student.get(&quot;age&quot;));
            // 设置有效时间 不设置则永久保存
            redisTemplate.expire(String.valueOf(id),2, TimeUnit.MINUTES);
        }
        return student;
    }
}
</code></pre>
<hr>
<h3 id="使用opsforhash">使用opsForHash</h3>
<pre><code class="language-java">@Component
@Service(interfaceClass = StudentService.class, timeout = 24000, version = &quot;1.0.0&quot;)
public class StudentServiceImpl implements StudentService {

    @Resource
    private StudentMapper studentMapper;
    @Resource
    private RedisTemplate&lt;Object,Object&gt; redisTemplate;

 public Map&lt;Object, Object&gt; queryStudentById(Integer id) {
        // 设置key序列化规则
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        // 先从redis缓存中获取数据
        Map&lt;Object, Object&gt; student = redisTemplate.opsForHash().entries(String.valueOf(id));
        // 第一次访问，redis缓存中没有数据，则从MySQL数据库中取
        if (student.size() == 0){
            student = studentMapper.selectByKey(id);
        // 数据存到redis缓存中
           redisTemplate.opsForHash().put(String.valueOf(id),&quot;id&quot;,student.get(&quot;id&quot;));
           redisTemplate.opsForHash().put(String.valueOf(id),&quot;name&quot;,student.get(&quot;name&quot;));
           redisTemplate.opsForHash().put(String.valueOf(id),&quot;age&quot;,student.get(&quot;age&quot;));
        // 设置有效时间  不设置则永久保存
           redisTemplate.expire(id,60,TimeUnit.SECONDS);
        }
        return student;
    }
 }
</code></pre>
<p>设置 redisTemplate 对象 key 的序列化方式,Put时key已经序列化，必须设置<br>
否则每次boundHashOps(String.valueOf(id))返回的都是新的Hash</p>
<ul>
<li>StringRedisSerializer
<ul>
<li>只能存储类型为String的value，当存储其他类型的数据时，则无法将value保存到Redis，必须转为String</li>
</ul>
</li>
</ul>
<p>网上查询参考：<br>
使用JackSon2JsonRedisSerializer，才能支持存储多种数据类型，避免存储了一些数据之后再进行转换以及历史数据进行处理的麻烦，有待实践</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git：error: failed to push some refs to]]></title>
        <id>https://geckoc.github.io/post/giterror-failed-to-push-some-refs-to/</id>
        <link href="https://geckoc.github.io/post/giterror-failed-to-push-some-refs-to/">
        </link>
        <updated>2021-02-24T09:21:14.000Z</updated>
        <summary type="html"><![CDATA[<p>在一次学习过程中，同时使用tortoiseGit和Git进行远程推送，突然出现错误error: failed to push some refs to</p>
]]></summary>
        <content type="html"><![CDATA[<p>在一次学习过程中，同时使用tortoiseGit和Git进行远程推送，突然出现错误error: failed to push some refs to</p>
<!-- more -->
<p><img src="https://geckoc.github.io//post-images/1614158838487.png" alt="" loading="lazy"><br>
自行Google了一番，这个错误的发生原因还不少</p>
<h2 id="分支名不完整">分支名不完整</h2>
<ul>
<li>要注意的是本地分支名和远程分支名不一样的情况</li>
</ul>
<p><strong>语法如下</strong></p>
<pre><code>git push @remoteName  @localBranch:@remoteBranch
// eg.remoteName:origin  localBranch:localTest  remoteBranch:remoteTest
git push origin localTest:remoteTest
</code></pre>
<ul>
<li>本地分支名与远程分支名一致的情况，可简写，例如：本地远程分支都是master</li>
</ul>
<pre><code>git push origin master
</code></pre>
<p>确认分支名没有写错，继续往下</p>
<h2 id="没有提交代码-commit">没有提交代码  commit</h2>
<p>可以git status 查看代码提交状态 ,忘记提交则提交再push即可</p>
<pre><code>  git add test
  git commit -m &quot;This is a new commit&quot;
  git push origin master
</code></pre>
<h2 id="本地与远程产生冲突">本地与远程产生冲突</h2>
<p><em>这是我产生错误的原因</em></p>
<p>由于使用Git和TortoiseGit同时操作一个工作区，推送同一个远程仓库，导致冲突<br>
可以看到错误hint(提示)  <strong>hint: 'git pull ...') before pushing again.</strong><br>
处理方式一：  先拉取再执行推送</p>
<pre><code>  git pull –-rebase origin maste
  git push origin master
</code></pre>
<p>不推荐使用暴力强制提交，至于 <em>--rebase</em> 有什么作用，是什么意思，不清不楚用起来也忐忑不安；<br>
参考廖雪峰老师的文章 ：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648">rebase &quot;变基&quot;</a></p>
<ul>
<li>
<p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
</li>
<li>
<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</li>
</ul>
<p>处理方式二：强制提交 (不推荐使用)</p>
<pre><code class="language-git">  git push -f origin master
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[禁用或启动笔记本内置键盘]]></title>
        <id>https://geckoc.github.io/post/bi-ji-ben-nei-zhi-jian-pan/</id>
        <link href="https://geckoc.github.io/post/bi-ji-ben-nei-zhi-jian-pan/">
        </link>
        <updated>2021-01-07T01:21:58.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-禁用内置键盘触摸板">1. 禁用内置键盘&amp;触摸板</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-禁用内置键盘触摸板">1. 禁用内置键盘&amp;触摸板</h4>
<!-- more -->
<p>启动管理员命令行(Win+x)，选择windowsPowershe(管理员)  (命令提示符)</p>
<figure data-type="image" tabindex="1"><img src="https://geckoc.github.io//post-images/1609982577853.png" alt="" loading="lazy"></figure>
<p>在打开的窗口中：输入cmd，并敲击回车</p>
<p>然后输入 sc config i8042prt start= disabled</p>
<p>提示成功后重启电脑即可，开启则是把disabled换成auto</p>
<p>sc config i8042prt start= disabled (关)</p>
<p>sc config i8042prt start= auto(开)</p>
<figure data-type="image" tabindex="2"><img src="https://geckoc.github.io//post-images/1609982602898.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql无法启动Plugin FEDERATED is disabled]]></title>
        <id>https://geckoc.github.io/post/mysql-plugin-federated-is-disabled/</id>
        <link href="https://geckoc.github.io/post/mysql-plugin-federated-is-disabled/">
        </link>
        <updated>2021-01-07T01:17:53.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mysql无法启动plugin-federated-is-disabled完美解决">Mysql无法启动Plugin FEDERATED is disabled完美解决</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mysql无法启动plugin-federated-is-disabled完美解决">Mysql无法启动Plugin FEDERATED is disabled完美解决</h2>
<!-- more -->
<blockquote>
<p>WampServer , MySQL 5.5.8</p>
<p>电脑意外关机后，服务启动失败，自动关闭</p>
<p>查看了mysql.log 错误日志</p>
</blockquote>
<pre><code class="language-clojure">201211  0:52:24 [Note] Plugin 'FEDERATED' is disabled.
InnoDB: The InnoDB memory heap is disabled
InnoDB: Mutexes and rw_locks use Windows interlocked functions
InnoDB: Compressed tables use zlib 1.2.3
201211  0:52:24  InnoDB: Error: unable to create temporary file; errno: 2
201211  0:52:24 [ERROR] Plugin 'InnoDB' init function returned error.
201211  0:52:24 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
201211  0:52:24 [ERROR] Unknown/unsupported storage engine: InnoDB
201211  0:52:24 [ERROR] Aborting

201211  0:52:24 [Note] wampmysqld: Shutdown complete
</code></pre>
<p>以上</p>
<p>网上找到方法,在My.ini文件中的[mysqld]中增加一行</p>
<p>我的是[wampmysqld]</p>
<p>tmpdir=d:/wamp/tmp</p>
<p>[mysqld]  增加一行，注意是 mysqld</p>
<p>federated</p>
<p>重启服务成功</p>
<pre><code class="language-clojure">201214  8:36:43  InnoDB: Initializing buffer pool, size = 128.0M
201214  8:36:43  InnoDB: Completed initialization of buffer pool
201214  8:36:43  InnoDB: highest supported file format is Barracuda.
201214  8:36:48  InnoDB: 1.1.4 started; log sequence number 1785000
201214  8:36:51 [Note] Event Scheduler: Loaded 0 events
201214  8:36:51 [Note] wampmysqld: ready for connections.
Version: '5.5.8-log'  socket: ''  port: 3306  MySQL Community Server (GPL)
</code></pre>
<p>顺便记下</p>
<p>skip-external-locking</p>
<p>skip-name-resolve</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JQuerySummary]]></title>
        <id>https://geckoc.github.io/post/jquerysummary/</id>
        <link href="https://geckoc.github.io/post/jquerysummary/">
        </link>
        <updated>2021-01-06T13:38:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="文本操作">文本操作</h3>
<p>html()//取得第一个匹配元素的html内容，包含标签内容<br>
html(val)//设置所有匹配元素的html内容，识别标签，能够表现出标签的效果</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="文本操作">文本操作</h3>
<p>html()//取得第一个匹配元素的html内容，包含标签内容<br>
html(val)//设置所有匹配元素的html内容，识别标签，能够表现出标签的效果</p>
<!-- more -->
<p>text()// 取得所有匹配元素的内容，只有文本内容，没有标签<br>
text(val)//设置所有匹配元素的内容，不识别标签，将标签作为文本插入进去<br>
示例:</p>
<pre><code class="language-javascript">$('.c1').text('&lt;h3&gt;你好,理查德&lt;/h3&gt;');
$('.c1').html('&lt;h3&gt;你好,理查德&lt;/h3&gt;');
</code></pre>
<h3 id="属性操作">属性操作</h3>
<pre><code class="language-javascript">attr(attrName)// 返回第一个匹配元素的属性值
attr(attrName, attrValue)// 为所有匹配元素设置一个属性值
attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值
removeAttr(attrName)// 从每一个匹配的元素中删除一个属性

示例:
	设置单个属性
		$('.c1').attr('xx','oo');
	设置多个属性
		$('.c1').attr({'age':'18','sex':'alex'});
	查看属性
		$('.c1').attr('属性名');
    	$('.c1').attr('xx');
    删除属性
    	$('.c1').removeAttr('xx');

prop -- 针对的是checked\selected\disabled..

查看标签是否有checked属性,也就是是否被选中
	    attr $(':checked').attr('checked'); //checked -- undefined
	    prop $(':checked').prop('checked'); //true  -- false
		
		通过设置属性的方式来设置是否选中:
			$(':radio').eq(2).prop('checked',true);  true和false不能加引号
			$(':radio').eq(2).prop('checked',false);

简单总结:
	1.对于标签上有的能看到的属性和自定义属性都用attr
	2.对于返回布尔值的比如checkbox、radio和option的是否被选中或者设置其被选中与取消选中都用prop。
	具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()
</code></pre>
<h3 id="文档处理">文档处理</h3>
<pre><code class="language-javascript">添加到指定元素内部的后面
	$(A).append(B)// 把B追加到A
	$(A).appendTo(B)// 把A追加到B
	#添加字符串照样能识别标签
	$('#d1').append('&lt;a href=&quot;http://www.jd.com&quot;&gt;京东&lt;/a&gt;');
添加到指定元素内部的前面
	$(A).prepend(B)// 把B前置到A
	$(A).prependTo(B)// 把A前置到B
	示例
		$('a').prependTo($('div'));

添加到指定元素外部的后面
	$(A).after(B)// 把B放到A的后面
	$(A).insertAfter(B)// 把A放到B的后面

添加到指定元素外部的前面
	$(A).before(B)// 把B放到A的前面
	$(A).insertBefore(B)// 把A放到B的前面
	
移除和清空元素
	remove()// 从DOM中删除所有匹配的元素。
	empty()// 删除匹配的元素集合中所有的子节点，包括文本被全部删除，但是匹配的元素还
	$('div').remove();
	$('div').empty();

替换
	replaceWith()
	replaceAll()
	示例:
		var a = document.createElement('a')
		a.href = 'http://www.baidu.com';
		a.innerText = 'xxx';
		
		$('span').replaceWith(a);
		$(a).replaceAll('span');
		
clone()克隆
	&lt;button class=&quot;btn&quot;&gt;屠龙宝刀,点击就送!&lt;/button&gt;	

    $('.btn').click(function () {
        // var a = $(this).clone(); //克隆标签
        var a = $(this).clone(true);  //连带事件一起克隆
        $(this).after(a);

    })
</code></pre>
<h3 id="常用事件">常用事件</h3>
<pre><code class="language-javascript">&lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;

click(function(){...})
	$('#d1').on('click',function () {
        $(this).css({'background-color':'green'})
    })
hover(function(){...})
	//鼠标悬浮 触发事件
    $('.c1').hover(
        //鼠标放上去
        function () {
            $(this).css({'background-color':'blue'});
        },
        function(){
            $(this).css({'background-color':'black'});
        }
    );


blur(function(){...})
	//失去光标(焦点)时触发事件 使div变色
    $('[type=&quot;text&quot;]').blur(function () {
        $('.c1').css({'background-color':'pink'})
    })
focus(function(){...})  //获取光标时触发事件 使div变色
	$('[type=&quot;text&quot;]').focus(function () {
        $('.c1').css({'background-color':'black'})
    })
                 
change(function(){...}) //内容发生变化，input，select等
	//与内容发改变时触发的事件
    $('select').change(function () {
        $('.c1').toggleClass('cc')
    })


keyup(function(){...})	//键盘抬起触发事件
    $(window).keyup(function (e) {
        console.log(e.keyCode);
    })


keydown(function(){...})	//键盘按键按下事件  参数e/event
	$(window).keydown(function (e) {
        console.log(e.keyCode) //每个键都有一个keycode键 ，通过不同的值触发不同的事件
        if(e.keyCode===37){
            $('.c1').css({'background-color':'green'})
        }else if(e.keyCode===39){
            $('.c1').css({'background-color':'balck'})
        }
        else{
            $('.c1').css({'background-color':'yellow'})
        }
    })


mouseenter(function(){...})	// 鼠标悬浮  等同于hover事件
mouseout(function(){...})
	$('.c1').mouseenter(function () {
        $(this).css({'background-color':'blue'});
    });
    $('.c1').mouseout(function () {
        $(this).css({'background-color':'yellow'});
    });


//鼠标悬浮 只触发一次
    $('.c2').mouseenter(function () {
        console.log('你变了');
    });
//鼠标悬浮  连续触发
    $('.c2').mouseover(function () {
        console.log('你变了');
    })
# mouseover 和 mouseenter的区别是：
# mouseover事件是如果该标签有子标签，
# 那么移动到该标签或者移动到子标签时会连续触发，
# mmouseenter事件不管有没有子标签都只触发一次，表示鼠标进入这个对象
</code></pre>
<h3 id="阻止后续冒泡事件发生">阻止后续（冒泡）事件发生</h3>
<pre><code class="language-javascript">//冒泡的意思就是因为html可以嵌套，如果你给儿子标签绑定了点事件或者没有绑定点击事件，
//父级标签绑定了点击事件，那么你一点击子标签，不管子标签有没有绑定事件，
//都会触发父级标签的点击事件，如果有，会先触发子标签的点击事件，
//然后触发父级标签的点击事件，不管子标签有没有点击事件，都会一级一级的还往上找点击事件

$('#d1').click(function () {
        alert('父级标签')
    })
    $('#d2').click(function (e) {	//这个参数e(只是个形参，写evt或者event名字的也很多)表示当前事件本身，这个事件也是一个对象
        alert('子级标签')
        // return false;	//这个也可以阻止
        e.stopPropagation();//用事件对象的这个方法就能阻止冒泡 （Propagation：传递的意思）
    })
</code></pre>
<h3 id="页面载入">页面载入</h3>
<blockquote>
<p>​	  将js代码写到head标签和写道body标签下面的作用是不同的，写在head标签里面的话，</p>
<p>如果你写了操作某个标签的内容的话，那个标签还没加载出来，先加载了你的js代码，就找不到这个标签，所以不会生效，所以写在body标签最下面是一种解决办法。</p>
<p>还有一种办法就是window.onload=function(){js的代码}，等页面上所有的元素都加载完，在执行这里面的js代码，还记得吗？但是这个window.onload有个缺点；</p>
<p>这个缺点就是这个操作时给window.onload赋值，如果你自己写了两个js文件，每个js文件中都有一个window.onload的话，那么后引入的文件会把前面引入的文件的window.onload里面的js代码全部覆盖掉，那么第一个文件的js代码就失去了效果；</p>
<p>还有一个问题就是，window.onload会等到页面上的文档、图片、视频等所有资源都加载完才执行里面的js代码，导致有些效果的加载比较慢；</p>
<p>所以我们使用下面的写法，不存在覆盖问题，而且只要文档加载完就触发，不需要等着一些图片啊视频啊什么的，加载js效果的速度快。</p>
</blockquote>
<pre><code class="language-javascript">1.jQuery文件要在使用jQuery的代码之前引入
2.js代码最好都放在body标签下面或者里面的最下面

3.window.onload:
	window.onload = function () {
            $('.c1').click(function () {
                $(this).css({'background-color': 'green'});
            })
        }

4.页面载入:
$(function () {
            $('.c1').click(function () {
                $(this).css({'background-color': 'green'});
            })
        })
$(document).ready(function{});


与window.onload的区别:
　　　1.window.onload()函数有覆盖现象，必须等待着图片资源加载完成之后才能调用
　　　2.jQuery的这个入口函数没有函数覆盖现象，文档加载完成之后就可以调用（建议使用此函数）
   
        // 等待整个页面中的内容全部加载完成之后,触发window.onload对应的函数里面的内容
        // window.onload 有覆盖现象,会被后面的window.onload给重新赋值
        // window.onload = function () {
        //     $('.c1').click(function () {
        //         $(this).css({'background-color':'green'});
        //     })
        // }

</code></pre>
<h3 id="each循环">each循环</h3>
<pre><code class="language-javascript">循环标签对象数组
$('li').each(function(k,v){
    console.log(k,v);
});

循环普通数组
var d1 = ['aa','bb','cc'];
$.each(d1,function(k,v){
    console.log(k,v);
})

跳出循环  return false; 类似于break
$('li').each(function(k,v){
    console.log(k,v.innerText);
    if (k === 1){
        return false;
    }

});

跳出本次循环  return; 类似于continue
$('li').each(function(k,v){
    
    if (k === 1){
        return;
    }
    console.log(k,v.innerText);
});

</code></pre>
<h3 id="点击事件和滚动事件的示例代码">点击事件和滚动事件的示例代码</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .c1{
            background-color: red;
            height: 100px;
            width: 100px;
        }
        .c2{
            background-color: green;
            height: 1000px;
            width: 100px;
        }
        .c3{
            background-color: blue;
            height: 1000px;
            width: 100px;
        }
        .s1{
            position: fixed;
            left:20px;
            bottom: 20px;
            height: 40px;
            width: 80px;
            background-color: purple;
            line-height: 40px;
            text-align: center;

        }
        .s1 a{
            color: white;
            font-size: 14px;
            text-decoration: none;
        }
        .hide{
            display: none;
        }
&lt;!-- more --&gt;



    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;a name=&quot;top&quot;&gt;这里是顶部&lt;/a&gt;--&gt;
&lt;!--&lt;a&gt;这里是顶部&lt;/a&gt;--&gt;
&lt;span&gt;顶部位置&lt;/span&gt;
&lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;

&lt;button class=&quot;change-postion&quot;&gt;走你&lt;/button&gt;

&lt;div class=&quot;c2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;c3&quot;&gt;&lt;/div&gt;

&lt;span class=&quot;s1 hide&quot;&gt;
    &lt;!--&lt;a href=&quot;#top&quot;&gt;返回顶部&lt;/a&gt;--&gt;
    &lt;span&gt;返回顶部&lt;/span&gt;

&lt;/span&gt;


&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
	//点击事件来改变标签位置
    $('.change-postion').click(function () {
        $('.c1').offset({top:200,left:200});
    });
    
	//滚动事件,监听滚动距离来显示或者隐藏标签
    $(window).scroll(function () {
        console.log($(window).scrollTop());
        if ($(window).scrollTop() &gt;=200){
            $('.s1').removeClass('hide');
        }else {
            $('.s1').addClass('hide');
        }
    });
    
	// 回到顶部,scrollTop设置值
    $('.s1').click(function () {
        $(window).scrollTop(0);
    })

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
</feed>