<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geckoc.github.io/</id>
    <title>RichardTech</title>
    <updated>2020-07-22T17:21:28.612Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geckoc.github.io/"/>
    <link rel="self" href="https://geckoc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://geckoc.github.io/images/avatar.png</logo>
    <icon>https://geckoc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, RichardTech</rights>
    <entry>
        <title type="html"><![CDATA[Java多线程模拟车站售票]]></title>
        <id>https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/</id>
        <link href="https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/">
        </link>
        <updated>2020-07-12T18:11:23.000Z</updated>
        <summary type="html"><![CDATA[<p>深入理解synchronized，以及多线程使用，这是较为经典的例子</p>
]]></summary>
        <content type="html"><![CDATA[<p>深入理解synchronized，以及多线程使用，这是较为经典的例子</p>
<!-- more -->
<blockquote>
<p>一开始我花了比较多时间，去判断当票数为0时，Thread还会继续启动，返回-1，-2显示购票成功<br>
解决：将synchronized同步代码片放到run方法下，且while(true)，一开始写成while(user.getRemainingTicket())，改过后，线程仍会启动进入run()但会返回无法购票提示，不再显示购票成功</p>
</blockquote>
<ul>
<li>本来写的代码注释较少，为了方便阅读，适当加了注释<br>
<s>1. TicketAccount (购票账户)</s><br>
- （改进，其实可以在run添加同购票方法，有需求也可在账户类编写）<br>
- （改进代码均会在下方贴出）</li>
</ul>
<ol start="2">
<li>TicketBusinessThread（线程）</li>
<li>TicketBusinessSystem（测试类）</li>
</ol>
<h4 id="talk-is-cheapshow-me-the-code"><em>Talk is cheap，show me the code.</em></h4>
<pre><code>public class TicketAccount {
	private int remainingTicket;  //票数
// 我是直接初始化给定票数值测试，你也可以带有参构造，自己想赋值多少都可以
	public TicketAccount() {
		this.remainingTicket = 100;
	}
	
	public int getRemainingTicket() {
		return remainingTicket;
	}

	public void setRemainingTicket(int after) {
		this.remainingTicket = after;
	}
// 购票方法
	public void ticketBuy(int remainingTicket) {
//			购票前
			int before = this.getRemainingTicket();
//			购票后
			int after = before - remainingTicket;
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
//			更新票数数据
			this.setRemainingTicket(after);
	}
}
</code></pre>
<pre><code>public class TicketBusinessThread implements Runnable{
	private TicketAccount ticketAccount ;
	public TicketBusinessThread(TicketAccount ticketAccount) {
		this.ticketAccount = ticketAccount;
	}
	@Override
	public void run() {
		int tick = 1;
        /*
		 *  这里花费了一些时间，由于while()语法，前面已说过不再赘述
		 *  注：synchronized同步代码块需在while内
		 *  否则会一个线程直接买完票，其他线程窗口无用
		 */
		while (true) {
		    synchronized (ticketAccount) {
		    	if (this.ticketAccount.getRemainingTicket() &gt; 0) {
		    		ticketAccount.ticketBuy(tick);
		    		System.out.println(&quot;恭喜使用&quot;+Thread.currentThread().getName()+&quot;购票成功&quot;+&quot;剩余票数为：&quot;
                    +this.ticketAccount.getRemainingTicket());
		    	}else {
		    		System.out.println(&quot;不好意思，票已售完&quot;);
		    		break;
		    	}
			}
		}
	}
}
</code></pre>
<pre><code>public class TicketBusinessSystem {
	public static void main(String[] args) {
		TicketAccount ticketAccount1 = new TicketAccount();
        // 创建线程对象，传入可运行类
		Thread tickBuy_one = new Thread(new TicketBusinessThread(ticketAccount1));
		Thread tickBuy_two = new Thread(new TicketBusinessThread(ticketAccount1));
		Thread tickBuy_three = new Thread(new TicketBusinessThread(ticketAccount1));
		// 设置线程名字
		tickBuy_one.setName(&quot;窗口1&quot;);
		tickBuy_two.setName(&quot;窗口2&quot;);
		tickBuy_three.setName(&quot;窗口3&quot;);
		//线程启动
		tickBuy_one.start();
		tickBuy_two.start();
		tickBuy_three.start();
	}
}
</code></pre>
<blockquote>
<p>以上为初次代码 2020-7-13 02:11:16</p>
</blockquote>
<ol>
<li>[改进] TicketBusinessThread（线程）<br>
<s>2. [改进] TicketBusinessSystem（测试类）</s><br>
-  测试类，与上面如出一辙，删除了有参构造，直接New调用即可</li>
</ol>
<pre><code>public class TicketBusinessThread implements Runnable{
	private int ticks = 100;//定义初始票数，也可构造有参自定义票数
	@Override
	public void run() {
        	while (true) {
                //调用购票方法，票售完跳出死循环
			    payTicket();
			    if (ticks == 0) {
				    System.out.println(&quot;对不起，票已售完...&quot;);
				    break;
			    }
		    }
		}
	}
	
//	定义同步买票方法
	public void payTicket() {
//		判断票是否存在
			synchronized (this) {
				if (ticks &gt; 0) {
//			提高线程安全问题出现概率，使线程堵塞
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName() + &quot;正在卖出第&quot;+ticks+&quot;张票，&quot;+&quot;恭喜购票成功&quot;);
					ticks--;
				}
			}
	}
}
</code></pre>
<ol>
<li>TicketAccount (购票账户)[改]</li>
</ol>
<blockquote>
<p>第一次写是想用户输入购票数，可多张购买；由于每个身份证只能购票一张，重写编写，在账户类定义方法如下：以下只有购票方法代码其他属性根据需求自行定义</p>
</blockquote>
<pre><code>public void ticketBuy() {
		synchronized (this) {
			if (this.getRemainingTicket() &gt; 0) {
//				提高线程安全问题出现概率，使线程堵塞
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + &quot;正在卖出第&quot;+getRemainingTicket()+&quot;张票，&quot;+&quot;恭喜购票成功&quot;);
				int after = --remainingTicket;
				setRemainingTicket(after);
			}	
		}
	}
      
    改于2020-7-13 21:48:39
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gitalk配置教程]]></title>
        <id>https://geckoc.github.io/post/gitalk-pei-zhi-jiao-cheng/</id>
        <link href="https://geckoc.github.io/post/gitalk-pei-zhi-jiao-cheng/">
        </link>
        <updated>2020-07-09T17:42:50.000Z</updated>
        <summary type="html"><![CDATA[<p>gitalk配置分享，使用Gridea初步</p>
<h3 id="获得权限">获得权限</h3>
<p>在使用该脚本之前首先要在 GitHub 创建一个新的 Oauth Application</p>
]]></summary>
        <content type="html"><![CDATA[<p>gitalk配置分享，使用Gridea初步</p>
<h3 id="获得权限">获得权限</h3>
<p>在使用该脚本之前首先要在 GitHub 创建一个新的 Oauth Application</p>
<!-- more -->
<p><a href="https://github.com/settings/apps">点击此处 Click Here</a></p>
<p>点击Oauth Apps，然后新建<br>
<img src="https://geckoc.github.io//post-images/1594317386736.png" alt="" loading="lazy"></p>
<p>Application name: 随便填写<br>
Homepage URL: 填写博客所在的仓库名。比如我的博客就填写: https://geckoc.github.io/<br>
Application description: 可以不用填写<br>
Authorization callback URL: 如果有把域名通过CNAME解析到仓库上就填写自己的域名。如果没有就填写仓库名即可</p>
<p>点击Register Application就可以创建<br>
接着就可以看到该应用的Client ID和Client Secret</p>
<h3 id="创建仓库">创建仓库</h3>
<p>完成以上步骤后，<a href="https://github.com/new">点此创建</a>仓库来保存评论<br>
<img src="https://geckoc.github.io//post-images/1594318018870.png" alt="" loading="lazy"></p>
<p>比如填写仓库名为Comments，其余都不用填写</p>
<h3 id="配置">配置</h3>
<p>博客配置</p>
<pre><code>&lt;section class=&quot;post-full-comments&quot;&gt;
    {{!-- gittalk --}}
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;
    &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var gitalk = new Gitalk({
            clientID: '修改：之前创建Oauth Apps保存的Client ID',
            clientSecret: '修改：之前创建Oauth Apps保存的Client Secret',
            repo: '修改：之前创建的repo名称，就是前面例子中的Comments',
            owner: '修改：GitHub的个人名称',
            admin: ['修改：GitHub的个人名称'], //这里可以填写具有写权限的用户名列表，用来初始化Issues的
            id: '{{comment_id}}',
            distractionFreeMode: false // Facebook-like distraction free mode
        });
        gitalk.render('gitalk-container');
    &lt;/script&gt;
&lt;/section&gt;
</code></pre>
<p>使用Gridea的话可以直接在设置中打开评论，填写以下内容</p>
<pre><code>clientID: '修改：之前创建Oauth Apps保存的Client ID',
clientSecret: '修改：之前创建Oauth Apps保存的Client Secret',
repo: '修改：之前创建的repo名称，就是前面例子中的Comments',
owner: '修改：GitHub的个人名称',
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[THE LIE WE LIVE]]></title>
        <id>https://geckoc.github.io/post/the-lie-we-live/</id>
        <link href="https://geckoc.github.io/post/the-lie-we-live/">
        </link>
        <updated>2020-07-04T15:27:37.000Z</updated>
        <summary type="html"><![CDATA[<p>人们最喜欢看的内容，不是现实和真相，而是可以让他们意淫的内容。</p>
]]></summary>
        <content type="html"><![CDATA[<p>人们最喜欢看的内容，不是现实和真相，而是可以让他们意淫的内容。</p>
<!-- more -->
<ul>
<li>微博上有不少居心不良的大V，喜欢打着女权的幌子，传播一些很倒风向的言论，比如“你负责赚钱养家，我负责貌美如花”“不舍得给你花钱的男人就是不爱你”“女孩子就应该被宠着”，如果你接触一下微博，你就会惊讶，这些一听就没道理的话，为什么会这么有市场？为什么很多女生听完以后会理直气壮的把这些话当成口号？答案就是——这些内容会让她们爽，让她们心安理得的接受别人的馈赠，不努力却要求别人努力，一身臭毛病还要让别人宠着。网络小说，给男生看的，大多是讲一个要钱没钱、要能力没能力的屌丝，忽然因为某个意外事件，获得了某种超能力，然后混的风生水起，多少女人前仆后继的陪他上床，最后甚至能统治整个宇宙；给女生看的，大多是讲一个长相普普通通的女生，某一天邂逅了一个白马王子，种种机缘巧合之下，她被白马王子追求，捧在手心，或者被n个富二代追求，最后顺理成章嫁入豪门。这些文章，但凡有脑子的人，都知道不现实，但是为什么网络小说全都这么写？就因为这些内容看完以后能让人爽，能让人通过短暂的幻想逃避现实。最残忍的是，很多人幻想的久了，竟然忘了这些事发生的概率多么低，真的以为自己可以屌丝逆袭/嫁入豪门/咸鱼翻身，然后就真的不努力了，因为幻想毁了自己的一生。而当我一板一眼的把这些残忍真相告诉他们的时候，他们竟然接受不了现实，不仅不给我继续，还扬言要屏蔽我...</li>
</ul>
<hr>
<ul>
<li>你并不比自己的父母优秀多少。现在知乎上批判自己父母的声音也很盛，诸多白领们自认为自己的表现远远优于自己的父母。其实，这不过是因为经济结构转型造成的误会。现在在公司的格子间里面哼哧哼哧做PPT的那些人，和当年踩着缝纫机的女工没有本质区别。 现在在各种购物软件上抢红包的那些人，和当年在菜市场上为了一分钱讨价还价的父母也没有区别；现在买个手机非得戴个壳、贴层膜，和当年父母非要给遥控器套个塑料袋也差不多；其实，现在每天刷微博、抖音、知乎的人，跟当年蹲在墙根晒太阳嗑瓜子的，也没什么区别。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[让子弹飞]]></title>
        <id>https://geckoc.github.io/post/rang-zi-dan-fei/</id>
        <link href="https://geckoc.github.io/post/rang-zi-dan-fei/">
        </link>
        <updated>2020-07-04T14:55:59.000Z</updated>
        <summary type="html"><![CDATA[<p>马匪：“我好不容易把女生追到手，该结婚了，居然要30万彩礼”<br>
师爷：“对。”<br>
马匪：“还必须有车有房？”<br>
师爷：“对。”</p>
]]></summary>
        <content type="html"><![CDATA[<p>马匪：“我好不容易把女生追到手，该结婚了，居然要30万彩礼”<br>
师爷：“对。”<br>
马匪：“还必须有车有房？”<br>
师爷：“对。”</p>
<!-- more -->
<p>马匪：“还必须时刻担心回到单身生活?”<br>
师爷：“对。”<br>
马匪：“我不成了跪着要饭的吗?”<br>
师爷：“那要你这么说，结婚的男性就是跪着要饭的，就这，三千万想跪还没这路子呢!”<br>
马匪：“我上大学，学毛概，学马克思，就是因为腿脚不利索，跪不下去!”<br>
师爷：“原来想站着结婚啊?那还是去欧美吧”<br>
马匪：“哎?这我就不明白了，咱们新时代独立女青年怎么就赶不上欧美资本主义的女性？”<br>
师爷：“咱们眼里，你是有志向高远的有为青年。在她们眼里，那你就是跪着要饭的。结婚嘛，跪着，不寒碜。”<br>
马匪：“寒碜!很T.M寒碜!”<br>
师爷：“那你是想站着，还是想结婚呢?”<br>
马匪：“我是想站着，还把婚结了。”<br>
师爷：“结不成。”<br>
马匪：“结不成?”<br>
师爷：“结不成!”<br>
马匪：“这个（年入百万）能不能把婚结了？”<br>
师爷：“能结，跪着。”<br>
马匪：“那这个（英俊帅气）能不能结婚？”<br>
师爷：“能结，好的不一定能找到。”<br>
马匪：“那我这个（年入百万）再加这个（英俊帅气），能不能把婚好好结了？”<br>
师爷：“敢问英雄贵姓？”马匪：“社会主义接班人”</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java集合继承关系图]]></title>
        <id>https://geckoc.github.io/post/java-collection-line/</id>
        <link href="https://geckoc.github.io/post/java-collection-line/">
        </link>
        <updated>2020-07-02T15:23:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""><img src="https://geckoc.github.io//post-images/1595438426995.png" alt="" loading="lazy"></h2>
<figure data-type="image" tabindex="1"><img src="https://geckoc.github.io//post-images/1595438441351.gif" alt="" loading="lazy"></figure>
<ul>
<li>上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而点线边框的是接口，比如Collection，Iterator，List等。</li>
<li><strong>注意</strong>：指出错误--&gt;Iterator的子接口是ListIterrator,而不是图中的<s>LinkIterator</s></li>
</ul>
<hr>
<h3 id="1-iterator-接口迭代器对象">1. <em>Iterator</em> 接口（迭代器对象）</h3>
<ul>
<li>用于迭代遍历集合中的所有元素</li>
<li><em>Collection</em> 通用迭代方法，<em>Map</em> 集合不能使用</li>
<li>包含hashNext(),next(),remove()三种方法
<ol>
<li>hashNext() 如果仍有元素可迭代，则返回 true</li>
<li>next() 让迭代器前进一位且返回所迭代中指向的元素。</li>
<li>remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）</li>
</ol>
</li>
<li>它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious()
<blockquote>
<p>通常无序集合使用Iterator接口，而有序集合使用LinkedIterator接口，可双向遍历</p>
</blockquote>
</li>
</ul>
<pre><code>迭代器：当集合结构发生改变时，迭代器需要重新获取，迭代器不会自动刷新
迭代器相当于生出一个新的快照，迭代时不可使用Collection的remove方法
因为Collection的remove删除的是集合结构里的元素，此时结构发生改变，出现异常
但可用Iterator的remove方法，迭代器的remove删除的是迭代器获取的快照元素
迭代器删除时，会自动跟新迭代器，并且更新集合
如果没有重新获取，会出现异常；
</code></pre>
<h3 id="2-list-中的常用子类">2. <em>List</em> 中的常用子类</h3>
<blockquote>
<p>特有方法<br>
<img src="https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621005955773-608960404.png" alt="" loading="lazy"></p>
</blockquote>
<ul>
<li><em><strong>ArrayList</strong></em>
<ol>
<li>初始化容量为10（底层先创建了一个长度为0 的数组，添加第一个元素时，初始化容量10）</li>
<li>扩容到原容量的1.5倍，建议给定一个预估定值，减少扩容，提高效率</li>
<li>底层为Object[]数组</li>
<li>检索查找效率高，随机增删元素效率低，PS：增删末尾元素不影响效率</li>
</ol>
<blockquote>
<p>检索效率高：因空间存储上内存地址为连续的，知道数据类型占用空间大小，知道元素下标，可通过数学表达式快速计算出元素位置，所以效率高</p>
</blockquote>
<ol start="5">
<li>非线程安全的，无法存储大数据【因在内存空间上很难找到一块连续的大内存】</li>
<li>有序可重复的，元素有下标</li>
</ol>
</li>
<li><em><strong>LinkedList</strong></em>
<ol>
<li>链表数据结构的基本单元是节点 <em>Node</em></li>
<li>LinkedList集合是双向链表结构，元素在空间存储上内存地址不连续</li>
<li>LinkedList集合没有初始化容量，最初没有任何元素，first 和 last 都是 null</li>
<li>优点：随机增删元素效率较高（不涉及到元素位移）内存地址不连续</li>
<li>缺点：查询检索效率较低，每一次查找都需要从头节点开始往下遍历</li>
</ol>
</li>
<li><em><strong>Vector</strong></em>
<ul>
<li>初始化容量为10，底层为数组</li>
<li>扩容后为原容量的两倍</li>
<li>所有方法线程同步，有<em>synchronize</em> 关键字修饰，属于线程安全</li>
<li>效率较低，使用较少</li>
</ul>
</li>
</ul>
<h3 id="3-generic-泛型特性">3. <em>Generic</em> (泛型特性)</h3>
<pre><code>* @Description: JDK5推出的新特性，泛型
* 	1、泛型语法机制，只在程序编译阶段起作用，提供给编译器参考（运行阶段泛型不产生作用）
* 	2、使用泛型的好处：
* 		第一：集合中存储的元素类型统一了；
* 		第二；从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”（强制类型转换）
*	
*	3、泛型的缺点：导致集合中存储的元素缺乏多样性
*		大多数业务，集合中的元素还是统一的，所以泛型得到认可
</code></pre>
<h3 id="4-object类">4. <em>Object</em>类</h3>
<ul>
<li>一个完整的类最好重写Object类中的 <em>toString()、equals()、hashCode()</em> 方法</li>
</ul>
<h3 id="5-集合常见输出方式">5. 集合常见输出方式</h3>
<ul>
<li>Iterator ---&gt; 迭代输出</li>
<li>ListIterator ---&gt; Iterator子接口，适用于双向链表迭代，遍历</li>
<li>Enumeration ---&gt; 枚举</li>
<li>Foreach ---&gt; for增强语句，不使用于需使用下标的环境</li>
</ul>
<blockquote>
<p>在迭代时，不可以通过集合对象的方法操作集合中的元素，因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的放过操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。</p>
</blockquote>
<p><strong><em>loading</em></strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Essentials Collection ]]></title>
        <id>https://geckoc.github.io/post/collection-essential/</id>
        <link href="https://geckoc.github.io/post/collection-essential/">
        </link>
        <updated>2020-06-28T19:00:10.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="collection当中可存放-的元素"><em>Collection</em>当中可存放 的元素</h3>
<ul>
<li>没有使用&quot;泛型&quot;之前， <em>Collection</em> 中可以存储Object的所有子类型</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h3 id="collection当中可存放-的元素"><em>Collection</em>当中可存放 的元素</h3>
<ul>
<li>没有使用&quot;泛型&quot;之前， <em>Collection</em> 中可以存储Object的所有子类型</li>
</ul>
<!-- more -->
<ul>
<li>使用了&quot;泛型&quot;之后，<em>Collection</em> 只能存储某个具体的类型</li>
</ul>
<blockquote>
<p>集合中不能直接存储基本数据类型和Java对象，只能存储对象的内存地址（引用）<br>
<em>Collection</em>是接口，无法实例化对象</p>
</blockquote>
<h3 id="collection中的常用方法"><em>Collection</em>中的常用方法</h3>
<ul>
<li><strong><em>boolean add(Object e)</em></strong></li>
<li><strong><em>boolean contains(Object o)</em></strong></li>
<li><strong><em>boolean remove(Object o)</em></strong></li>
<li><strong><em>nt size()</em></strong></li>
<li><strong><em>boolean isEmpty()</em></strong></li>
<li><strong><em>Object[] toArray()</em></strong>   <s>把集合转换为数组</s></li>
</ul>
<pre><code>public class ContainTest {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		String s1 = new String(&quot;abc&quot;);
		c.add(s1);
		String s2 = new String(&quot;edf&quot;);
		c.add(s2);
		
		String x = new String(&quot;abc&quot;);
		/*
		 * 	如果此集合包含指定的元素，则返回true 。 
		 * 	更正式地，返回true
		 * 	如果且仅当该集合至少包含一个元素e使得(o==null ? e==null : o.equals(e)) 
		 *  contains底层调用了equals(),而String已经重写了equals方法
		 *	所以比较的不是内存地址 ，而是内容
		 */
		System.out.println(c.contains(x)); //true
	}
}
</code></pre>
<pre><code>public class DeepContains {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		User u1 = new User(&quot;abc&quot;);
		User u2 = new User(&quot;abc&quot;);
		c.add(u1);
		/*
		 * 	User没有重写equals方法，底层Object的equals使用的是==
		 * 	比较的是内存地址，返回false
		 */
//		System.out.println(c.contains(u2));
		/*
		 * 	重写User的equals方法后，返回true
		 * 	比较的是内容
		 */
		System.out.println(c.contains(u2));
		
		Collection collection = new ArrayList();
		String x1 = new String(&quot;jack&quot;);
		String x2 = new String(&quot;jack&quot;);
		collection.add(x1);
		System.out.println(collection.size());
		/*
		 * remove方法底层调用了equals
		 * 	删除x2的时候，既是删除了x1
		 */
		collection.remove(x2);
		System.out.println(collection.size());
		
	}
	
}
class User{
	String name;
	public User() {
		// TODO Auto-generated constructor stub
	}
	public User(String name) {
		
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}
</code></pre>
<h4 id="结论存放在集合中的类型一种要重写equals方法"><strong><em>结论：存放在集合中的类型，一种要重写equals方法</em></strong></h4>
<hr>
<h3 id="关于集合遍历-迭代器"><strong>关于集合遍历 迭代器</strong></h3>
<ol>
<li><em>boolean hasNext()</em>  如果仍有元素可迭代，则返回 <em>true</em></li>
<li><em>Object next()</em> 让迭代器前进一位且返回所迭代中指向的元素。</li>
<li><em>remove()</em> 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。
<blockquote>
<p><em>Collection</em>通用迭代方法，在<em>Map</em>集合中不能使用</p>
</blockquote>
</li>
</ol>
<ul>
<li>List集合存储元素特点：有序可重复，元素有下标   实现类 <em>ArraysList、LinkedList、Vector</em></li>
<li>Set集合存储元素特点：无序不可重复，元素没有下标  实现类 <em>HashSet、TreeSet</em></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaWeb:The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path]]></title>
        <id>https://geckoc.github.io/post/javaweb/</id>
        <link href="https://geckoc.github.io/post/javaweb/">
        </link>
        <updated>2020-06-28T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jsp页面顶端出现红色的报错信息"><em><strong>JSP页面顶端出现“红色”的报错信息:</strong></em></h2>
<p><em><strong>The superclass &quot;javax.servlet.http.HttpServlet&quot; was not found on the Java Build Path。</strong></em><br>
<em>原来Javaweb工程类中没有添加Tomcat运行时相关类导致。<br>
下面是具体的解决方法：</em></p>
<ol>
<li><em>右击web工程-》属性或Build Path-》Java Build Path-&gt;Libraries-&gt; Add Libray...-&gt;Server Runtime -》Tomcat Server</em></li>
<li><em>切换到Java Build Path界面中的Orader and Export，选择Tomcat。</em></li>
</ol>
<h3 id="注意"><strong>注意</strong></h3>
<p>按以上方法操作时，若打开<em>Server Runtime</em>后一片空白，需要设置<em>Apache</em>服务器。设置方法为：<em>window-&gt;Preferences-&gt;Server-&gt;Runtime Environment -&gt; add --&gt;</em> 选择<em>Apache</em>的版本后点<em>Next</em>，再填入你<em>apache</em>服务器软件的安装（解压后）地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Java异常深入理解 ]]></title>
        <id>https://geckoc.github.io/post/guan-yu-java-yi-chang-shen-ru-li-jie/</id>
        <link href="https://geckoc.github.io/post/guan-yu-java-yi-chang-shen-ru-li-jie/">
        </link>
        <updated>2020-06-27T19:32:58.000Z</updated>
        <summary type="html"><![CDATA[<p>throws | try catch Day_27<br>
◾不建议在main()方法中直接调用throws，因为一旦出现异常JVM将会直接终止，一般采用try catch<br>
◾关于throws和try...catch的选择，当需要反馈给调用者异常信息时，则throws<br>
◾异常在Java程序中是以类和对象存在的<br>
◾异常的作用：增强程序的j健壮性</p>
]]></summary>
        <content type="html"><![CDATA[<p>throws | try catch Day_27<br>
◾不建议在main()方法中直接调用throws，因为一旦出现异常JVM将会直接终止，一般采用try catch<br>
◾关于throws和try...catch的选择，当需要反馈给调用者异常信息时，则throws<br>
◾异常在Java程序中是以类和对象存在的<br>
◾异常的作用：增强程序的j健壮性</p>
<!-- more -->
<p>异常中的关键字<br>
◾try<br>
◾try 和 finally 可以联合使用，try不可单独使用</p>
<p>◾catch<br>
◾catch可以捕捉多个异常<br>
◾catch的异常顺序必须遵循自上而下从小到大的原则</p>
<p>◾finally<br>
1.finally子语句必须和try...catch使用<br>
2.finally语句块中的代码一旦会执行且在最后执行<br>
3.finally多用于资源的释放和关闭，因执行有保障</p>
<p>◾throws<br>
◾throws可以抛出多个异常以逗号隔开<br>
◾在方法声明位置上使用，表示上报异常给调用者</p>
<p>◾throw 手动抛出异常</p>
<p>自定义异常Exception<br>
1.创建的类中继承Exception或者RuntimeException<br>
2.创建构造方法，一个无参数的，一个有参数String的</p>
<p>final	finally	finalize 三者间的区别</p>
<p>final ---- 关键字<br>
◾final修饰的类无法继承<br>
◾final修饰的方法无法重载/重写override<br>
◾final修饰的变量无法重写赋值</p>
<p>finally ---- 关键字<br>
◾finally语句块的代码必须执行<br>
◾finally和try可以联合使用<br>
◾System.exit(0)，终止JVM时finally语句块的代码无法执行</p>
<p>finalize ---- 标识符<br>
◾这是一个Object类中的方法名<br>
◾此方法是由垃圾回收器GC调用的<br>
◾finalize 已经过时<br>
在方法重写Override中，重写的方法抛出的异常不能比父类的多（宽泛性）</p>
]]></content>
    </entry>
</feed>