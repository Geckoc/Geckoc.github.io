<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geckoc.github.io/</id>
    <title>RichardTech</title>
    <updated>2020-08-14T17:52:20.068Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geckoc.github.io/"/>
    <link rel="self" href="https://geckoc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://geckoc.github.io/images/avatar.png</logo>
    <icon>https://geckoc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, RichardTech</rights>
    <entry>
        <title type="html"><![CDATA[MySQL三部曲之初见端倪]]></title>
        <id>https://geckoc.github.io/post/mysql-san-bu-qu-zhi-chu-jian-duan-ni/</id>
        <link href="https://geckoc.github.io/post/mysql-san-bu-qu-zhi-chu-jian-duan-ni/">
        </link>
        <updated>2020-08-14T17:20:40.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>sql、DB、DBMS分别是什么，他们之间的关系？</p>
<ul>
<li>
<p>DB：DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）</p>
</li>
<li>
<p>DBMS：DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer...）</p>
</li>
<li>
<p>SQL：结构化查询语言，是一门标准通用的语言，标准的sql适合于所有数据库产品。<br>
SQL属于高级语言，只要能看懂英语单词，写出来的sql语句，可以读懂什么意思。<br>
SQL语句在执行的时候，实际上内部也会先进行编译，然后再试下SQL（SQL语句的编译由DBMS完成）</p>
</li>
<li>
<p>DBMS负责执行SQL语句，通过执行SQL语句来操作DB当中的数据。</p>
</li>
<li>
<p>DBMS--&gt;(执行)-&gt; SQl(操作)-&gt; DB</p>
</li>
</ul>
</li>
<li>
<p>什么是表？</p>
</li>
</ol>
<ul>
<li>
<p>table是数据库当中的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。</p>
</li>
<li>
<p>一个表包括行和列<br>
行：被称为数据（data）<br>
列：被称为字段（column）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>学号(int)</th>
<th>姓名(varchar)</th>
<th>年龄(int)</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>张三</td>
<td>18</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>24</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>16</td>
</tr>
</tbody>
</table>
<ul>
<li>每一个字段应该包括哪些属性？</li>
</ul>
<ul>
<li>字段名、数据类型、相关的约束</li>
</ul>
<ol start="3">
<li>
<p>学习MySQL主要还是学习通用的SQL语句，SQL语句包括增删改查，SQL语句是如何分类的？</p>
<ul>
<li>DQL（数据查询语言）： 查询语句，凡是select语句都是DQL。</li>
<li>DML（数据操作语言）：insert ， delete ， update 对表当中的数据进行增删改。</li>
<li>DDL（数据定义语言）：create，drop ，alter  对表结构的增删改。</li>
<li>TCL（事务控制语言）：commit提交事务，rollback回滚事务、（TCL中的T是Transaction）</li>
<li>DCL（数据控制语言）：grant授权、revoke撤销权限等。</li>
</ul>
</li>
<li>
<p>导入数据（后期练习时使用）</p>
<ul>
<li>
<p>第一步：登录MySQL数据库 root</p>
</li>
<li>
<p>第二步：查看有哪些数据库</p>
<ul>
<li>
<p><em>show database</em>（这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</p>
<pre><code>mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
</code></pre>
</li>
</ul>
</li>
<li>
<p>第三步：创建属于自己的数据库</p>
<ul>
<li><em>create database bjpowernode</em>; （这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</li>
</ul>
</li>
<li>
<p>第四步：使用***bjpowernode***数据库</p>
<ul>
<li><em>use bjpowernode</em>;（这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</li>
</ul>
</li>
<li>
<p>第五步：查看数据库中有哪些表？</p>
<ul>
<li><em>show tables</em>;（这个不是<strong>SQL</strong>语句，属于<strong>MySQL</strong>的命令）</li>
</ul>
</li>
<li>
<p>第六步：初始化数据</p>
<ul>
<li><em>mysql&gt; source</em> ( <filename> | source <filename>) ---&gt; 文件路径</li>
<li><em>mysql&gt; source</em></li>
<li>注意：数据初始化完成之后，有三张表</li>
</ul>
<pre><code>mysql&gt; show tables;
+-----------------------+
| Tables_in_bjpowernode |
+-----------------------+
| dept                  |
| emp                   |
| salgrade              |
+-----------------------+
</code></pre>
</li>
</ul>
</li>
<li>
<p><em>bjpowernode.sql</em>,这个文件以<strong>sql</strong>结尾，这样的文件被称为&quot;sql脚本&quot;。什么是sql脚本？</p>
<ul>
<li>当一个文件的扩展名是&quot;.sql&quot;，并且该文件中编写了大量的sql语句，这样的文件叫SQL脚本。</li>
<li>注意：直接使用source命令可以执行SQL脚本。</li>
<li>SQL脚本中的数据量太大时无法打开，请使用source命令完成初始化。</li>
</ul>
</li>
<li>
<p>删除数据库：drop database bjpowernode;</p>
</li>
<li>
<p>查看表结构</p>
<pre><code>mysql&gt; show tables;
+-----------------------+
| Tables_in_bjpowernode |
+-----------------------+
| dept                  |	(部门表)
| emp                   |	(员工表)
| salgrade              |	(工资登记表)
+-----------------------+
</code></pre>
<pre><code>mysql&gt; desc dept;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| DEPTNO | int(2)      | NO   | PRI | NULL    |       |	部门编号
| DNAME  | varchar(14) | YES  |     | NULL    |       |	部门名称
| LOC    | varchar(13) | YES  |     | NULL    |       |	部门位置
+--------+-------------+------+-----+---------+-------+

mysql&gt; desc emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| EMPNO    | int(4)      | NO   | PRI | NULL    |       |	员工编号
| ENAME    | varchar(10) | YES  |     | NULL    |       |	员工姓名
| JOB      | varchar(9)  | YES  |     | NULL    |       |	工作岗位
| MGR      | int(4)      | YES  |     | NULL    |       |	上级领导编号
| HIREDATE | date        | YES  |     | NULL    |       |	入职日期
| SAL      | double(7,2) | YES  |     | NULL    |       |	月薪
| COMM     | double(7,2) | YES  |     | NULL    |       |	补助/津贴
| DEPTNO   | int(2)      | YES  |     | NULL    |       |	部门编号
+----------+-------------+------+-----+---------+-------+

mysql&gt; desc salgrade;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| GRADE | int(11) | YES  |     | NULL    |       |	等级
| LOSAL | int(11) | YES  |     | NULL    |       |	最低薪资
| HISAL | int(11) | YES  |     | NULL    |       |	最高薪资
+-------+---------+------+-----+---------+-------+
</code></pre>
</li>
<li>
<p>表中的数据</p>
<pre><code>mysql&gt; select * from dept;
mysql&gt; select * from emp;
mysql&gt; select * from salgrade;
</code></pre>
</li>
<li>
<p>MySQL常用命令？</p>
<pre><code>select database();	查看当前正在使用的数据库
select version();	查看mysql的版本号
\c	命令，结束一条语句
exit	命令，退出MySQL
</code></pre>
</li>
<li>
<p>查看创建表的语句</p>
</li>
</ol>
<pre><code>   mysql&gt; show create table emp;
   +-------+-------------------------------
   | Table | Create Table
   +-------+-------------------------------
   | emp   | CREATE TABLE `emp` (
     `EMPNO` int(4) NOT NULL,
     `ENAME` varchar(10) DEFAULT NULL,
     `JOB` varchar(9) DEFAULT NULL,
     `MGR` int(4) DEFAULT NULL,
     `HIREDATE` date DEFAULT NULL,
     `SAL` double(7,2) DEFAULT NULL,
     `COMM` double(7,2) DEFAULT NULL,
     `DEPTNO` int(2) DEFAULT NULL,
     PRIMARY KEY (`EMPNO`)
   ) ENGINE=InnoDB DEFAULT CHARSET=latin1 |
   +-------+-------------------------------
</code></pre>
<h4 id="简单的查询dql数据查询">简单的查询（DQL数据查询）</h4>
<ul>
<li>语法格式：select 字段名1, 字段名2, 字段名3,... form 表名;</li>
<li>任何一条SQL语句以&quot;;&quot;结尾。</li>
<li>SQL与极具不区分大小写</li>
<li>注意：标准SQL语句中要求字符串使用单引号括起来，虽然MySQL支持双引号，尽量别用。</li>
</ul>
<pre><code>   查询员工的年薪
   mysql&gt; select ename,empno,sal * 12 from emp; (字段可以参与数学运算)
   mysql&gt; select ename,empno,sal * 12 as yearsal from emp;（给查询结果的列重命名 ‘as’ 关键字）
   mysql&gt; select ename,empno,sal * 12 yearsal from emp;（‘as’ 关键字可以省略）
   mysql&gt; select ename,empno,sal * 12 as '年薪' from emp; （别名中有中文，单引号括起来）
   mysql&gt; select * from emp; （查询全部字段）
   实际开发中不建议使用 * ，效率较低。
</code></pre>
<h4 id="条件查询">条件查询</h4>
<ul>
<li>语法格式：select 字段，字段... from 表名 where 条件；执行顺序： from --&gt; where --&gt; select</li>
<li>between..and..在使用时必须左小右大</li>
<li>between..and..也可以使用在字符串方面</li>
</ul>
<pre><code>    mysql&gt; select ename,sal from emp where sal = 3000; （查询薪资等于3000的员工）
    mysql&gt; select ename,sal from emp where sal &lt;&gt; 3000; （不等于3000，也可以用 != ）
    mysql&gt; select ename,sal from emp where ename = 'smith'; （查询员工姓名为Smith的工资）
    mysql&gt; select ename,sal from emp where sal &gt;= 1500 and sal &lt;= 5000;(1500~5000薪资的员工)
    mysql&gt; select ename,sal from emp where sal between 100 and 3100;（between...and...是闭区间）
    between..and..在使用时必须左小右大
    mysql&gt; select ename from emp where ename between 'A' and 'D'; （左闭右开）
</code></pre>
<h4 id="is-null-is-not-null-and-or-innot-in-like"><em><strong>is null (is not null) ,  and , or , in，not in , like</strong></em></h4>
<ul>
<li>在数据库当中null不是一个值，代表什么也没有，为空。</li>
<li>空不是一个值，不能用等号衡量。</li>
<li>必须使用 is null 或者 is not null</li>
<li>注意：当运算符的优先级不确定的时候加小括号。</li>
</ul>
<pre><code>mysql&gt; select ename,sal,comm from emp where comm is null or comm = 0;(找出无津贴员工)
    mysql&gt; select ename,sal,comm from emp where comm is not null;（找出有津贴员工）

(找出工作岗位是salasman和manager的员工)
mysql&gt; select ename,job,hiredate from emp where job='salesman' or job ='manager';
（and和or联合起来使用：找出薪资大于1000的并且部门编号是20或者30部门的员工）
mysql&gt; select ename,sal,deptno from emp where sal &gt; 1000 and deptno = 20 or deptno =30; //错误
mysql&gt; select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno =30); // 正确
</code></pre>
<ul>
<li><strong>in</strong> 等同于 <strong>or</strong>，找出工作岗位是salasman和manager的员工(in后面的值不是区间，是具体的值)</li>
</ul>
<pre><code>mysql&gt; select ename,job,hiredate from emp where job='salesman' or job ='manager';
mysql&gt; select ename,sal,job from emp where job in ('salesman','manager');
mysql&gt; select ename,sal from emp where sal in (800, 3000); //in后面的值不是区间，是具体的值
</code></pre>
<ul>
<li><strong>not in :</strong> 不在这几个值当中</li>
</ul>
<pre><code>mysql&gt; select ename, sal from emp where sal not in(800,5000); (查询不是800，5000的值)
</code></pre>
<ul>
<li>
<p>模糊查询 <strong>like</strong></p>
<ul>
<li>在模糊查询中，必须掌握的两个特殊的符号，一个是 <strong>%</strong> ，一个是 <strong>_</strong></li>
<li><strong>%</strong> 代表任意多个字符， <strong>_</strong> 代表任意一个字符。</li>
</ul>
<pre><code>mysql&gt; select ename from emp where ename like '%A%'; (找出名字中含有A字母的)
mysql&gt; select ename from emp where ename like '_A%'; (找出第二个字母是A的)
(找出名字中有下划线的，可以使用反斜杠转义，表示一个普通的下划线)
mysql&gt; select ename from emp where	 ename like '%\_%';
(找出最后一个字母是S的名字)
mysql&gt; select ename from emp where ename like '%S';
</code></pre>
</li>
</ul>
<h4 id="排序升序-降序order-by">排序（升序、降序）Order by</h4>
<ul>
<li>
<p>---&gt; 默认是升序</p>
</li>
<li>
<p>指定升降序，<strong>asc</strong> 表示升序，<strong>desc</strong> 表示降序</p>
<pre><code>mysql&gt; select ename , sal from emp order by sal; （默认升序）

mysql&gt; select ename ,sal from emp order by sal desc; (指定降序)

mysql&gt; select ename ,sal from emp order by sal asc; (指定升序)

（按照工资的降序排列，当工资相同的时候再按照名字的升序排列）
mysql&gt; select ename , sal from emp order by sal desc , ename asc;
(找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列)
mysql&gt; select ename,sal,job from emp
    -&gt; where job = 'salesman'
    -&gt; order by sal desc;
    
    执行顺序  from---&gt; where ---&gt; select ---&gt; order by...
</code></pre>
<ul>
<li>注意：越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序的时候，才会启用后面的字段。</li>
</ul>
</li>
</ul>
<h4 id="分组函数">分组函数</h4>
<ul>
<li><em><strong>count（计数），sum（求和）， avg（平均值）， max（最大值）， min（最小值）</strong></em>
<ul>
<li>所有的分组函数都是对“某一组”数据进行操作的</li>
<li>分组函数又称：多行处理函数</li>
<li>多行处理函数特点：输入多行，最终输出的结果是一行。</li>
<li>分组函数有一个特点：自动忽略null。</li>
<li><strong>在数据库中只要有null进行了运算，最后结果一定是null，所有数据库都是这样规定的</strong></li>
<li>分组函数不可直接使用在where子句当中</li>
<li>分组函数可以组合使用</li>
</ul>
</li>
</ul>
<pre><code>mysql&gt; select sum(sal) from emp;  （找出工资总和）
mysql&gt; select sum(sal) from emp;   （平均工资）
...
（找出工资高于平均工资的员工）
mysql&gt; select ename,sal from emp where sal &gt; avg(sal);
ERROR 1111 (HY000): Invalid use of group function
错误：无效的使用的了分组函数
mysql&gt; select ename, sal  from emp where sal &gt; (select avg(sal) from emp);
	因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why?
	怎么解释？
		因为 group by 是在 where 执行之后才会执行的（分组函数用不了，是因为还没有分组）
		而分组函数必须要 group by 分组才能执行
		select...	5.选择数据
		from...		1.先从表取出数据
		where...	2.条件过滤，哪个数据
		group by...	3.数据分组
		having...	4.数据过滤
		order by... 6.排序输出
count (*) 和 count(具体字段)有什么区别？
count(*) : 不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）
count(comm) : 表示统计comm字段中不为null的数据总数量。

分组函数可以组合使用
mysql&gt; select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;
+----------+----------+-------------+----------+----------+
| count(*) | sum(sal) | avg(sal)    | max(sal) | min(sal) |
+----------+----------+-------------+----------+----------+
|       14 | 29025.00 | 2073.214286 |  5000.00 |   800.00 |
+----------+----------+-------------+----------+----------+
1 row in set (0.00 sec)
</code></pre>
<h4 id="单行处理函数">单行处理函数</h4>
<ul>
<li>输入一行，输出一行</li>
<li><strong>ifnull(comm,0)</strong> ---&gt; 如果comm为null，则使其等同于0。</li>
<li><strong>ifnull(可能为null的数据，被当做什么处理)</strong>  <em>空处理函数</em></li>
</ul>
<pre><code>计算每个员工的年薪？
mysql&gt; select ename, (sal+comm) * 12 yearsal from emp;  // comm为null值时，员工薪资为null，不正确
使用ifnull函数;
mysql&gt; select ename, (sal + ifnull(comm,0)) * 12 yearsal from emp;
</code></pre>
<h4 id="group-by-having"><em><strong>Group by  || Having</strong></em></h4>
<ul>
<li>
<p>group by ：按照某个字段或者某些字段进行分组；</p>
<ul>
<li>注意：分组函数一般都会和 group by 联合使用，这也是为什么被称为分组函数的原因。</li>
<li>任何一个分组函数(count，sum，avg，max，min)都是在group by 语句执行结束后才执行的。</li>
<li>当一条SQL语句没有group by的话，整张表的数据会自成一组。</li>
<li>记住：当一条语句中有 group by 的话，select 后面只能跟分组函数和参与分组的字段。</li>
<li>找出每个工作岗位的最高薪资；</li>
</ul>
<pre><code>mysql&gt; select job,max(sal) from emp group by job;	//找出每个工作岗位的最高薪资；
+-----------+----------+
| job       | max(sal) |
+-----------+----------+
| ANALYST   |  3000.00 |
| CLERK     |  1300.00 |
| MANAGER   |  2975.00 |
| PRESIDENT |  5000.00 |
| SALESMAN  |  1600.00 |
+-----------+----------+

mysql&gt; select job,max(sal) from emp group by job;
以上在mysql当中，有查询结果，但结果没有意义，在oracle数据库中会报错，语法错误。
oracle的语法规则比MySQL语法规则严谨。
记住：当一条语句中有 group by 的话，select 后面只能跟分组函数和参与分组的字段。

找出每个工作岗位的平均薪资。
mysql&gt; select job, avg(sal) from emp group by job;

多个字段能不能联合起来一块分组？
案例：找出每个不同部门不同工作岗位的最高薪资；
mysql&gt; select deptno,job,max(sal) from emp group by deptno,job;

</code></pre>
<ul>
<li>
<p>having：对分组之后的数据进行再次过滤；</p>
<ul>
<li>找出每个部门的最高薪资，要求显示薪资大于2900的数据。
<ul>
<li>sql语句一般多层逻辑建议拆分思考编写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    mysql&gt; select deptno, max(sal) from emp group by deptno;（找出每个部门的最高薪资）
    +--------+----------+
    | deptno | max(sal) |
    +--------+----------+
    |     10 |  5000.00 |
    |     20 |  3000.00 |
    |     30 |  2850.00 |
    +--------+----------+
    （找出每个部门的最高薪资，要求显示薪资大于2900的数据）
    //这种方式效率低,因前面算出的最大值，后面又删掉
    select deptno, max(sal) from emp group by deptno having max(sal) &gt; 2900; 
    +--------+----------+
    | deptno | max(sal) |
    +--------+----------+
    |     10 |  5000.00 |
    |     20 |  3000.00 |
    +--------+----------+
    // 效率较高， where语句，可以从一开始就过滤掉2900以下的
    mysql&gt; select deptno,max(sal) from emp where sal &gt; 2900 group by deptno;
    +--------+----------+
    | deptno | max(sal) |
    +--------+----------+
    |     10 |  5000.00 |
    |     20 |  3000.00 |
    +--------+----------+
    2 rows in set (0.00 sec)
    
    （找出每个部门的平均薪资，要求显示薪资大于2900的数据）
</code></pre>
<h4 id="去重-distinct"><strong>去重</strong> <em><strong>distinct</strong></em></h4>
<ul>
<li><em><strong>distinct</strong></em> 只能出现在所有字段的最前面</li>
</ul>
<pre><code>mysql&gt; select distinct deptno,job from emp;      (联合去重多个字段)
mysql&gt; select count(distinct job),job from emp; （统计所有岗位数量，去重）
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL修改root密码以及改密后仍可直接登录问题]]></title>
        <id>https://geckoc.github.io/post/mysql-xiu-gai-root-mi-ma-yi-ji-gai-mi-hou-reng-ke-zhi-jie-deng-lu-wen-ti/</id>
        <link href="https://geckoc.github.io/post/mysql-xiu-gai-root-mi-ma-yi-ji-gai-mi-hou-reng-ke-zhi-jie-deng-lu-wen-ti/">
        </link>
        <updated>2020-07-31T11:37:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mysql修改root密码">MySQL修改root密码</h3>
<ul>
<li>
<p>进入mysql控制台</p>
<pre><code>mysql&gt; use mysql;
Database changed
mysql&gt; update user set password = PASSWORD('你想要修改的密码') where user = 'root';
</code></pre>
</li>
<li>
<p>如果报错，则是新版变动问题</p>
<pre><code>无报错的话，直接输入
mysql&gt; flush privileges;   //刷新表，使密码生效
-----------------------------------------
新版---&gt;
mysql&gt; update user set authentication_string = PASSWORD('你想要修改的密码') 
     &gt; where user = 'root';
     &gt; 最后仍然需要刷新表
</code></pre>
</li>
<li>
<p>为什么MySQL设置密码后，仍可以不输入密码直接登录？</p>
<p>之前设置了密码，但输入mysql后，可直接进入mysql，而输入mysql -uroot -p，则需要输入密码，这是为什么呢？</p>
<ul>
<li>原来是因为数据库里面有空用户</li>
</ul>
<pre><code>use mysql;
select * from user where user='';  // 找出空账户，如果有则删除
delete from user where user = '';  // 删除空账户
flush privileges;		// 刷新表，使其生效
exit;
</code></pre>
</li>
<li>
<p><strong>注意</strong>：<strong>必要时需要重启MySQL服务器</strong></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaSE语法进阶重点提炼]]></title>
        <id>https://geckoc.github.io/post/javase-yu-fa-jin-jie-chong-dian-ti-lian/</id>
        <link href="https://geckoc.github.io/post/javase-yu-fa-jin-jie-chong-dian-ti-lian/">
        </link>
        <updated>2020-07-25T05:16:31.000Z</updated>
        <content type="html"><![CDATA[<h4 id="about-array"><em>About Array</em></h4>
<ol>
<li>
<p>Java语言中的数组Array是一种引用数据类型，数组的父类是Object；</p>
</li>
<li>
<p>数组实际是一种容器，可以同时容纳多个元素（数组是一个数据集合）字面意思是一组数据；</p>
</li>
<li>
<p>数组当中可以存储基本数据类型，也可以存储引用数据类型；</p>
</li>
<li>
<p>数组是引用数据类型，所以数组对象是堆内存当中的； （存放在堆内存中）</p>
</li>
<li>
<p>数组当中如果存储的是&quot;Java对象&quot;的话，实际上存储的是对象的引用(内存地址)；</p>
</li>
<li>
<p>数组一旦创建，长度不可变；（数组长度不可变）</p>
</li>
<li>
<p>数组的分类：一维数组、二维数组、三维数组....</p>
</li>
<li>
<p>所有数组都有length属性(Java自带的)，用来获取数组中元素的个数；</p>
</li>
<li>
<p>Java中数组中元素要求类型统一</p>
</li>
<li>
<p>数组在内存方面存储的时候，数组中的元素内存地址是连续的（有规律的，排列好的）紧挨着的，数组是一种数据结构</p>
</li>
<li>
<p>数组中首元素的内存地址作为整个数组对象的内存地址</p>
</li>
<li>
<p>数组中每一个元素都是有下标的,下标从0开始，以1递增，最后一个元素的下标是: length-1;</p>
</li>
<li>
<p>数组这种数据结构的优点和缺点？</p>
<ul>
<li>
<p>优点：查询/检索某个下标上的元素时效率极高，可以说是查询效率最高的一个数据结构；</p>
</li>
<li>
<p><strong>为什么查询效率高？</strong><br>
1、每一个元素的内存地址在空间存储上是连续的；<br>
2、每一个元素的类型相同，所以占用空间相同；<br>
3、知道第一个元素内存地址，知道元素占用空间，知道下标，可通过数学表达式快速计算<br>
出某一个下标上元素的内存地址，直接定位所以效率是最高的；</p>
<p>数组中存储100个元素，或者100万个元素，在查询/检索方面，效率是相同的；</p>
</li>
<li>
<p>缺点：由于数组上元素的内存地址是连续的，所以在数组上随机增删元素时，效率较低，因增删元素会涉及到后面元素统一向前或向后位移的操作；</p>
</li>
<li>
<p>数组不能存储大数据类型，为什么？</p>
<ul>
<li>因为很难在内存空间上找到一块特别大的连续的内存空间</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意：对于数组最后一个元素的增删，效率是不会影响的</strong></p>
<hr>
<pre><code>//		静态初始化数组
		int[] i = {12,123,124,325,523};
		for (int j = 0; j &lt; i.length; j++) {
			System.out.println(i[j]);
		}
		System.out.println(i[i.length-1]);
		
//		动态初始化数组
		Object[] obj = new Object[5];
		for (int j = 0; j &lt; obj.length; j++) {
			System.out.println(obj[j]);
		}
</code></pre>
<pre><code>/*
 * 	一维数组深入理解：数组中存储的类型为引用数据类型
 * 	对于数组来说，实际上只能存户java对象的“内存地址”，
 * 	数组中存储的每个元素是“引用”
 */
public class ArrayDeep01 {
	public static void main(String[] args) {
		Animal a1 = new Animal();
		Animal a2 = new Animal();
		Animal[] animals = {a1 , a2};
		for (int i = 0; i &lt; animals.length; i++) {
//			Animal animal = animals[i];
//			animal.move();
			animals[i].move(); // 代码合并
			//animals是一个数组 。
			//animals[0]是数组中的一个元素 所以可以调用move()方法
		}
		
		Animal[] anis = new Animal[3];
		anis[0] = new Animal();
//		anis[1] = new Product();类型不匹配，无法转换 数值中元素要求数据类型统一
		anis[2] = new Cat(); // Animal数组中可以存放Cat，因为Cat是Animal的子类
		anis[1] = new Bird(); //多态父类型引用指向子类型对象
		
		anis[0].move();
		anis[1].move();
		anis[2].move();
		System.out.println(&quot;--------------&quot;);
//		当使用子对象特有方法时，需向下类型转换   
		for (int i = 0; i &lt; anis.length; i++) {
			if (anis[i] instanceof Cat) {
				Cat cat = (Cat)anis[i];
				cat.catchMouse();
			}else if (anis[i] instanceof Bird) {
				Bird bird = (Bird)anis[i];
				bird.fly();
			}
		}
	}

}
class Animal{
	public void move() {
		System.out.println(&quot;Animal move...&quot;);
	}
}
class Product{
	
}

class Cat extends Animal{
	public void move() {
		System.out.println(&quot;Cat move...&quot;);
	}
	public void catchMouse() {
		System.out.println(&quot;猫抓老鼠&quot;);
	}
}

class Bird extends Animal{
	public void move() {
		System.out.println(&quot;Bird fly!!!&quot;);
	}
	public void fly() {
		System.out.println(&quot;鸟儿在翱翔&quot;);
	}
}
</code></pre>
<h6 id="关于java一维数组的扩容">关于Java一维数组的扩容</h6>
<pre><code>public class ArrayDeep02 {
	public static void main(String[] args) {
		//数组是如何进行拷贝的？
//		System.arraycopy(src源, srcPos源的起始位置, dest目标, destPos目标起始位置, length长度); 
		
		int[] src = {1 , 23 , 455 , 21 , 24}; //拷贝源
		int[] dest = new int[20];	//目标		
		
		System.arraycopy(src, 0, dest, 5, src.length);
		
		// 遍历目标数组
		for (int i = 0; i &lt; dest.length; i++) {
			System.out.println(dest[i]);
		}
		
		//数组中存储的元素是引用，也可以拷贝
		String[] str = {&quot;xsax&quot;, &quot;sadasd&quot;, &quot;Hello&quot;, &quot;World&quot;, &quot;Copy&quot;};
		String[] deStrings = new String[10];
		System.arraycopy(str, 0, deStrings, 2, str.length);
		for (int i = 0; i &lt; deStrings.length; i++) {
//			System.out.print(deStrings[i] + &quot;\t&quot;);
		}
		
		Object[] objs = {new Object(), new Object(), new Object()};
		Object[] destObj = new Object[10];
		System.out.println(&quot;============&quot;);
		// 拷贝的是对象的内存地址，不是拷贝对象；
		System.arraycopy(objs, 0, destObj, 2, objs.length);
		for (int i = 0; i &lt; destObj.length; i++) {
			System.out.println(destObj[i]);
		}
	}
}
</code></pre>
<h6 id="关于java中的二维数组">关于Java中的二维数组</h6>
<pre><code>/**
*
* Copyright: Copyright (c) 2020 Richard-Chan
* @Description: 关于Java中的二维数组
* 	1. 二维数组是一个特殊的一维数组，特殊在这个数组中每一个元素都是一个一维数组
* 
* 	2. 三维数组是一个特殊的一维数组，特殊在这个数组中每一个元素都是一个二维数组
* 		实际开发中使用最多的是一维数组，二维数组较少用，三维几乎不用
* 
* 	3. 二维数组静态初始化
*		int[][] y = { {100, 200, 300},{234, 234, 987},{290, 876, 230}, {0 , 1} };
*
*---------------------------------------------------------
 */
public class Array2Dimension01 {
	public static void main(String[] args) {
		// 一维数组
		int[] x = {100, 200, 300};
		System.out.println(x.length); //3
		// 二维数组  ,每一个元素都是一个一维数组
		// 二维数组的length属性
		int[][] y = {
				{100, 200, 300},
				{234, 234, 987},
				{290, 876, 230}, {0 , 1}
			};
		System.out.println(y.length); //4
		System.out.println(y[0].length);//3
	}
}
---------------------------------------------------------------
/*
 *  	关于二维数组的读和改
 *  	a[二维数组中一维数组的下标] [一维数组的下标]
 *  
 *  	a[0][0] 表示二维数组中第一个一维数组中的第一个元素
 *  
 *  	a[3][100] 表示二维数组中第四个一维数组中的第101个元素
 *  
 *  	注意：
 */
public class Array2Dimension02 {
	public static void main(String[] args) {
		int[][] y = {
				{100, 200, 300},
				{234, 234, 987},
				{290, 876, 230}, 
				{0 , 1}
			};
		// 取出二维数组中的元素
		int[] y0 = y[0];
		int x1 = y0[0];
		System.out.println(x1);
		//合并以上代码
		System.out.println(y[0][0]);
		
		//取出第二个一维数组中的第三个元素
		
		//改
		y[0][0] = 999;  //注意下标越界问题
		
	}
}
</code></pre>
<h6 id="二维数组的遍历">二维数组的遍历</h6>
<pre><code>public class Array2Dimension03 {
	public static void main(String[] args) {
		String[][] dimensionArray = {
				{&quot;Java&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;c#&quot;, &quot;PHP&quot;},
				{&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;},
				{&quot;Jack&quot;, &quot;Tom&quot;, &quot;Gilfoyle&quot;, &quot;Denish&quot;, &quot;Richard&quot;}
		};
		
		// 遍历二维数组
		for (int i = 0; i &lt; dimensionArray.length; i++) {  //外层循环 （负责纵向）
//			String[] array = dimensionArray[i]; // 一维数组
			// 遍历一维数组
			for (int j = 0; j &lt; dimensionArray[i].length; j++) {
				System.out.print(dimensionArray[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
}
</code></pre>
<h4 id="about-exception"><em>About Exception</em></h4>
<ul>
<li>什么是异常，异常在Java中的作用
<ol>
<li>程序执行过程中出现的不正常情况，叫做异常</li>
<li>java把异常信息打印输出到控制台，供开发者参考 （信息是JVM打印的）</li>
<li>看到后可以修改，让程序更加完善、健壮</li>
<li>异常在Java中以类的形式存在，只要是类就可以创建对象</li>
</ol>
</li>
</ul>
<p><strong>对于异常的理解</strong></p>
<ul>
<li>
<p>java的异常处理机制</p>
<ol>
<li>
<p>异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？</p>
<ul>
<li>我们可以使用UML图来描述一下继承结构。</li>
<li>画UML图有很多工具，例如：Rational Rose（收费的）、starUML等....</li>
<li>Object</li>
<li>Object下有Throwable（可抛出的）</li>
<li>Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）</li>
<li>Exception下有两个分支：</li>
<li>Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</li>
<li>RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</li>
</ul>
</li>
<li>
<p>编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。</p>
<ul>
<li>编译时异常因为什么而得名？</li>
<li>因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。</li>
<li>所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。</li>
<li>因为异常的发生就是new异常对象。</li>
</ul>
</li>
<li>
<p>编译时异常和运行时异常的区别？</p>
<ul>
<li>
<p>编译时异常一般发生的概率比较高。</p>
<ul>
<li>举个例子：
<ul>
<li>
<p>你看到外面下雨了，倾盆大雨的。</p>
</li>
<li>
<p>你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。</p>
</li>
<li>
<p>而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。</p>
</li>
<li>
<p>“拿一把伞”就是对“生病异常”发生之前的一种处理方式。</p>
</li>
<li>
<p>对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>运行时异常一般发生的概率比较低。</p>
<ul>
<li>举个例子：
<ul>
<li>小明走在大街上，可能会被天上的飞机轮子砸到。</li>
<li>被飞机轮子砸到也算一种异常。</li>
<li>但是这种异常发生概率较低。</li>
<li>在出门之前你没必要提前对这种发生概率较低的异常进行预处理。</li>
<li>如果你预处理这种异常，你将活的很累。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。</p>
</li>
<li>
<p>假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，</p>
</li>
<li>
<p>所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？</p>
<ul>
<li>首先，如果这样的话，程序肯定是绝对的安全的。</li>
<li>但是程序员编写程序太累，代码到处都是处理异常的代码。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编译时异常还有其他名字：</p>
<ul>
<li>受检异常（受控异常）：CheckedException</li>
</ul>
</li>
<li>
<p>运行时异常还有其它名字：</p>
<ul>
<li>未受检异常（非受控异常）：UnCheckedException</li>
</ul>
</li>
<li>
<p>再次强调：所有异常都是发生在运行阶段的。</p>
</li>
<li>
<p>Java语言中对异常的处理包括两种方式：</p>
<ul>
<li>
<p>第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。抛给上一级。</p>
</li>
<li>
<p>第二种方式：使用try..catch语句进行异常的捕捉。这件事发生了，谁也不知道，因为我给抓住了。</p>
</li>
<li>
<p>举个例子：</p>
<ul>
<li>
<p>我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，“损失1000元”这可以看做是一个异常发生了。我有两种处理方式，</p>
</li>
<li>
<p>第一种方式：我把这件事告诉我的领导【异常上抛】</p>
</li>
<li>
<p>第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】</p>
</li>
<li>
<p>张三 --&gt; 李四 ---&gt; 王五 --&gt; CEO</p>
</li>
</ul>
</li>
<li>
<p>思考：</p>
<ul>
<li>异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要</li>
<li>对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</p>
</li>
<li>
<p>不建议在main()方法中调用 throws 上抛异常，因为一旦出现异常</p>
</li>
</ol>
<ul>
<li>main()会直接抛给JVM，终止程序运行</li>
<li>在main方法中一般使用 try...catch 捕捉异常</li>
<li>throws()可以上抛多个异常，以逗号隔开</li>
</ul>
</li>
</ul>
<pre><code>* 异常对象中两个非常重要的方法
* 		1、获取异常的描述信息
* 			String msg = exception.getMessage(); 
* 
*		2、打印异常追踪的堆栈信息
*			e.printStackTrace();
/**
* Copyright: Copyright (c) 2020 Richard-Chan
* 
* @Description: 深入理解 try ... catch..
*		1、catch后面的异常类型可以是具体异常类型也可以是父类
*		2、catch后面可以写多个，建议catch的时候精确的一个个处理，利于调试
*		3、catch写多个的时候，自上而下必须遵守从小到大的原则
*
*---------------------------------------------------------
 */
public class TryCatchDeep {
	public static void main(String[] args) {
		try {
			FileInputStream fis = new FileInputStream(&quot;&quot;);
			fis.read();
			fis.close();
		} catch (FileNotFoundException e) {
			System.out.println(&quot;文件不存在&quot;);
		} catch (IOException e) {
			e.printStackTrace();
		}
		tryCatch();
	}
	
	/*
	 * 	JDK8中的新特性，可以使用 | 或 捕捉多个异常
	 */
	public static void tryCatch() {
		try {
			FileInputStream fis = new FileInputStream(&quot;&quot;);
			System.out.println(fis);
			System.out.println(100 / 0);
		} catch (FileNotFoundException | ArithmeticException | NullPointerException e) {
			System.out.println(&quot;文件不存在？算数异常？空指针异常？都有可能&quot;);
		}
	}
}
</code></pre>
<p><strong><em>Finally</em> 语句</strong></p>
<pre><code>/*      关于try...catch...中的子句Finally
*		1、即使try中出现异常，在finally子句中的代码是最后执行且一定会执行的
*			
*		2、而且必须和try...catch语句一起使用
*
*		3、通常在finally语句中完成资源的释放/关闭,因为finally语句中的代码比较有保障
 * try不可以单独使用
 * finally语句可以和try联合使用
 * finally语句中的代码是一定会执行的
 * exit()可以终止finally
 * 
 */
public class FinallyTry {
	public static void main(String[] args) {
		
		/*
		 * 	以下代码执行顺序：
		 * 	try &gt; finally &gt; return
		 * 	finally语句中即使有return也会执行
		 * 	finally语句
		 */
		try {
			System.out.println(&quot;try....&quot;);
//			System.exit(0); 退出JVM，finally语句不执行
			return;
		} finally {
			System.out.println(&quot;finally...&quot;);
		}
		//以下代码一定不会执行，所以编译错误，上面已经执行return
		//System.out.println(&quot;Hello Gilfoyle&quot;);
	}
}
</code></pre>
<p><strong><em>Finally</em></strong> <strong>面试题</strong></p>
<pre><code>public class FinallyInterview {
	public static void main(String[] args) {
		int result = finallyIV();
		System.out.println(result); // 100
	}
	/*
	 * Java语法规则，必须遵循自上而下的原则
	 * return语句必须保证是最后执行的
	 * return语句一旦执行整个方法必须结束
	 */
	public static int finallyIV() {
		int i = 100;
		try {
			return i;
		} finally {
			i++;
		}
	}
}
</code></pre>
<p><strong><em>final、finally、finalize</em></strong> <strong>的区别</strong></p>
<ul>
<li>final（关键字）</li>
<li>final 修饰的变量无法重新赋值</li>
<li>final 修饰的类无法继承</li>
<li>final 修饰的方法无法覆盖（重写）</li>
<li>finally（关键字）</li>
<li>finally和try一起联用</li>
<li>finally语句块中的代码是必须执行的</li>
<li>finalize （标识符）是一个Object类中的方法名, 这个方法是由垃圾回收器GC调用的</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程模拟车站售票]]></title>
        <id>https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/</id>
        <link href="https://geckoc.github.io/post/java-duo-xian-cheng-mo-ni-che-zhan-shou-piao/">
        </link>
        <updated>2020-07-12T18:11:23.000Z</updated>
        <summary type="html"><![CDATA[<p>深入理解synchronized，以及多线程使用，这是较为经典的例子</p>
]]></summary>
        <content type="html"><![CDATA[<p>深入理解synchronized，以及多线程使用，这是较为经典的例子</p>
<!-- more -->
<blockquote>
<p>一开始我花了比较多时间，去判断当票数为0时，Thread还会继续启动，返回-1，-2显示购票成功<br>
解决：将synchronized同步代码片放到run方法下，且while(true)，一开始写成while(user.getRemainingTicket())，改过后，线程仍会启动进入run()但会返回无法购票提示，不再显示购票成功</p>
</blockquote>
<ul>
<li>本来写的代码注释较少，为了方便阅读，适当加了注释<br>
<s>1. TicketAccount (购票账户)</s><br>
- （改进，其实可以在run添加同购票方法，有需求也可在账户类编写）<br>
- （改进代码均会在下方贴出）</li>
</ul>
<ol start="2">
<li>TicketBusinessThread（线程）</li>
<li>TicketBusinessSystem（测试类）</li>
</ol>
<h4 id="talk-is-cheapshow-me-the-code"><em>Talk is cheap，show me the code.</em></h4>
<pre><code>public class TicketAccount {
	private int remainingTicket;  //票数
// 我是直接初始化给定票数值测试，你也可以带有参构造，自己想赋值多少都可以
	public TicketAccount() {
		this.remainingTicket = 100;
	}
	
	public int getRemainingTicket() {
		return remainingTicket;
	}

	public void setRemainingTicket(int after) {
		this.remainingTicket = after;
	}
// 购票方法
	public void ticketBuy(int remainingTicket) {
//			购票前
			int before = this.getRemainingTicket();
//			购票后
			int after = before - remainingTicket;
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
//			更新票数数据
			this.setRemainingTicket(after);
	}
}
</code></pre>
<pre><code>public class TicketBusinessThread implements Runnable{
	private TicketAccount ticketAccount ;
	public TicketBusinessThread(TicketAccount ticketAccount) {
		this.ticketAccount = ticketAccount;
	}
	@Override
	public void run() {
		int tick = 1;
        /*
		 *  这里花费了一些时间，由于while()语法，前面已说过不再赘述
		 *  注：synchronized同步代码块需在while内
		 *  否则会一个线程直接买完票，其他线程窗口无用
		 */
		while (true) {
		    synchronized (ticketAccount) {
		    	if (this.ticketAccount.getRemainingTicket() &gt; 0) {
		    		ticketAccount.ticketBuy(tick);
		    		System.out.println(&quot;恭喜使用&quot;+Thread.currentThread().getName()+&quot;购票成功&quot;+&quot;剩余票数为：&quot;
                    +this.ticketAccount.getRemainingTicket());
		    	}else {
		    		System.out.println(&quot;不好意思，票已售完&quot;);
		    		break;
		    	}
			}
		}
	}
}
</code></pre>
<pre><code>public class TicketBusinessSystem {
	public static void main(String[] args) {
		TicketAccount ticketAccount1 = new TicketAccount();
        // 创建线程对象，传入可运行类
		Thread tickBuy_one = new Thread(new TicketBusinessThread(ticketAccount1));
		Thread tickBuy_two = new Thread(new TicketBusinessThread(ticketAccount1));
		Thread tickBuy_three = new Thread(new TicketBusinessThread(ticketAccount1));
		// 设置线程名字
		tickBuy_one.setName(&quot;窗口1&quot;);
		tickBuy_two.setName(&quot;窗口2&quot;);
		tickBuy_three.setName(&quot;窗口3&quot;);
		//线程启动
		tickBuy_one.start();
		tickBuy_two.start();
		tickBuy_three.start();
	}
}
</code></pre>
<blockquote>
<p>以上为初次代码 2020-7-13 02:11:16</p>
</blockquote>
<ol>
<li>[改进] TicketBusinessThread（线程）<br>
<s>2. [改进] TicketBusinessSystem（测试类）</s><br>
-  测试类，与上面如出一辙，删除了有参构造，直接New调用即可</li>
</ol>
<pre><code>public class TicketBusinessThread implements Runnable{
	private int ticks = 100;//定义初始票数，也可构造有参自定义票数
	@Override
	public void run() {
        	while (true) {
                //调用购票方法，票售完跳出死循环
			    payTicket();
			    if (ticks == 0) {
				    System.out.println(&quot;对不起，票已售完...&quot;);
				    break;
			    }
		    }
		}
	}
	
//	定义同步买票方法
	public void payTicket() {
//		判断票是否存在
			synchronized (this) {
				if (ticks &gt; 0) {
//			提高线程安全问题出现概率，使线程堵塞
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName() + &quot;正在卖出第&quot;+ticks+&quot;张票，&quot;+&quot;恭喜购票成功&quot;);
					ticks--;
				}
			}
	}
}
</code></pre>
<ol>
<li>TicketAccount (购票账户)[改]</li>
</ol>
<blockquote>
<p>第一次写是想用户输入购票数，可多张购买；由于每个身份证只能购票一张，重写编写，在账户类定义方法如下：以下只有购票方法代码其他属性根据需求自行定义</p>
</blockquote>
<pre><code>public void ticketBuy() {
		synchronized (this) {
			if (this.getRemainingTicket() &gt; 0) {
//				提高线程安全问题出现概率，使线程堵塞
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + &quot;正在卖出第&quot;+getRemainingTicket()+&quot;张票，&quot;+&quot;恭喜购票成功&quot;);
				int after = --remainingTicket;
				setRemainingTicket(after);
			}	
		}
	}
      
    改于2020-7-13 21:48:39
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gitalk配置教程]]></title>
        <id>https://geckoc.github.io/post/gitalk-pei-zhi-jiao-cheng/</id>
        <link href="https://geckoc.github.io/post/gitalk-pei-zhi-jiao-cheng/">
        </link>
        <updated>2020-07-09T17:42:50.000Z</updated>
        <summary type="html"><![CDATA[<p>gitalk配置分享，使用Gridea初步</p>
]]></summary>
        <content type="html"><![CDATA[<p>gitalk配置分享，使用Gridea初步</p>
<!-- more -->
<h3 id="获得权限">获得权限</h3>
<p>在使用该脚本之前首先要在 GitHub 创建一个新的 Oauth Application</p>
<p><a href="https://github.com/settings/apps">点击此处 Click Here</a></p>
<p>点击Oauth Apps，然后新建<br>
<img src="https://geckoc.github.io//post-images/1594317386736.png" alt="" loading="lazy"></p>
<p>Application name: 随便填写<br>
Homepage URL: 填写博客所在的仓库名。比如我的博客就填写: https://geckoc.github.io/<br>
Application description: 可以不用填写<br>
Authorization callback URL: 如果有把域名通过CNAME解析到仓库上就填写自己的域名。如果没有就填写仓库名即可</p>
<p>点击Register Application就可以创建<br>
接着就可以看到该应用的Client ID和Client Secret</p>
<h3 id="创建仓库">创建仓库</h3>
<p>完成以上步骤后，<a href="https://github.com/new">点此创建</a>仓库来保存评论<br>
<img src="https://geckoc.github.io//post-images/1594318018870.png" alt="" loading="lazy"></p>
<p>比如填写仓库名为Comments，其余都不用填写</p>
<h3 id="配置">配置</h3>
<p>博客配置</p>
<pre><code>&lt;section class=&quot;post-full-comments&quot;&gt;
    {{!-- gittalk --}}
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;
    &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var gitalk = new Gitalk({
            clientID: '修改：之前创建Oauth Apps保存的Client ID',
            clientSecret: '修改：之前创建Oauth Apps保存的Client Secret',
            repo: '修改：之前创建的repo名称，就是前面例子中的Comments',
            owner: '修改：GitHub的个人名称',
            admin: ['修改：GitHub的个人名称'], //这里可以填写具有写权限的用户名列表，用来初始化Issues的
            id: '{{comment_id}}',
            distractionFreeMode: false // Facebook-like distraction free mode
        });
        gitalk.render('gitalk-container');
    &lt;/script&gt;
&lt;/section&gt;
</code></pre>
<p>使用Gridea的话可以直接在设置中打开评论，填写以下内容</p>
<pre><code>clientID: '修改：之前创建Oauth Apps保存的Client ID',
clientSecret: '修改：之前创建Oauth Apps保存的Client Secret',
repo: '修改：之前创建的repo名称，就是前面例子中的Comments',
owner: '修改：GitHub的个人名称',
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[THE LIE WE LIVE]]></title>
        <id>https://geckoc.github.io/post/the-lie-we-live/</id>
        <link href="https://geckoc.github.io/post/the-lie-we-live/">
        </link>
        <updated>2020-07-04T15:27:37.000Z</updated>
        <summary type="html"><![CDATA[<p>人们最喜欢看的内容，不是现实和真相，而是可以让他们意淫的内容。</p>
]]></summary>
        <content type="html"><![CDATA[<p>人们最喜欢看的内容，不是现实和真相，而是可以让他们意淫的内容。</p>
<!-- more -->
<ul>
<li>微博上有不少居心不良的大V，喜欢打着女权的幌子，传播一些很倒风向的言论，比如“你负责赚钱养家，我负责貌美如花”“不舍得给你花钱的男人就是不爱你”“女孩子就应该被宠着”，如果你接触一下微博，你就会惊讶，这些一听就没道理的话，为什么会这么有市场？为什么很多女生听完以后会理直气壮的把这些话当成口号？答案就是——这些内容会让她们爽，让她们心安理得的接受别人的馈赠，不努力却要求别人努力，一身臭毛病还要让别人宠着。网络小说，给男生看的，大多是讲一个要钱没钱、要能力没能力的屌丝，忽然因为某个意外事件，获得了某种超能力，然后混的风生水起，多少女人前仆后继的陪他上床，最后甚至能统治整个宇宙；给女生看的，大多是讲一个长相普普通通的女生，某一天邂逅了一个白马王子，种种机缘巧合之下，她被白马王子追求，捧在手心，或者被n个富二代追求，最后顺理成章嫁入豪门。这些文章，但凡有脑子的人，都知道不现实，但是为什么网络小说全都这么写？就因为这些内容看完以后能让人爽，能让人通过短暂的幻想逃避现实。最残忍的是，很多人幻想的久了，竟然忘了这些事发生的概率多么低，真的以为自己可以屌丝逆袭/嫁入豪门/咸鱼翻身，然后就真的不努力了，因为幻想毁了自己的一生。而当我一板一眼的把这些残忍真相告诉他们的时候，他们竟然接受不了现实，不仅不给我继续，还扬言要屏蔽我...</li>
</ul>
<hr>
<ul>
<li>你并不比自己的父母优秀多少。现在知乎上批判自己父母的声音也很盛，诸多白领们自认为自己的表现远远优于自己的父母。其实，这不过是因为经济结构转型造成的误会。现在在公司的格子间里面哼哧哼哧做PPT的那些人，和当年踩着缝纫机的女工没有本质区别。 现在在各种购物软件上抢红包的那些人，和当年在菜市场上为了一分钱讨价还价的父母也没有区别；现在买个手机非得戴个壳、贴层膜，和当年父母非要给遥控器套个塑料袋也差不多；其实，现在每天刷微博、抖音、知乎的人，跟当年蹲在墙根晒太阳嗑瓜子的，也没什么区别。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[让子弹飞]]></title>
        <id>https://geckoc.github.io/post/rang-zi-dan-fei/</id>
        <link href="https://geckoc.github.io/post/rang-zi-dan-fei/">
        </link>
        <updated>2020-07-04T14:55:59.000Z</updated>
        <summary type="html"><![CDATA[<p>马匪：“我好不容易把女生追到手，该结婚了，居然要30万彩礼”<br>
师爷：“对。”<br>
马匪：“还必须有车有房？”<br>
师爷：“对。”</p>
]]></summary>
        <content type="html"><![CDATA[<p>马匪：“我好不容易把女生追到手，该结婚了，居然要30万彩礼”<br>
师爷：“对。”<br>
马匪：“还必须有车有房？”<br>
师爷：“对。”</p>
<!-- more -->
<p>马匪：“还必须时刻担心回到单身生活?”<br>
师爷：“对。”<br>
马匪：“我不成了跪着要饭的吗?”<br>
师爷：“那要你这么说，结婚的男性就是跪着要饭的，就这，三千万想跪还没这路子呢!”<br>
马匪：“我上大学，学毛概，学马克思，就是因为腿脚不利索，跪不下去!”<br>
师爷：“原来想站着结婚啊?那还是去欧美吧”<br>
马匪：“哎?这我就不明白了，咱们新时代独立女青年怎么就赶不上欧美资本主义的女性？”<br>
师爷：“咱们眼里，你是有志向高远的有为青年。在她们眼里，那你就是跪着要饭的。结婚嘛，跪着，不寒碜。”<br>
马匪：“寒碜!很T.M寒碜!”<br>
师爷：“那你是想站着，还是想结婚呢?”<br>
马匪：“我是想站着，还把婚结了。”<br>
师爷：“结不成。”<br>
马匪：“结不成?”<br>
师爷：“结不成!”<br>
马匪：“这个（年入百万）能不能把婚结了？”<br>
师爷：“能结，跪着。”<br>
马匪：“那这个（英俊帅气）能不能结婚？”<br>
师爷：“能结，好的不一定能找到。”<br>
马匪：“那我这个（年入百万）再加这个（英俊帅气），能不能把婚好好结了？”<br>
师爷：“敢问英雄贵姓？”马匪：“社会主义接班人”</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java集合继承关系图]]></title>
        <id>https://geckoc.github.io/post/java-collection-line/</id>
        <link href="https://geckoc.github.io/post/java-collection-line/">
        </link>
        <updated>2020-07-02T15:23:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""><img src="https://geckoc.github.io//post-images/1595438426995.png" alt="" loading="lazy"></h2>
<figure data-type="image" tabindex="1"><img src="https://geckoc.github.io//post-images/1595438441351.gif" alt="" loading="lazy"></figure>
<ul>
<li>上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而点线边框的是接口，比如Collection，Iterator，List等。</li>
<li><strong>注意</strong>：指出错误--&gt;Iterator的子接口是ListIterrator,而不是图中的<s>LinkIterator</s></li>
</ul>
<hr>
<h3 id="1-iterator-接口迭代器对象">1. <em>Iterator</em> 接口（迭代器对象）</h3>
<ul>
<li>用于迭代遍历集合中的所有元素</li>
<li><em>Collection</em> 通用迭代方法，<em>Map</em> 集合不能使用</li>
<li>包含hashNext(),next(),remove()三种方法
<ol>
<li>hashNext() 如果仍有元素可迭代，则返回 true</li>
<li>next() 让迭代器前进一位且返回所迭代中指向的元素。</li>
<li>remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）</li>
</ol>
</li>
<li>它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious()
<blockquote>
<p>通常无序集合使用Iterator接口，而有序集合使用LinkedIterator接口，可双向遍历</p>
</blockquote>
</li>
</ul>
<pre><code>迭代器：当集合结构发生改变时，迭代器需要重新获取，迭代器不会自动刷新
迭代器相当于生出一个新的快照，迭代时不可使用Collection的remove方法
因为Collection的remove删除的是集合结构里的元素，此时结构发生改变，出现异常
但可用Iterator的remove方法，迭代器的remove删除的是迭代器获取的快照元素
迭代器删除时，会自动跟新迭代器，并且更新集合
如果没有重新获取，会出现异常；
</code></pre>
<h3 id="2-list-中的常用子类">2. <em>List</em> 中的常用子类</h3>
<blockquote>
<p>特有方法<br>
<img src="https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621005955773-608960404.png" alt="" loading="lazy"></p>
</blockquote>
<ul>
<li><em><strong>ArrayList</strong></em>
<ol>
<li>初始化容量为10（底层先创建了一个长度为0 的数组，添加第一个元素时，初始化容量10）</li>
<li>扩容到原容量的1.5倍，建议给定一个预估定值，减少扩容，提高效率</li>
<li>底层为Object[]数组</li>
<li>检索查找效率高，随机增删元素效率低，PS：增删末尾元素不影响效率</li>
</ol>
<blockquote>
<p>检索效率高：因空间存储上内存地址为连续的，知道数据类型占用空间大小，知道元素下标，可通过数学表达式快速计算出元素位置，所以效率高</p>
</blockquote>
<ol start="5">
<li>非线程安全的，无法存储大数据【因在内存空间上很难找到一块连续的大内存】</li>
<li>有序可重复的，元素有下标</li>
</ol>
</li>
<li><em><strong>LinkedList</strong></em>
<ol>
<li>链表数据结构的基本单元是节点 <em>Node</em></li>
<li>LinkedList集合是双向链表结构，元素在空间存储上内存地址不连续</li>
<li>LinkedList集合没有初始化容量，最初没有任何元素，first 和 last 都是 null</li>
<li>优点：随机增删元素效率较高（不涉及到元素位移）内存地址不连续</li>
<li>缺点：查询检索效率较低，每一次查找都需要从头节点开始往下遍历</li>
</ol>
</li>
<li><em><strong>Vector</strong></em>
<ul>
<li>初始化容量为10，底层为数组</li>
<li>扩容后为原容量的两倍</li>
<li>所有方法线程同步，有<em>synchronize</em> 关键字修饰，属于线程安全</li>
<li>效率较低，使用较少</li>
</ul>
</li>
</ul>
<h3 id="3-generic-泛型特性">3. <em>Generic</em> (泛型特性)</h3>
<pre><code>* @Description: JDK5推出的新特性，泛型
* 	1、泛型语法机制，只在程序编译阶段起作用，提供给编译器参考（运行阶段泛型不产生作用）
* 	2、使用泛型的好处：
* 		第一：集合中存储的元素类型统一了；
* 		第二；从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”（强制类型转换）
*	
*	3、泛型的缺点：导致集合中存储的元素缺乏多样性
*		大多数业务，集合中的元素还是统一的，所以泛型得到认可
</code></pre>
<h3 id="4-object类">4. <em>Object</em>类</h3>
<ul>
<li>一个完整的类最好重写Object类中的 <em>toString()、equals()、hashCode()</em> 方法</li>
</ul>
<h3 id="5-集合常见输出方式">5. 集合常见输出方式</h3>
<ul>
<li>Iterator ---&gt; 迭代输出</li>
<li>ListIterator ---&gt; Iterator子接口，适用于双向链表迭代，遍历</li>
<li>Enumeration ---&gt; 枚举</li>
<li>Foreach ---&gt; for增强语句，不使用于需使用下标的环境</li>
</ul>
<blockquote>
<p>在迭代时，不可以通过集合对象的方法操作集合中的元素，因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的放过操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Essentials Collection ]]></title>
        <id>https://geckoc.github.io/post/collection-essential/</id>
        <link href="https://geckoc.github.io/post/collection-essential/">
        </link>
        <updated>2020-06-28T19:00:10.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="collection当中可存放的元素"><em>Collection</em>当中可存放的元素</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="collection当中可存放的元素"><em>Collection</em>当中可存放的元素</h3>
<!-- more -->
<ul>
<li>
<p>没有使用&quot;泛型&quot;之前， <em>Collection</em> 中可以存储Object的所有子类型</p>
</li>
<li>
<p>使用了&quot;泛型&quot;之后，<em>Collection</em> 只能存储某个具体的类型</p>
</li>
</ul>
<blockquote>
<p>集合中不能直接存储基本数据类型和Java对象，只能存储对象的内存地址（引用）<br>
<em>Collection</em>是接口，无法实例化对象</p>
</blockquote>
<h3 id="collection中的常用方法"><em>Collection</em>中的常用方法</h3>
<ul>
<li><strong><em>boolean add(Object e)</em></strong></li>
<li><strong><em>boolean contains(Object o)</em></strong></li>
<li><strong><em>boolean remove(Object o)</em></strong></li>
<li><strong><em>nt size()</em></strong></li>
<li><strong><em>boolean isEmpty()</em></strong></li>
<li><strong><em>Object[] toArray()</em></strong>   <s>把集合转换为数组</s></li>
</ul>
<pre><code>public class ContainTest {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		String s1 = new String(&quot;abc&quot;);
		c.add(s1);
		String s2 = new String(&quot;edf&quot;);
		c.add(s2);
		
		String x = new String(&quot;abc&quot;);
		/*
		 * 	如果此集合包含指定的元素，则返回true 。 
		 * 	更正式地，返回true
		 * 	如果且仅当该集合至少包含一个元素e使得(o==null ? e==null : o.equals(e)) 
		 *  contains底层调用了equals(),而String已经重写了equals方法
		 *	所以比较的不是内存地址 ，而是内容
		 */
		System.out.println(c.contains(x)); //true
	}
}
</code></pre>
<pre><code>public class DeepContains {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		User u1 = new User(&quot;abc&quot;);
		User u2 = new User(&quot;abc&quot;);
		c.add(u1);
		/*
		 * 	User没有重写equals方法，底层Object的equals使用的是==
		 * 	比较的是内存地址，返回false
		 */
//		System.out.println(c.contains(u2));
		/*
		 * 	重写User的equals方法后，返回true
		 * 	比较的是内容
		 */
		System.out.println(c.contains(u2));
		
		Collection collection = new ArrayList();
		String x1 = new String(&quot;jack&quot;);
		String x2 = new String(&quot;jack&quot;);
		collection.add(x1);
		System.out.println(collection.size());
		/*
		 * remove方法底层调用了equals
		 * 	删除x2的时候，既是删除了x1
		 */
		collection.remove(x2);
		System.out.println(collection.size());
		
	}
	
}
class User{
	String name;
	public User() {
		// TODO Auto-generated constructor stub
	}
	public User(String name) {
		
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
}
</code></pre>
<h4 id="结论存放在集合中的类型一种要重写equals方法"><strong><em>结论：存放在集合中的类型，一种要重写equals方法</em></strong></h4>
<hr>
<h3 id="关于集合遍历-迭代器"><strong>关于集合遍历 迭代器</strong></h3>
<ol>
<li><em>boolean hasNext()</em>  如果仍有元素可迭代，则返回 <em>true</em></li>
<li><em>Object next()</em> 让迭代器前进一位且返回所迭代中指向的元素。</li>
<li><em>remove()</em> 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。
<blockquote>
<p><em>Collection</em>通用迭代方法，在<em>Map</em>集合中不能使用</p>
</blockquote>
</li>
</ol>
<ul>
<li>List集合存储元素特点：有序可重复，元素有下标   实现类 <em>ArraysList、LinkedList、Vector</em></li>
<li>Set集合存储元素特点：无序不可重复，元素没有下标  实现类 <em>HashSet、TreeSet</em></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaWeb:The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path]]></title>
        <id>https://geckoc.github.io/post/javaweb/</id>
        <link href="https://geckoc.github.io/post/javaweb/">
        </link>
        <updated>2020-06-28T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jsp页面顶端出现红色的报错信息"><em><strong>JSP页面顶端出现“红色”的报错信息:</strong></em></h2>
<p><em><strong>The superclass &quot;javax.servlet.http.HttpServlet&quot; was not found on the Java Build Path。</strong></em><br>
<em>原来Javaweb工程类中没有添加Tomcat运行时相关类导致。<br>
下面是具体的解决方法：</em></p>
<ol>
<li><em>右击web工程-》属性或Build Path-》Java Build Path-&gt;Libraries-&gt; Add Libray...-&gt;Server Runtime -》Tomcat Server</em></li>
<li><em>切换到Java Build Path界面中的Orader and Export，选择Tomcat。</em></li>
</ol>
<h3 id="注意"><strong>注意</strong></h3>
<p>按以上方法操作时，若打开<em>Server Runtime</em>后一片空白，需要设置<em>Apache</em>服务器。设置方法为：<em>window-&gt;Preferences-&gt;Server-&gt;Runtime Environment -&gt; add --&gt;</em> 选择<em>Apache</em>的版本后点<em>Next</em>，再填入你<em>apache</em>服务器软件的安装（解压后）地址。</p>
]]></content>
    </entry>
</feed>